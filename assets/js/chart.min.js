/*!
 * Chart.js vv3.0.0-beta.5
 * https://www.chartjs.org
 * (c) 2020 Chart.js Contributors
 * Released under the MIT License
 */
!(function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = e() : typeof define === 'function' && define.amd ? define(e) : (t = typeof globalThis !== 'undefined' ? globalThis : t || self).Chart = e() }(this, function () {
  'use strict'; function t (t, e) { for (let n = 0; n < e.length; n++) { const i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function e (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } function n () { return (n = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const i in n) { Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } } return t }).apply(this, arguments) } function i (t, e) { t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e } function r (t) { if (void 0 === t) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called") } return t } const a = typeof window === 'undefined' ? function (t) { return t() } : window.requestAnimationFrame; function o (t, e, n) { const i = n || function (t) { return Array.prototype.slice.call(t) }; let r = !1; let o = []; return function () { for (var n = arguments.length, s = new Array(n), l = 0; l < n; l++) { s[l] = arguments[l] }o = i(s), r || (r = !0, a.call(window, function () { r = !1, t.apply(e, o) })) } } const s = new (function () { function t () { this._request = null, this._charts = new Map(), this._running = !1, this._lastDate = void 0 } const e = t.prototype; return e._notify = function (t, e, n, i) { const r = e.listeners[i] || []; const a = e.duration; r.forEach(function (i) { return i({ chart: t, numSteps: a, currentStep: Math.min(n - e.start, a) }) }) }, e._refresh = function () { const t = this; t._request || (t._running = !0, t._request = a.call(window, function () { t._update(), t._request = null, t._running && t._refresh() })) }, e._update = function () { const t = this; const e = Date.now(); let n = 0; t._charts.forEach(function (i, r) { if (i.running && i.items.length) { for (var a, o = i.items, s = o.length - 1, l = !1; s >= 0; --s) { (a = o[s])._active ? (a.tick(e), l = !0) : (o[s] = o[o.length - 1], o.pop()) }l && (r.draw(), t._notify(r, i, e, 'progress')), r.options.animation.debug && (function (t, e, n, i) { const r = 1e3 / (n - i) | 0; const a = t.ctx; a.save(), a.clearRect(0, 0, 50, 24), a.fillStyle = 'black', a.textAlign = 'right', e && (a.fillText(e, 50, 8), a.fillText(r + ' fps', 50, 18)), a.restore() }(r, o.length, e, t._lastDate)), o.length || (i.running = !1, t._notify(r, i, e, 'complete')), n += o.length } }), t._lastDate = e, n === 0 && (t._running = !1) }, e._getAnims = function (t) { const e = this._charts; let n = e.get(t); return n || (n = { running: !1, items: [], listeners: { complete: [], progress: [] } }, e.set(t, n)), n }, e.listen = function (t, e, n) { this._getAnims(t).listeners[e].push(n) }, e.add = function (t, e) { let n; e && e.length && (n = this._getAnims(t).items).push.apply(n, e) }, e.has = function (t) { return this._getAnims(t).items.length > 0 }, e.start = function (t) { const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(function (t, e) { return Math.max(t, e._duration) }, 0), this._refresh()) }, e.running = function (t) { if (!this._running) { return !1 } const e = this._charts.get(t); return !!(e && e.running && e.items.length) }, e.stop = function (t) { const e = this._charts.get(t); if (e && e.items.length) { for (let n = e.items, i = n.length - 1; i >= 0; --i) { n[i].cancel() }e.items = [], this._notify(t, e, Date.now(), 'complete') } }, e.remove = function (t) { return this._charts.delete(t) }, t }())(); function l () {} let c; const u = (c = 0, function () { return c++ }); function h (t) { return t == null } function f (t) { if (Array.isArray && Array.isArray(t)) { return !0 } const e = Object.prototype.toString.call(t); return e.substr(0, 7) === '[object' && e.substr(-6) === 'Array]' } function d (t) { return t !== null && Object.prototype.toString.call(t) === '[object Object]' } const p = function (t) { return (typeof t === 'number' || t instanceof Number) && isFinite(+t) }; function g (t, e) { return void 0 === t ? e : t } function v (t, e, n) { if (t && typeof t.call === 'function') { return t.apply(n, e) } } function m (t, e, n, i) { let r, a, o; if (f(t)) { if (a = t.length, i) { for (r = a - 1; r >= 0; r--) { e.call(n, t[r], r) } } else { for (r = 0; r < a; r++) { e.call(n, t[r], r) } } } else if (d(t)) { for (a = (o = Object.keys(t)).length, r = 0; r < a; r++) { e.call(n, t[o[r]], o[r]) } } } function b (t, e) { let n, i, r, a; if (!t || !e || t.length !== e.length) { return !1 } for (n = 0, i = t.length; n < i; ++n) { if (r = t[n], a = e[n], r.datasetIndex !== a.datasetIndex || r.index !== a.index) { return !1 } } return !0 } function x (t) { if (f(t)) { return t.map(x) } if (d(t)) { for (var e = Object.create(null), n = Object.keys(t), i = n.length, r = 0; r < i; ++r) { e[n[r]] = x(t[n[r]]) } return e } return t } function y (t) { return !['__proto__', 'prototype', 'constructor'].includes(t) } function _ (t, e, n, i) { if (y(t)) { const r = e[t]; const a = n[t]; d(r) && d(a) ? w(r, a, i) : e[t] = x(a) } } function w (t, e, n) { const i = f(e) ? e : [e]; const r = i.length; if (!d(t)) { return t } for (let a = (n = n || {}).merger || _, o = 0; o < r; ++o) { if (d(e = i[o])) { for (let s = Object.keys(e), l = 0, c = s.length; l < c; ++l) { a(s[l], t, e, n) } } } return t } function M (t, e) { return w(t, e, { merger: k }) } function k (t, e, n) { if (y(t)) { const i = e[t]; const r = n[t]; d(i) && d(r) ? M(i, r) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = x(r)) } } function S (t, e) { if (e.length < 3) { return t[e] } for (let n = e.split('.'), i = 0, r = n.length; i < r; ++i) { const a = n[i]; if (!(a in t)) { return } t = t[a] } return t } function P (t) { return t.charAt(0).toUpperCase() + t.slice(1) } function D (t, e) { if (!e) { return t } for (let n = e.split('.'), i = 0, r = n.length; i < r; ++i) { const a = n[i]; t = t[a] || (t[a] = Object.create(null)) } return t } const A = new (function () { function t () { this.color = 'rgba(0,0,0,0.1)', this.elements = {}, this.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'], this.font = { color: '#666', family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: 'normal', lineHeight: 1.2, weight: null, lineWidth: 0, strokeStyle: void 0 }, this.interaction = { mode: 'nearest', intersect: !0 }, this.hover = { onHover: null }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.responsive = !0, this.showLine = !0, this.plugins = {}, this.scale = void 0, this.doughnut = void 0, this.scales = {}, this.controllers = void 0 } const e = t.prototype; return e.set = function (t, e) { return w(D(this, t), e) }, e.get = function (t) { return D(this, t) }, e.route = function (t, e, n, i) { let r; const a = D(this, t); const o = D(this, n); const s = '_' + e; Object.defineProperties(a, ((r = {})[s] = { writable: !0 }, r[e] = { enumerable: !0, get () { return g(this[s], o[i]) }, set (t) { this[s] = t } }, r)) }, t }())(); const T = Math.PI; const O = 2 * T; const E = O + T; const L = Number.POSITIVE_INFINITY; const C = T / 180; const R = T / 2; const F = T / 4; const z = 2 * T / 3; function I (t) { let e; const n = []; const i = Math.sqrt(t); for (e = 1; e < i; e++) { t % e == 0 && (n.push(e), n.push(t / e)) } return i === (0 | i) && n.push(i), n.sort(function (t, e) { return t - e }).pop(), n } const B = Math.log10 || function (t) { const e = Math.log(t) * Math.LOG10E; const n = Math.round(e); return t === Math.pow(10, n) ? n : e }; function V (t) { return !isNaN(parseFloat(t)) && isFinite(t) } function W (t, e, n) { return Math.abs(t - e) < n } function N (t, e) { const n = Math.round(t); return n - e <= t && n + e >= t } function H (t, e, n) { let i, r, a; for (i = 0, r = t.length; i < r; i++) { a = t[i][n], isNaN(a) || (e.min = Math.min(e.min, a), e.max = Math.max(e.max, a)) } } const j = Math.sign ? function (t) { return Math.sign(t) } : function (t) { return (t = +t) === 0 || isNaN(t) ? t : t > 0 ? 1 : -1 }; function Y (t) { return t * (T / 180) } function U (t) { return t * (180 / T) } function X (t) { if (p(t)) { for (var e = 1, n = 0; Math.round(t * e) / e !== t;) { e *= 10, n++ } return n } } function $ (t, e) { const n = e.x - t.x; const i = e.y - t.y; const r = Math.sqrt(n * n + i * i); let a = Math.atan2(i, n); return a < -0.5 * T && (a += O), { angle: a, distance: r } } function K (t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) } function q (t, e) { return (t - e + E) % O - T } function G (t) { return (t % O + O) % O } function Z (t, e, n) { const i = G(t); const r = G(e); const a = G(n); const o = G(r - i); const s = G(a - i); const l = G(i - r); const c = G(i - a); return i === r || i === a || o > s && l < c } function Q (t, e, n) { return Math.max(e, Math.min(n, t)) } function J (t) { return Q(t, -32768, 32767) } function tt (t) { return !t || h(t.size) || h(t.family) ? null : (t.style ? t.style + ' ' : '') + (t.weight ? t.weight + ' ' : '') + t.size + 'px ' + t.family } function et (t, e, n, i, r) { let a = e[r]; return a || (a = e[r] = t.measureText(r).width, n.push(r)), a > i && (i = a), i } function nt (t, e, n, i) { let r = (i = i || {}).data = i.data || {}; let a = i.garbageCollect = i.garbageCollect || []; i.font !== e && (r = i.data = {}, a = i.garbageCollect = [], i.font = e), t.save(), t.font = e; let o; let s; let l; let c; let u; let h = 0; const d = n.length; for (o = 0; o < d; o++) { if ((c = n[o]) != null && !0 !== f(c)) { h = et(t, r, a, h, c) } else if (f(c)) { for (s = 0, l = c.length; s < l; s++) { (u = c[s]) == null || f(u) || (h = et(t, r, a, h, u)) } } } t.restore(); const p = a.length / 2; if (p > n.length) { for (o = 0; o < p; o++) { delete r[a[o]] } a.splice(0, p) } return h } function it (t, e, n) { const i = t.currentDevicePixelRatio; const r = n / 2; return Math.round((e - r) * i) / i + r } function rt (t) { t.ctx.clearRect(0, 0, t.width, t.height) } function at (t, e, n, i) { let r; let a; let o; let s; let l; const c = e.pointStyle; const u = e.rotation; const h = e.radius; let f = (u || 0) * C; if (c && typeof c === 'object' && ((r = c.toString()) === '[object HTMLImageElement]' || r === '[object HTMLCanvasElement]')) { return t.save(), t.translate(n, i), t.rotate(f), t.drawImage(c, -c.width / 2, -c.height / 2, c.width, c.height), void t.restore() } if (!(isNaN(h) || h <= 0)) { switch (t.beginPath(), c) { default:t.arc(n, i, h, 0, O), t.closePath(); break; case 'triangle':t.moveTo(n + Math.sin(f) * h, i - Math.cos(f) * h), f += z, t.lineTo(n + Math.sin(f) * h, i - Math.cos(f) * h), f += z, t.lineTo(n + Math.sin(f) * h, i - Math.cos(f) * h), t.closePath(); break; case 'rectRounded':s = h - (l = 0.516 * h), a = Math.cos(f + F) * s, o = Math.sin(f + F) * s, t.arc(n - a, i - o, l, f - T, f - R), t.arc(n + o, i - a, l, f - R, f), t.arc(n + a, i + o, l, f, f + R), t.arc(n - o, i + a, l, f + R, f + T), t.closePath(); break; case 'rect':if (!u) { s = Math.SQRT1_2 * h, t.rect(n - s, i - s, 2 * s, 2 * s); break }f += F; case 'rectRot':a = Math.cos(f) * h, o = Math.sin(f) * h, t.moveTo(n - a, i - o), t.lineTo(n + o, i - a), t.lineTo(n + a, i + o), t.lineTo(n - o, i + a), t.closePath(); break; case 'crossRot':f += F; case 'cross':a = Math.cos(f) * h, o = Math.sin(f) * h, t.moveTo(n - a, i - o), t.lineTo(n + a, i + o), t.moveTo(n + o, i - a), t.lineTo(n - o, i + a); break; case 'star':a = Math.cos(f) * h, o = Math.sin(f) * h, t.moveTo(n - a, i - o), t.lineTo(n + a, i + o), t.moveTo(n + o, i - a), t.lineTo(n - o, i + a), f += F, a = Math.cos(f) * h, o = Math.sin(f) * h, t.moveTo(n - a, i - o), t.lineTo(n + a, i + o), t.moveTo(n + o, i - a), t.lineTo(n - o, i + a); break; case 'line':a = Math.cos(f) * h, o = Math.sin(f) * h, t.moveTo(n - a, i - o), t.lineTo(n + a, i + o); break; case 'dash':t.moveTo(n, i), t.lineTo(n + Math.cos(f) * h, i + Math.sin(f) * h) }t.fill(), e.borderWidth > 0 && t.stroke() } } function ot (t, e) { const n = 0.5; return t.x > e.left - n && t.x < e.right + n && t.y > e.top - n && t.y < e.bottom + n } function st (t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip() } function lt (t) { t.restore() } function ct (t, e, n, i, r) { if (!e) { return t.lineTo(n.x, n.y) } if (r === 'middle') { const a = (e.x + n.x) / 2; t.lineTo(a, e.y), t.lineTo(a, n.y) } else { r === 'after' != !!i ? t.lineTo(e.x, n.y) : t.lineTo(n.x, e.y) } t.lineTo(n.x, n.y) } function ut (t, e, n, i) { if (!e) { return t.lineTo(n.x, n.y) } t.bezierCurveTo(i ? e.controlPointPreviousX : e.controlPointNextX, i ? e.controlPointPreviousY : e.controlPointNextY, i ? n.controlPointNextX : n.controlPointPreviousX, i ? n.controlPointNextY : n.controlPointPreviousY, n.x, n.y) } function ht (t, e, n) { n = n || function (n) { return t[n] < e }; for (var i, r = t.length - 1, a = 0; r - a > 1;) { n(i = a + r >> 1) ? a = i : r = i } return { lo: a, hi: r } } const ft = function (t, e, n) { return ht(t, n, function (i) { return t[i][e] < n }) }; const dt = function (t, e, n) { return ht(t, n, function (i) { return t[i][e] >= n }) }; function pt (t, e, n) { for (var i = 0, r = t.length; i < r && t[i] < e;) { i++ } for (;r > i && t[r - 1] > n;) { r-- } return i > 0 || r < t.length ? t.slice(i, r) : t } const gt = ['push', 'pop', 'shift', 'splice', 'unshift']; function vt (t, e) { t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, '_chartjs', { configurable: !0, enumerable: !1, value: { listeners: [e] } }), gt.forEach(function (e) { const n = '_onData' + P(e); const i = t[e]; Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value () { for (var e = arguments.length, r = new Array(e), a = 0; a < e; a++) { r[a] = arguments[a] } const o = i.apply(this, r); return t._chartjs.listeners.forEach(function (t) { typeof t[n] === 'function' && t[n].apply(t, r) }), o } }) })) } function mt (t, e) { const n = t._chartjs; if (n) { const i = n.listeners; const r = i.indexOf(e); r !== -1 && i.splice(r, 1), i.length > 0 || (gt.forEach(function (e) { delete t[e] }), delete t._chartjs) } } function bt (t) { let e; let n; const i = new Set(); for (e = 0, n = t.length; e < n; ++e) { i.add(t[e]) } if (i.size === n) { return t } const r = []; return i.forEach(function (t) { r.push(t) }), r } function xt (t) { let e = t.parentNode; return e && e.toString() === '[object ShadowRoot]' && (e = e.host), e } function yt (t, e, n) { let i; return typeof t === 'string' ? (i = parseInt(t, 10), t.includes('%') && (i = i / 100 * e.parentNode[n])) : i = t, i } const _t = function (t) { return window.getComputedStyle(t, null) }; function wt (t, e) { return t.currentStyle ? t.currentStyle[e] : _t(t).getPropertyValue(e) } const Mt = ['top', 'right', 'bottom', 'left']; function kt (t, e, n) { const i = {}; n = n ? '-' + n : ''; for (let r = 0; r < 4; r++) { const a = Mt[r]; i[a] = parseFloat(t[e + '-' + a + n]) || 0 } return i.width = i.left + i.right, i.height = i.top + i.bottom, i } function St (t, e) { const n = e.canvas; const i = e.currentDevicePixelRatio; const r = _t(n); const a = r.boxSizing === 'border-box'; const o = kt(r, 'padding'); const s = kt(r, 'border', 'width'); const l = (function (t, e) { let n; let i; const r = t.originalEvent || t; const a = r.touches; const o = a && a.length ? a[0] : r; const s = o.offsetX; const l = o.offsetY; let c = !1; if (s > 0 || l > 0) { n = s, i = l } else { const u = e.getBoundingClientRect(); n = o.clientX - u.left, i = o.clientY - u.top, c = !0 } return { x: n, y: i, box: c } }(t, n)); const c = l.x; const u = l.y; const h = l.box; const f = o.left + (h && s.left); const d = o.top + (h && s.top); let p = e.width; let g = e.height; return a && (p -= o.width + s.width, g -= o.height + s.height), { x: Math.round((c - f) / p * n.width / i), y: Math.round((u - d) / g * n.height / i) } } function Pt (t, e, n, i) { const r = _t(t); const a = kt(r, 'margin'); const o = yt(r.maxWidth, t, 'clientWidth') || L; const s = yt(r.maxHeight, t, 'clientHeight') || L; const l = (function (t, e, n) { let i, r; if (void 0 === e || void 0 === n) { const a = xt(t); if (a) { const o = a.getBoundingClientRect(); const s = _t(a); const l = kt(s, 'border', 'width'); const c = kt(s, 'padding'); e = o.width - c.width - l.width, n = o.height - c.height - l.height, i = yt(s.maxWidth, a, 'clientWidth'), r = yt(s.maxHeight, a, 'clientHeight') } else { e = t.clientWidth, n = t.clientHeight } } return { width: e, height: n, maxWidth: i || L, maxHeight: r || L } }(t, e, n)); let c = l.width; let u = l.height; if (r.boxSizing === 'content-box') { const h = kt(r, 'border', 'width'); const f = kt(r, 'padding'); c -= f.width + h.width, u -= f.height + h.height } return c = Math.max(0, c - a.width), u = Math.max(0, i ? Math.floor(c / i) : u - a.height), { width: Math.min(c, o, l.maxWidth), height: Math.min(u, s, l.maxHeight) } } function Dt (t, e) { const n = t.currentDevicePixelRatio = e || typeof window !== 'undefined' && window.devicePixelRatio || 1; const i = t.canvas; const r = t.width; const a = t.height; i.height = a * n, i.width = r * n, t.ctx.setTransform(n, 0, 0, n, 0, 0), !i.style || i.style.height || i.style.width || (i.style.height = a + 'px', i.style.width = r + 'px') } const At = (function () { let t = !1; try { const e = { get passive () { return t = !0, !1 } }; window.addEventListener('test', null, e), window.removeEventListener('test', null, e) } catch (t) {} return t }()); function Tt (t, e) { const n = wt(t, e); const i = n && n.match(/^(\d+)(\.\d+)?px$/); return i ? +i[1] : void 0 } function Ot (t, e) { return 'native' in t ? { x: t.x, y: t.y } : St(t, e) } function Et (t, e, n, i) { const r = t.controller; const a = t.data; const o = t._sorted; const s = r._cachedMeta.iScale; if (s && e === s.axis && o && a.length) { const l = s._reversePixels ? dt : ft; if (!i) { return l(a, e, n) } if (r._sharedOptions) { const c = a[0]; const u = typeof c.getRange === 'function' && c.getRange(e); if (u) { const h = l(a, e, n - u); const f = l(a, e, n + u); return { lo: h.lo, hi: f.hi } } } } return { lo: 0, hi: a.length - 1 } } function Lt (t, e, n, i, r) { for (let a = t.getSortedVisibleDatasetMetas(), o = n[e], s = 0, l = a.length; s < l; ++s) { for (let c = a[s], u = c.index, h = c.data, f = Et(a[s], e, o, r), d = f.lo, p = f.hi, g = d; g <= p; ++g) { const v = h[g]; v.skip || i(v, u, g) } } } function Ct (t, e, n, i) { const r = []; if (!ot(e, t.chartArea)) { return r } return Lt(t, n, e, function (t, n, a) { t.inRange(e.x, e.y, i) && r.push({ element: t, datasetIndex: n, index: a }) }, !0), r } function Rt (t, e, n, i, r) { const a = (function (t) { const e = t.includes('x'); const n = t.includes('y'); return function (t, i) { const r = e ? Math.abs(t.x - i.x) : 0; const a = n ? Math.abs(t.y - i.y) : 0; return Math.sqrt(Math.pow(r, 2) + Math.pow(a, 2)) } }(n)); let o = Number.POSITIVE_INFINITY; let s = []; if (!ot(e, t.chartArea)) { return s } return Lt(t, n, e, function (t, n, l) { if (!i || t.inRange(e.x, e.y, r)) { const c = t.getCenterPoint(r); const u = a(e, c); u < o ? (s = [{ element: t, datasetIndex: n, index: l }], o = u) : u === o && s.push({ element: t, datasetIndex: n, index: l }) } }), s } function Ft (t, e, n, i) { const r = Ot(e, t); const a = []; const o = n.axis; const s = o === 'x' ? 'inXRange' : 'inYRange'; let l = !1; return (function (t, e) { for (var n, i, r, a = t.getSortedVisibleDatasetMetas(), o = 0, s = a.length; o < s; ++o) { const l = a[o]; n = l.index; for (let c = 0, u = (i = l.data).length; c < u; ++c) { (r = i[c]).skip || e(r, n, c) } } }(t, function (t, e, n) { t[s](r[o], i) && a.push({ element: t, datasetIndex: e, index: n }), t.inRange(r.x, r.y, i) && (l = !0) })), n.intersect && !l ? [] : a } const zt = { modes: { index (t, e, n, i) { const r = Ot(e, t); const a = n.axis || 'x'; const o = n.intersect ? Ct(t, r, a, i) : Rt(t, r, a, !1, i); const s = []; return o.length ? (t.getSortedVisibleDatasetMetas().forEach(function (t) { const e = o[0].index; const n = t.data[e]; n && !n.skip && s.push({ element: n, datasetIndex: t.index, index: e }) }), s) : [] }, dataset (t, e, n, i) { const r = Ot(e, t); const a = n.axis || 'xy'; let o = n.intersect ? Ct(t, r, a, i) : Rt(t, r, a, !1, i); if (o.length > 0) { const s = o[0].datasetIndex; const l = t.getDatasetMeta(s).data; o = []; for (let c = 0; c < l.length; ++c) { o.push({ element: l[c], datasetIndex: s, index: c }) } } return o }, point (t, e, n, i) { return Ct(t, Ot(e, t), n.axis || 'xy', i) }, nearest (t, e, n, i) { return Rt(t, Ot(e, t), n.axis || 'xy', n.intersect, i) }, x (t, e, n, i) { return n.axis = 'x', Ft(t, e, n, i) }, y (t, e, n, i) { return n.axis = 'y', Ft(t, e, n, i) } } }; function It (t, e) { const n = ('' + t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/); if (!n || n[1] === 'normal') { return 1.2 * e } switch (t = +n[2], n[3]) { case 'px':return t; case '%':t /= 100 } return e * t } const Bt = function (t) { return +t || 0 }; function Vt (t) { let e, n, i, r; return d(t) ? (e = Bt(t.top), n = Bt(t.right), i = Bt(t.bottom), r = Bt(t.left)) : e = n = i = r = Bt(t), { top: e, right: n, bottom: i, left: r } } function Wt (t) { let e, n, i, r; return d(t) ? (e = Bt(t.topLeft), n = Bt(t.topRight), i = Bt(t.bottomLeft), r = Bt(t.bottomRight)) : e = n = i = r = Bt(t), { topLeft: e, topRight: n, bottomLeft: i, bottomRight: r } } function Nt (t) { const e = Vt(t); return e.width = e.left + e.right, e.height = e.top + e.bottom, e } function Ht (t, e) { t = t || {}, e = e || A.font; let n = g(t.size, e.size); typeof n === 'string' && (n = parseInt(n, 10)); const i = { color: g(t.color, e.color), family: g(t.family, e.family), lineHeight: It(g(t.lineHeight, e.lineHeight), n), lineWidth: g(t.lineWidth, e.lineWidth), size: n, style: g(t.style, e.style), weight: g(t.weight, e.weight), strokeStyle: g(t.strokeStyle, e.strokeStyle), string: '' }; return i.string = tt(i), i } function jt (t, e, n, i) { let r; let a; let o; let s = !0; for (r = 0, a = t.length; r < a; ++r) { if (void 0 !== (o = t[r]) && (void 0 !== e && typeof o === 'function' && (o = o(e), s = !1), void 0 !== n && f(o) && (o = o[n % o.length], s = !1), void 0 !== o)) { return i && !s && (i.cacheable = !1), o } } } const Yt = ['left', 'top', 'right', 'bottom']; function Ut (t, e) { return t.filter(function (t) { return t.pos === e }) } function Xt (t, e) { return t.filter(function (t) { return !Yt.includes(t.pos) && t.box.axis === e }) } function $t (t, e) { return t.sort(function (t, n) { const i = e ? n : t; const r = e ? t : n; return i.weight === r.weight ? i.index - r.index : i.weight - r.weight }) } function Kt (t, e, n, i) { return Math.max(t[n], e[n]) + Math.max(t[i], e[i]) } function qt (t, e, n) { const i = n.box; const r = t.maxPadding; if (!d(n.pos)) { if (n.size && (t[n.pos] -= n.size), n.size = n.horizontal ? i.height : i.width, t[n.pos] += n.size, i.getPadding) { const a = i.getPadding(); r.top = Math.max(r.top, a.top), r.left = Math.max(r.left, a.left), r.bottom = Math.max(r.bottom, a.bottom), r.right = Math.max(r.right, a.right) } const o = e.outerWidth - Kt(r, t, 'left', 'right'); const s = e.outerHeight - Kt(r, t, 'top', 'bottom'); return o !== t.w || s !== t.h ? (t.w = o, t.h = s, n.horizontal ? o !== t.w : s !== t.h) : void 0 } } function Gt (t, e) { const n = e.maxPadding; function i (t) { const i = { left: 0, top: 0, right: 0, bottom: 0 }; return t.forEach(function (t) { i[t] = Math.max(e[t], n[t]) }), i } return i(t ? ['left', 'right'] : ['top', 'bottom']) } function Zt (t, e, n) { let i; let r; let a; let o; let s; let l; const c = []; for (i = 0, r = t.length; i < r; ++i) { (o = (a = t[i]).box).update(a.width || e.w, a.height || e.h, Gt(a.horizontal, e)), qt(e, n, a) && (l = !0, c.length && (s = !0)), o.fullWidth || c.push(a) } return s && Zt(c, e, n) || l } function Qt (t, e, n) { let i; let r; let a; let o; const s = n.padding; let l = e.x; let c = e.y; for (i = 0, r = t.length; i < r; ++i) { o = (a = t[i]).box, a.horizontal ? (o.left = o.fullWidth ? s.left : e.left, o.right = o.fullWidth ? n.outerWidth - s.right : e.left + e.w, o.top = c, o.bottom = c + o.height, o.width = o.right - o.left, c = o.bottom) : (o.left = l, o.right = l + o.width, o.top = o.fullWidth ? s.top : e.top, o.bottom = o.fullWidth ? n.outerHeight - s.right : e.top + e.h, o.height = o.bottom - o.top, l = o.right) }e.x = l, e.y = c }A.set('layout', { padding: { top: 0, right: 0, bottom: 0, left: 0 } }); const Jt = { addBox (t, e) { t.boxes || (t.boxes = []), e.fullWidth = e.fullWidth || !1, e.position = e.position || 'top', e.weight = e.weight || 0, e._layers = e._layers || function () { return [{ z: 0, draw (t) { e.draw(t) } }] }, t.boxes.push(e) }, removeBox (t, e) { const n = t.boxes ? t.boxes.indexOf(e) : -1; n !== -1 && t.boxes.splice(n, 1) }, configure (t, e, n) { for (var i, r = ['fullWidth', 'position', 'weight'], a = r.length, o = 0; o < a; ++o) { i = r[o], Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } }, update (t, e, i) { if (t) { const r = t.options.layout || {}; const a = { chart: t }; const o = Nt(jt([r.padding], a)); const s = e - o.width; const l = i - o.height; const c = (function (t) { const e = (function (t) { let e; let n; let i; const r = []; for (e = 0, n = (t || []).length; e < n; ++e) { i = t[e], r.push({ index: e, box: i, pos: i.position, horizontal: i.isHorizontal(), weight: i.weight }) } return r }(t)); const n = $t(Ut(e, 'left'), !0); const i = $t(Ut(e, 'right')); const r = $t(Ut(e, 'top'), !0); const a = $t(Ut(e, 'bottom')); const o = Xt(e, 'x'); const s = Xt(e, 'y'); return { leftAndTop: n.concat(r), rightAndBottom: i.concat(s).concat(a).concat(o), chartArea: Ut(e, 'chartArea'), vertical: n.concat(i).concat(s), horizontal: r.concat(a).concat(o) } }(t.boxes)); const u = c.vertical; const h = c.horizontal; const f = Object.freeze({ outerWidth: e, outerHeight: i, padding: o, availableWidth: s, availableHeight: l, vBoxMaxWidth: s / 2 / u.length, hBoxMaxHeight: l / 2 }); const d = n({ maxPadding: n({}, o), w: s, h: l, x: o.left, y: o.top }, o); !(function (t, e) { let n, i, r; for (n = 0, i = t.length; n < i; ++n) { (r = t[n]).horizontal ? (r.width = r.box.fullWidth && e.availableWidth, r.height = e.hBoxMaxHeight) : (r.width = e.vBoxMaxWidth, r.height = r.box.fullWidth && e.availableHeight) } }(u.concat(h), f)), Zt(u, d, f), Zt(h, d, f) && Zt(u, d, f), (function (t) { const e = t.maxPadding; function n (n) { const i = Math.max(e[n] - t[n], 0); return t[n] += i, i }t.y += n('top'), t.x += n('left'), n('right'), n('bottom') }(d)), Qt(c.leftAndTop, d, f), d.x += d.w, d.y += d.h, Qt(c.rightAndBottom, d, f), t.chartArea = { left: d.left, top: d.top, right: d.left + d.w, bottom: d.top + d.h, height: d.h, width: d.w }, m(c.chartArea, function (e) { const i = e.box; n(i, t.chartArea), i.update(d.w, d.h) }) } } }; const te = (function () { function t () {} const e = t.prototype; return e.acquireContext = function (t, e) {}, e.releaseContext = function (t) { return !1 }, e.addEventListener = function (t, e, n) {}, e.removeEventListener = function (t, e, n) {}, e.getDevicePixelRatio = function () { return 1 }, e.getMaximumSize = function (t, e, n, i) { return e = Math.max(0, e || t.width), n = n || t.height, { width: e, height: Math.max(0, i ? Math.floor(e / i) : n) } }, e.isAttached = function (t) { return !0 }, t }()); const ee = (function (t) { function e () { return t.apply(this, arguments) || this } return i(e, t), e.prototype.acquireContext = function (t) { return t && t.getContext && t.getContext('2d') || null }, e }(te)); const ne = (function () { if (typeof Map !== 'undefined') { return Map } function t (t, e) { let n = -1; return t.some(function (t, i) { return t[0] === e && (n = i, !0) }), n } return (function () { function e () { this.__entries__ = [] } return Object.defineProperty(e.prototype, 'size', { get () { return this.__entries__.length }, enumerable: !0, configurable: !0 }), e.prototype.get = function (e) { const n = t(this.__entries__, e); const i = this.__entries__[n]; return i && i[1] }, e.prototype.set = function (e, n) { const i = t(this.__entries__, e); ~i ? this.__entries__[i][1] = n : this.__entries__.push([e, n]) }, e.prototype.delete = function (e) { const n = this.__entries__; const i = t(n, e); ~i && n.splice(i, 1) }, e.prototype.has = function (e) { return !!~t(this.__entries__, e) }, e.prototype.clear = function () { this.__entries__.splice(0) }, e.prototype.forEach = function (t, e) { void 0 === e && (e = null); for (let n = 0, i = this.__entries__; n < i.length; n++) { const r = i[n]; t.call(e, r[1], r[0]) } }, e }()) }()); const ie = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; const re = typeof global !== 'undefined' && global.Math === Math ? global : typeof self !== 'undefined' && self.Math === Math ? self : typeof window !== 'undefined' && window.Math === Math ? window : Function('return this')(); const ae = typeof requestAnimationFrame === 'function' ? requestAnimationFrame.bind(re) : function (t) { return setTimeout(function () { return t(Date.now()) }, 1e3 / 60) }; const oe = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; const se = typeof MutationObserver !== 'undefined'; const le = (function () { function t () { this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = (function (t, e) { let n = !1; let i = !1; let r = 0; function a () { n && (n = !1, t()), i && s() } function o () { ae(a) } function s () { const t = Date.now(); if (n) { if (t - r < 2) { return } i = !0 } else { n = !0, i = !1, setTimeout(o, e) }r = t } return s }(this.refresh.bind(this), 20)) } return t.prototype.addObserver = function (t) { ~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_() }, t.prototype.removeObserver = function (t) { const e = this.observers_; const n = e.indexOf(t); ~n && e.splice(n, 1), !e.length && this.connected_ && this.disconnect_() }, t.prototype.refresh = function () { this.updateObservers_() && this.refresh() }, t.prototype.updateObservers_ = function () { const t = this.observers_.filter(function (t) { return t.gatherActive(), t.hasActive() }); return t.forEach(function (t) { return t.broadcastActive() }), t.length > 0 }, t.prototype.connect_ = function () { ie && !this.connected_ && (document.addEventListener('transitionend', this.onTransitionEnd_), window.addEventListener('resize', this.refresh), se ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, { attributes: !0, childList: !0, characterData: !0, subtree: !0 })) : (document.addEventListener('DOMSubtreeModified', this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0) }, t.prototype.disconnect_ = function () { ie && this.connected_ && (document.removeEventListener('transitionend', this.onTransitionEnd_), window.removeEventListener('resize', this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener('DOMSubtreeModified', this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1) }, t.prototype.onTransitionEnd_ = function (t) { const e = t.propertyName; const n = void 0 === e ? '' : e; oe.some(function (t) { return !!~n.indexOf(t) }) && this.refresh() }, t.getInstance = function () { return this.instance_ || (this.instance_ = new t()), this.instance_ }, t.instance_ = null, t }()); const ce = function (t, e) { for (let n = 0, i = Object.keys(e); n < i.length; n++) { const r = i[n]; Object.defineProperty(t, r, { value: e[r], enumerable: !1, writable: !1, configurable: !0 }) } return t }; const ue = function (t) { return t && t.ownerDocument && t.ownerDocument.defaultView || re }; const he = me(0, 0, 0, 0); function fe (t) { return parseFloat(t) || 0 } function de (t) { for (var e = [], n = 1; n < arguments.length; n++) { e[n - 1] = arguments[n] } return e.reduce(function (e, n) { return e + fe(t['border-' + n + '-width']) }, 0) } function pe (t) { const e = t.clientWidth; const n = t.clientHeight; if (!e && !n) { return he } const i = ue(t).getComputedStyle(t); const r = (function (t) { for (var e = {}, n = 0, i = ['top', 'right', 'bottom', 'left']; n < i.length; n++) { const r = i[n]; const a = t['padding-' + r]; e[r] = fe(a) } return e }(i)); const a = r.left + r.right; const o = r.top + r.bottom; let s = fe(i.width); let l = fe(i.height); if (i.boxSizing === 'border-box' && (Math.round(s + a) !== e && (s -= de(i, 'left', 'right') + a), Math.round(l + o) !== n && (l -= de(i, 'top', 'bottom') + o)), !(function (t) { return t === ue(t).document.documentElement }(t))) { const c = Math.round(s + a) - e; const u = Math.round(l + o) - n; Math.abs(c) !== 1 && (s -= c), Math.abs(u) !== 1 && (l -= u) } return me(r.left, r.top, s, l) } const ge = typeof SVGGraphicsElement !== 'undefined' ? function (t) { return t instanceof ue(t).SVGGraphicsElement } : function (t) { return t instanceof ue(t).SVGElement && typeof t.getBBox === 'function' }; function ve (t) { return ie ? ge(t) ? (function (t) { const e = t.getBBox(); return me(0, 0, e.width, e.height) }(t)) : pe(t) : he } function me (t, e, n, i) { return { x: t, y: e, width: n, height: i } } const be = (function () { function t (t) { this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = me(0, 0, 0, 0), this.target = t } return t.prototype.isActive = function () { const t = ve(this.target); return this.contentRect_ = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight }, t.prototype.broadcastRect = function () { const t = this.contentRect_; return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t }, t }()); const xe = function (t, e) { let n; let i; let r; let a; let o; let s; let l; const c = (i = (n = e).x, r = n.y, a = n.width, o = n.height, s = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object, l = Object.create(s.prototype), ce(l, { x: i, y: r, width: a, height: o, top: r, right: i + a, bottom: o + r, left: i }), l); ce(this, { target: t, contentRect: c }) }; const ye = (function () { function t (t, e, n) { if (this.activeObservations_ = [], this.observations_ = new ne(), typeof t !== 'function') { throw new TypeError('The callback provided as parameter 1 is not a function.') } this.callback_ = t, this.controller_ = e, this.callbackCtx_ = n } return t.prototype.observe = function (t) { if (!arguments.length) { throw new TypeError('1 argument required, but only 0 present.') } if (typeof Element !== 'undefined' && Element instanceof Object) { if (!(t instanceof ue(t).Element)) { throw new TypeError('parameter 1 is not of type "Element".') } const e = this.observations_; e.has(t) || (e.set(t, new be(t)), this.controller_.addObserver(this), this.controller_.refresh()) } }, t.prototype.unobserve = function (t) { if (!arguments.length) { throw new TypeError('1 argument required, but only 0 present.') } if (typeof Element !== 'undefined' && Element instanceof Object) { if (!(t instanceof ue(t).Element)) { throw new TypeError('parameter 1 is not of type "Element".') } const e = this.observations_; e.has(t) && (e.delete(t), e.size || this.controller_.removeObserver(this)) } }, t.prototype.disconnect = function () { this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this) }, t.prototype.gatherActive = function () { const t = this; this.clearActive(), this.observations_.forEach(function (e) { e.isActive() && t.activeObservations_.push(e) }) }, t.prototype.broadcastActive = function () { if (this.hasActive()) { const t = this.callbackCtx_; const e = this.activeObservations_.map(function (t) { return new xe(t.target, t.broadcastRect()) }); this.callback_.call(t, e, t), this.clearActive() } }, t.prototype.clearActive = function () { this.activeObservations_.splice(0) }, t.prototype.hasActive = function () { return this.activeObservations_.length > 0 }, t }()); const _e = typeof WeakMap !== 'undefined' ? new WeakMap() : new ne(); const we = function t (e) { if (!(this instanceof t)) { throw new TypeError('Cannot call a class as a function.') } if (!arguments.length) { throw new TypeError('1 argument required, but only 0 present.') } const n = le.getInstance(); const i = new ye(e, n, this); _e.set(this, i) }; ['observe', 'unobserve', 'disconnect'].forEach(function (t) { we.prototype[t] = function () { let e; return (e = _e.get(this))[t].apply(e, arguments) } }); const Me = void 0 !== re.ResizeObserver ? re.ResizeObserver : we; const ke = { touchstart: 'mousedown', touchmove: 'mousemove', touchend: 'mouseup', pointerenter: 'mouseenter', pointerdown: 'mousedown', pointermove: 'mousemove', pointerup: 'mouseup', pointerleave: 'mouseout', pointerout: 'mouseout' }; const Se = function (t) { return t === null || t === '' }; const Pe = !!At && { passive: !0 }; function De (t, e, n) { t.canvas.removeEventListener(e, n, Pe) } function Ae (t, e, n) { const i = t.canvas; const r = i && xt(i) || i; const a = new MutationObserver(function (t) { const e = xt(r); t.forEach(function (t) { for (let i = 0; i < t.addedNodes.length; i++) { const a = t.addedNodes[i]; a !== r && a !== e || n(t.target) } }) }); return a.observe(document, { childList: !0, subtree: !0 }), a } function Te (t, e, n) { const i = t.canvas; const r = i && xt(i); if (r) { const a = new MutationObserver(function (t) { t.forEach(function (t) { for (let e = 0; e < t.removedNodes.length; e++) { if (t.removedNodes[e] === i) { n(); break } } }) }); return a.observe(r, { childList: !0 }), a } } const Oe = new Map(); let Ee = 0; function Le () { const t = window.devicePixelRatio; t !== Ee && (Ee = t, Oe.forEach(function (e, n) { n.currentDevicePixelRatio !== t && e() })) } function Ce (t, e, n) { const i = t.canvas; const r = i && xt(i); if (r) { const a = o(function (t, e) { const i = r.clientWidth; n(t, e), i < r.clientWidth && n() }, window); const s = new Me(function (t) { const e = t[0]; const n = e.contentRect.width; const i = e.contentRect.height; n === 0 && i === 0 || a(n, i) }); return s.observe(r), (function (t, e) { Oe.size || window.addEventListener('resize', Le), Oe.set(t, e) }(t, a)), s } } function Re (t, e, n) { n && n.disconnect(), e === 'resize' && (function (t) { Oe.delete(t), Oe.size || window.removeEventListener('resize', Le) }(t)) } function Fe (t, e, n) { const i = t.canvas; const r = o(function (e) { t.ctx !== null && n(function (t, e) { const n = ke[t.type] || t.type; const i = St(t, e); const r = i.x; const a = i.y; return { type: n, chart: e, native: t, x: void 0 !== r ? r : null, y: void 0 !== a ? a : null } }(e, t)) }, t, function (t) { const e = t[0]; return [e, e.offsetX, e.offsetY] }); return (function (t, e, n) { t.addEventListener(e, n, Pe) }(i, e, r)), r } const ze = (function (t) { function e () { return t.apply(this, arguments) || this }i(e, t); const n = e.prototype; return n.acquireContext = function (t, e) { const n = t && t.getContext && t.getContext('2d'); return n && n.canvas === t ? ((function (t, e) { const n = t.style; const i = t.getAttribute('height'); const r = t.getAttribute('width'); if (t.$chartjs = { initial: { height: i, width: r, style: { display: n.display, height: n.height, width: n.width } } }, n.display = n.display || 'block', n.boxSizing = n.boxSizing || 'border-box', Se(r)) { const a = Tt(t, 'width'); void 0 !== a && (t.width = a) } if (Se(i)) { if (t.style.height === '') { t.height = t.width / (e.options.aspectRatio || 2) } else { const o = Tt(t, 'height'); void 0 !== o && (t.height = o) } } }(t, e)), n) : null }, n.releaseContext = function (t) { const e = t.canvas; if (!e.$chartjs) { return !1 } const n = e.$chartjs.initial; ['height', 'width'].forEach(function (t) { const i = n[t]; h(i) ? e.removeAttribute(t) : e.setAttribute(t, i) }); const i = n.style || {}; return Object.keys(i).forEach(function (t) { e.style[t] = i[t] }), e.width = e.width, delete e.$chartjs, !0 }, n.addEventListener = function (t, e, n) { this.removeEventListener(t, e); const i = t.$proxies || (t.$proxies = {}); const r = { attach: Ae, detach: Te, resize: Ce }[e] || Fe; i[e] = r(t, e, n) }, n.removeEventListener = function (t, e) { const n = t.$proxies || (t.$proxies = {}); const i = n[e]; i && (({ attach: Re, detach: Re, resize: Re }[e] || De)(t, e, i), n[e] = void 0) }, n.getDevicePixelRatio = function () { return window.devicePixelRatio }, n.getMaximumSize = function (t, e, n, i) { return Pt(t, e, n, i) }, n.isAttached = function (t) { const e = xt(t); return !(!e || !xt(e)) }, e }(te)); const Ie = Object.freeze({ __proto__: null, BasePlatform: te, BasicPlatform: ee, DomPlatform: ze }); const Be = setTimeout; function Ve (t) { return Boolean(t && void 0 !== t.length) } function We () {} function Ne (t) { if (!(this instanceof Ne)) { throw new TypeError('Promises must be constructed via new') } if (typeof t !== 'function') { throw new TypeError('not a function') } this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], $e(t, this) } function He (t, e) { for (;t._state === 3;) { t = t._value }t._state !== 0 ? (t._handled = !0, Ne._immediateFn(function () { const n = t._state === 1 ? e.onFulfilled : e.onRejected; if (n !== null) { let i; try { i = n(t._value) } catch (t) { return void Ye(e.promise, t) }je(e.promise, i) } else { (t._state === 1 ? je : Ye)(e.promise, t._value) } })) : t._deferreds.push(e) } function je (t, e) { try { if (e === t) { throw new TypeError('A promise cannot be resolved with itself.') } if (e && (typeof e === 'object' || typeof e === 'function')) { const n = e.then; if (e instanceof Ne) { return t._state = 3, t._value = e, void Ue(t) } if (typeof n === 'function') { return void $e((i = n, r = e, function () { i.apply(r, arguments) }), t) } }t._state = 1, t._value = e, Ue(t) } catch (e) { Ye(t, e) } let i, r } function Ye (t, e) { t._state = 2, t._value = e, Ue(t) } function Ue (t) { t._state === 2 && t._deferreds.length === 0 && Ne._immediateFn(function () { t._handled || Ne._unhandledRejectionFn(t._value) }); for (let e = 0, n = t._deferreds.length; e < n; e++) { He(t, t._deferreds[e]) }t._deferreds = null } function Xe (t, e, n) { this.onFulfilled = typeof t === 'function' ? t : null, this.onRejected = typeof e === 'function' ? e : null, this.promise = n } function $e (t, e) { let n = !1; try { t(function (t) { n || (n = !0, je(e, t)) }, function (t) { n || (n = !0, Ye(e, t)) }) } catch (t) { if (n) { return } n = !0, Ye(e, t) } }Ne.prototype.catch = function (t) { return this.then(null, t) }, Ne.prototype.then = function (t, e) { const n = new this.constructor(We); return He(this, new Xe(t, e, n)), n }, Ne.prototype.finally = function (t) { const e = this.constructor; return this.then(function (n) { return e.resolve(t()).then(function () { return n }) }, function (n) { return e.resolve(t()).then(function () { return e.reject(n) }) }) }, Ne.all = function (t) { return new Ne(function (e, n) { if (!Ve(t)) { return n(new TypeError('Promise.all accepts an array')) } const i = Array.prototype.slice.call(t); if (i.length === 0) { return e([]) } let r = i.length; function a (t, o) { try { if (o && (typeof o === 'object' || typeof o === 'function')) { const s = o.then; if (typeof s === 'function') { return void s.call(o, function (e) { a(t, e) }, n) } }i[t] = o, --r == 0 && e(i) } catch (t) { n(t) } } for (let o = 0; o < i.length; o++) { a(o, i[o]) } }) }, Ne.resolve = function (t) { return t && typeof t === 'object' && t.constructor === Ne ? t : new Ne(function (e) { e(t) }) }, Ne.reject = function (t) { return new Ne(function (e, n) { n(t) }) }, Ne.race = function (t) { return new Ne(function (e, n) { if (!Ve(t)) { return n(new TypeError('Promise.race accepts an array')) } for (let i = 0, r = t.length; i < r; i++) { Ne.resolve(t[i]).then(e, n) } }) }, Ne._immediateFn = typeof setImmediate === 'function' && function (t) { setImmediate(t) } || function (t) { Be(t, 0) }, Ne._unhandledRejectionFn = function (t) { typeof console !== 'undefined' && console && console.warn('Possible Unhandled Promise Rejection:', t) }; var Ke = { linear (t) { return t }, easeInQuad (t) { return t * t }, easeOutQuad (t) { return -t * (t - 2) }, easeInOutQuad (t) { return (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1) }, easeInCubic (t) { return t * t * t }, easeOutCubic (t) { return (t -= 1) * t * t + 1 }, easeInOutCubic (t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2) }, easeInQuart (t) { return t * t * t * t }, easeOutQuart (t) { return -((t -= 1) * t * t * t - 1) }, easeInOutQuart (t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2) }, easeInQuint (t) { return t * t * t * t * t }, easeOutQuint (t) { return (t -= 1) * t * t * t * t + 1 }, easeInOutQuint (t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2) }, easeInSine (t) { return 1 - Math.cos(t * R) }, easeOutSine (t) { return Math.sin(t * R) }, easeInOutSine (t) { return -0.5 * (Math.cos(T * t) - 1) }, easeInExpo (t) { return t === 0 ? 0 : Math.pow(2, 10 * (t - 1)) }, easeOutExpo (t) { return t === 1 ? 1 : 1 - Math.pow(2, -10 * t) }, easeInOutExpo (t) { return t === 0 ? 0 : t === 1 ? 1 : (t /= 0.5) < 1 ? 0.5 * Math.pow(2, 10 * (t - 1)) : 0.5 * (2 - Math.pow(2, -10 * --t)) }, easeInCirc (t) { return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1) }, easeOutCirc (t) { return Math.sqrt(1 - (t -= 1) * t) }, easeInOutCirc (t) { return (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) }, easeInElastic (t) { let e; let n = 0; return t === 0 ? 0 : t === 1 ? 1 : (n || (n = 0.3), e = n / O * Math.asin(1), -1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * O / n)) }, easeOutElastic (t) { let e; let n = 0; return t === 0 ? 0 : t === 1 ? 1 : (n || (n = 0.3), e = n / O * Math.asin(1), 1 * Math.pow(2, -10 * t) * Math.sin((t - e) * O / n) + 1) }, easeInOutElastic (t) { let e; let n = 0; return t === 0 ? 0 : (t /= 0.5) == 2 ? 1 : (n || (n = 0.45), e = n / O * Math.asin(1), t < 1 ? 1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * O / n) * -0.5 : 1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * O / n) * 0.5 + 1) }, easeInBack (t) { const e = 1.70158; return t * t * ((e + 1) * t - e) }, easeOutBack (t) { const e = 1.70158; return (t -= 1) * t * ((e + 1) * t + e) + 1 }, easeInOutBack (t) { let e = 1.70158; return (t /= 0.5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * 0.5 : 0.5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2) }, easeInBounce (t) { return 1 - Ke.easeOutBounce(1 - t) }, easeOutBounce (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375 }, easeInOutBounce (t) { return t < 0.5 ? 0.5 * Ke.easeInBounce(2 * t) : 0.5 * Ke.easeOutBounce(2 * t - 1) + 0.5 } }; const qe = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }; const Ge = '0123456789ABCDEF'; const Ze = function (t) { return Ge[15 & t] }; const Qe = function (t) { return Ge[(240 & t) >> 4] + Ge[15 & t] }; const Je = function (t) { return (240 & t) >> 4 == (15 & t) }
  /*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */function tn (t) { const e = (function (t) { return Je(t.r) && Je(t.g) && Je(t.b) && Je(t.a) }(t)) ? Ze : Qe; return t ? '#' + e(t.r) + e(t.g) + e(t.b) + (t.a < 255 ? e(t.a) : '') : t } function en (t) { return t + 0.5 | 0 } const nn = function (t, e, n) { return Math.max(Math.min(t, n), e) }; function rn (t) { return nn(en(2.55 * t), 0, 255) } function an (t) { return nn(en(255 * t), 0, 255) } function on (t) { return nn(en(t / 2.55) / 100, 0, 1) } function sn (t) { return nn(en(100 * t), 0, 100) } const ln = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/; const cn = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/; function un (t, e, n) { const i = e * Math.min(n, 1 - n); const r = function (e, r) { return void 0 === r && (r = (e + t / 30) % 12), n - i * Math.max(Math.min(r - 3, 9 - r, 1), -1) }; return [r(0), r(8), r(4)] } function hn (t, e, n) { const i = function (i, r) { return void 0 === r && (r = (i + t / 60) % 6), n - n * e * Math.max(Math.min(r, 4 - r, 1), 0) }; return [i(5), i(3), i(1)] } function fn (t, e, n) { let i; const r = un(t, 1, 0.5); for (e + n > 1 && (e *= i = 1 / (e + n), n *= i), i = 0; i < 3; i++) { r[i] *= 1 - e - n, r[i] += e } return r } function dn (t) { let e; let n; let i; const r = t.r / 255; const a = t.g / 255; const o = t.b / 255; const s = Math.max(r, a, o); const l = Math.min(r, a, o); const c = (s + l) / 2; return s !== l && (i = s - l, n = c > 0.5 ? i / (2 - s - l) : i / (s + l), e = 60 * (e = s === r ? (a - o) / i + (a < o ? 6 : 0) : s === a ? (o - r) / i + 2 : (r - a) / i + 4) + 0.5), [0 | e, n || 0, c] } function pn (t, e, n, i) { return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, n, i)).map(an) } function gn (t, e, n) { return pn(un, t, e, n) } function vn (t) { return (t % 360 + 360) % 360 } function mn (t) { let e; const n = cn.exec(t); let i = 255; if (n) { n[5] !== e && (i = n[6] ? rn(+n[5]) : an(+n[5])); const r = vn(+n[2]); const a = +n[3] / 100; const o = +n[4] / 100; return { r: (e = n[1] === 'hwb' ? (function (t, e, n) { return pn(fn, t, e, n) }(r, a, o)) : n[1] === 'hsv' ? (function (t, e, n) { return pn(hn, t, e, n) }(r, a, o)) : gn(r, a, o))[0], g: e[1], b: e[2], a: i } } } let bn; const xn = { x: 'dark', Z: 'light', Y: 're', X: 'blu', W: 'gr', V: 'medium', U: 'slate', A: 'ee', T: 'ol', S: 'or', B: 'ra', C: 'lateg', D: 'ights', R: 'in', Q: 'turquois', E: 'hi', P: 'ro', O: 'al', N: 'le', M: 'de', L: 'yello', F: 'en', K: 'ch', G: 'arks', H: 'ea', I: 'ightg', J: 'wh' }; const yn = { OiceXe: 'f0f8ff', antiquewEte: 'faebd7', aqua: 'ffff', aquamarRe: '7fffd4', azuY: 'f0ffff', beige: 'f5f5dc', bisque: 'ffe4c4', black: '0', blanKedOmond: 'ffebcd', Xe: 'ff', XeviTet: '8a2be2', bPwn: 'a52a2a', burlywood: 'deb887', caMtXe: '5f9ea0', KartYuse: '7fff00', KocTate: 'd2691e', cSO: 'ff7f50', cSnflowerXe: '6495ed', cSnsilk: 'fff8dc', crimson: 'dc143c', cyan: 'ffff', xXe: '8b', xcyan: '8b8b', xgTMnPd: 'b8860b', xWay: 'a9a9a9', xgYF: '6400', xgYy: 'a9a9a9', xkhaki: 'bdb76b', xmagFta: '8b008b', xTivegYF: '556b2f', xSange: 'ff8c00', xScEd: '9932cc', xYd: '8b0000', xsOmon: 'e9967a', xsHgYF: '8fbc8f', xUXe: '483d8b', xUWay: '2f4f4f', xUgYy: '2f4f4f', xQe: 'ced1', xviTet: '9400d3', dAppRk: 'ff1493', dApskyXe: 'bfff', dimWay: '696969', dimgYy: '696969', dodgerXe: '1e90ff', fiYbrick: 'b22222', flSOwEte: 'fffaf0', foYstWAn: '228b22', fuKsia: 'ff00ff', gaRsbSo: 'dcdcdc', ghostwEte: 'f8f8ff', gTd: 'ffd700', gTMnPd: 'daa520', Way: '808080', gYF: '8000', gYFLw: 'adff2f', gYy: '808080', honeyMw: 'f0fff0', hotpRk: 'ff69b4', RdianYd: 'cd5c5c', Rdigo: '4b0082', ivSy: 'fffff0', khaki: 'f0e68c', lavFMr: 'e6e6fa', lavFMrXsh: 'fff0f5', lawngYF: '7cfc00', NmoncEffon: 'fffacd', ZXe: 'add8e6', ZcSO: 'f08080', Zcyan: 'e0ffff', ZgTMnPdLw: 'fafad2', ZWay: 'd3d3d3', ZgYF: '90ee90', ZgYy: 'd3d3d3', ZpRk: 'ffb6c1', ZsOmon: 'ffa07a', ZsHgYF: '20b2aa', ZskyXe: '87cefa', ZUWay: '778899', ZUgYy: '778899', ZstAlXe: 'b0c4de', ZLw: 'ffffe0', lime: 'ff00', limegYF: '32cd32', lRF: 'faf0e6', magFta: 'ff00ff', maPon: '800000', VaquamarRe: '66cdaa', VXe: 'cd', VScEd: 'ba55d3', VpurpN: '9370db', VsHgYF: '3cb371', VUXe: '7b68ee', VsprRggYF: 'fa9a', VQe: '48d1cc', VviTetYd: 'c71585', midnightXe: '191970', mRtcYam: 'f5fffa', mistyPse: 'ffe4e1', moccasR: 'ffe4b5', navajowEte: 'ffdead', navy: '80', Tdlace: 'fdf5e6', Tive: '808000', TivedBb: '6b8e23', Sange: 'ffa500', SangeYd: 'ff4500', ScEd: 'da70d6', pOegTMnPd: 'eee8aa', pOegYF: '98fb98', pOeQe: 'afeeee', pOeviTetYd: 'db7093', papayawEp: 'ffefd5', pHKpuff: 'ffdab9', peru: 'cd853f', pRk: 'ffc0cb', plum: 'dda0dd', powMrXe: 'b0e0e6', purpN: '800080', YbeccapurpN: '663399', Yd: 'ff0000', Psybrown: 'bc8f8f', PyOXe: '4169e1', saddNbPwn: '8b4513', sOmon: 'fa8072', sandybPwn: 'f4a460', sHgYF: '2e8b57', sHshell: 'fff5ee', siFna: 'a0522d', silver: 'c0c0c0', skyXe: '87ceeb', UXe: '6a5acd', UWay: '708090', UgYy: '708090', snow: 'fffafa', sprRggYF: 'ff7f', stAlXe: '4682b4', tan: 'd2b48c', teO: '8080', tEstN: 'd8bfd8', tomato: 'ff6347', Qe: '40e0d0', viTet: 'ee82ee', JHt: 'f5deb3', wEte: 'ffffff', wEtesmoke: 'f5f5f5', Lw: 'ffff00', LwgYF: '9acd32' }; function _n (t) { bn || ((bn = (function () { let t; let e; let n; let i; let r; const a = {}; const o = Object.keys(yn); const s = Object.keys(xn); for (t = 0; t < o.length; t++) { for (i = r = o[t], e = 0; e < s.length; e++) { n = s[e], r = r.replace(n, xn[n]) }n = parseInt(yn[i], 16), a[r] = [n >> 16 & 255, n >> 8 & 255, 255 & n] } return a }())).transparent = [0, 0, 0, 0]); const e = bn[t.toLowerCase()]; return e && { r: e[0], g: e[1], b: e[2], a: e.length === 4 ? e[3] : 255 } } function wn (t, e, n) { if (t) { let i = dn(t); i[e] = Math.max(0, Math.min(i[e] + i[e] * n, e === 0 ? 360 : 1)), i = gn(i), t.r = i[0], t.g = i[1], t.b = i[2] } } function Mn (t, e) { return t ? n(e || {}, t) : t } function kn (t) { let e = { r: 0, g: 0, b: 0, a: 255 }; return Array.isArray(t) ? t.length >= 3 && (e = { r: t[0], g: t[1], b: t[2], a: 255 }, t.length > 3 && (e.a = an(t[3]))) : (e = Mn(t, { r: 0, g: 0, b: 0, a: 1 })).a = an(e.a), e } function Sn (t) { return t.charAt(0) === 'r' ? (function (t) { let e; let n; let i; const r = ln.exec(t); let a = 255; if (r) { if (r[7] !== e) { const o = +r[7]; a = 255 & (r[8] ? rn(o) : 255 * o) } return e = +r[1], n = +r[3], i = +r[5], { r: e = 255 & (r[2] ? rn(e) : e), g: n = 255 & (r[4] ? rn(n) : n), b: i = 255 & (r[6] ? rn(i) : i), a } } }(t)) : mn(t) } const Pn = (function () { function t (e) { if (e instanceof t) { return e } let n; let i; let r; let a; const o = typeof e; o === 'object' ? n = kn(e) : o === 'string' && (a = (i = e).length, i[0] === '#' && (a === 4 || a === 5 ? r = { r: 255 & 17 * qe[i[1]], g: 255 & 17 * qe[i[2]], b: 255 & 17 * qe[i[3]], a: a === 5 ? 17 * qe[i[4]] : 255 } : a !== 7 && a !== 9 || (r = { r: qe[i[1]] << 4 | qe[i[2]], g: qe[i[3]] << 4 | qe[i[4]], b: qe[i[5]] << 4 | qe[i[6]], a: a === 9 ? qe[i[7]] << 4 | qe[i[8]] : 255 })), n = r || _n(e) || Sn(e)), this._rgb = n, this._valid = !!n } const n = t.prototype; return n.rgbString = function () { return this._valid ? (t = this._rgb) && (t.a < 255 ? 'rgba(' + t.r + ', ' + t.g + ', ' + t.b + ', ' + on(t.a) + ')' : 'rgb(' + t.r + ', ' + t.g + ', ' + t.b + ')') : this._rgb; let t }, n.hexString = function () { return this._valid ? tn(this._rgb) : this._rgb }, n.hslString = function () { return this._valid ? (function (t) { if (t) { const e = dn(t); const n = e[0]; const i = sn(e[1]); const r = sn(e[2]); return t.a < 255 ? 'hsla(' + n + ', ' + i + '%, ' + r + '%, ' + on(t.a) + ')' : 'hsl(' + n + ', ' + i + '%, ' + r + '%)' } }(this._rgb)) : this._rgb }, n.mix = function (t, e) { const n = this; if (t) { let i; const r = n.rgb; const a = t.rgb; const o = e === i ? 0.5 : e; const s = 2 * o - 1; const l = r.a - a.a; const c = ((s * l == -1 ? s : (s + l) / (1 + s * l)) + 1) / 2; i = 1 - c, r.r = 255 & c * r.r + i * a.r + 0.5, r.g = 255 & c * r.g + i * a.g + 0.5, r.b = 255 & c * r.b + i * a.b + 0.5, r.a = o * r.a + (1 - o) * a.a, n.rgb = r } return n }, n.clone = function () { return new t(this.rgb) }, n.alpha = function (t) { return this._rgb.a = an(t), this }, n.clearer = function (t) { return this._rgb.a *= 1 - t, this }, n.greyscale = function () { const t = this._rgb; const e = en(0.3 * t.r + 0.59 * t.g + 0.11 * t.b); return t.r = t.g = t.b = e, this }, n.opaquer = function (t) { return this._rgb.a *= 1 + t, this }, n.negate = function () { const t = this._rgb; return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this }, n.lighten = function (t) { return wn(this._rgb, 2, t), this }, n.darken = function (t) { return wn(this._rgb, 2, -t), this }, n.saturate = function (t) { return wn(this._rgb, 1, t), this }, n.desaturate = function (t) { return wn(this._rgb, 1, -t), this }, n.rotate = function (t) { return (function (t, e) { let n = dn(t); n[0] = vn(n[0] + e), n = gn(n), t.r = n[0], t.g = n[1], t.b = n[2] }(this._rgb, t)), this }, e(t, [{ key: 'valid', get () { return this._valid } }, { key: 'rgb', get () { const t = Mn(this._rgb); return t && (t.a = on(t.a)), t }, set (t) { this._rgb = kn(t) } }]), t }()); function Dn (t) { return new Pn(t) } const An = function (t) { return t instanceof CanvasGradient || t instanceof CanvasPattern }; function Tn (t) { return An(t) ? t : Dn(t) } function On (t) { return An(t) ? t : Dn(t).saturate(0.5).darken(0.1).hexString() } const En = 'transparent'; const Ln = { boolean (t, e, n) { return n > 0.5 ? e : t }, color (t, e, n) { const i = Tn(t || En); const r = i.valid && Tn(e || En); return r && r.valid ? r.mix(i, n).hexString() : e }, number (t, e, n) { return t + (e - t) * n } }; const Cn = (function () { function t (t, e, n, i) { const r = e[n]; i = jt([t.to, i, r, t.from]); const a = jt([t.from, r, i]); this._active = !0, this._fn = t.fn || Ln[t.type || typeof a], this._easing = Ke[t.easing || 'linear'], this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = n, this._from = a, this._to = i, this._promises = void 0 } const e = t.prototype; return e.active = function () { return this._active }, e.update = function (t, e, n) { const i = this; if (i._active) { const r = i._target[i._prop]; const a = n - i._start; const o = i._duration - a; i._start = n, i._duration = Math.floor(Math.max(o, t.duration)), i._loop = !!t.loop, i._to = jt([t.to, e, r, t.from]), i._from = jt([t.from, r, e]) } }, e.cancel = function () { const t = this; t._active && (t.tick(Date.now()), t._active = !1, t._notify(!1)) }, e.tick = function (t) { let e; const n = this; const i = t - n._start; const r = n._duration; const a = n._prop; const o = n._from; const s = n._loop; const l = n._to; if (n._active = o !== l && (s || i < r), !n._active) { return n._target[a] = l, void n._notify(!0) } i < 0 ? n._target[a] = o : (e = i / r % 2, e = s && e > 1 ? 2 - e : e, e = n._easing(Math.min(1, Math.max(0, e))), n._target[a] = n._fn(o, l, e)) }, e.wait = function () { const t = this._promises || (this._promises = []); return new Ne(function (e, n) { t.push({ res: e, rej: n }) }) }, e._notify = function (t) { for (let e = t ? 'res' : 'rej', n = this._promises || [], i = 0; i < n.length; i++) { n[i][e]() } }, t }()); const Rn = ['borderColor', 'backgroundColor']; A.set('animation', { duration: 1e3, easing: 'easeOutQuart', onProgress: l, onComplete: l, colors: { type: 'color', properties: Rn }, numbers: { type: 'number', properties: ['x', 'y', 'borderWidth', 'radius', 'tension'] }, active: { duration: 400 }, resize: { duration: 0 }, show: { colors: { type: 'color', properties: Rn, from: 'transparent' }, visible: { type: 'boolean', duration: 0 } }, hide: { colors: { type: 'color', properties: Rn, to: 'transparent' }, visible: { type: 'boolean', easing: 'easeInExpo' } } }); const Fn = (function () { function t (t, e) { this._chart = t, this._properties = new Map(), this.configure(e) } const e = t.prototype; return e.configure = function (t) { if (d(t)) { const e = this._properties; const i = (function (t) { const e = {}; return Object.keys(t).forEach(function (n) { const i = t[n]; d(i) || (e[n] = i) }), e }(t)); Object.keys(t).forEach(function (r) { const a = t[r]; d(a) && (a.properties || [r]).forEach(function (t) { if (e.has(t)) { if (t === r) { const o = e.get(t); const s = (o.properties, (function (t, e) { if (t == null) { return {} } let n; let i; const r = {}; const a = Object.keys(t); for (i = 0; i < a.length; i++) { n = a[i], e.includes(n) || (r[n] = t[n]) } return r }(o, ['properties']))); e.set(t, n({}, s, a)) } } else { e.set(t, n({}, i, a)) } }) }) } }, e._animateOptions = function (t, e) { const i = e.options; const r = (function (t, e) { if (!e) { return } let i = t.options; if (!i) { return void (t.options = e) } i.$shared && !e.$shared && (t.options = i = n({}, i, { $shared: !1, $animations: {} })); return i }(t, i)); if (!r) { return [] } const a = this._createAnimations(r, i); return i.$shared && !r.$shared && (function (t, e) { for (var n = [], i = Object.keys(e), r = 0; r < i.length; r++) { const a = t[i[r]]; a && a.active() && n.push(a.wait()) } return Ne.all(n) }(t.options.$animations, i)).then(function () { t.options = i }), a }, e._createAnimations = function (t, e) { let n; const i = this._properties; const r = []; const a = t.$animations || (t.$animations = {}); const o = Object.keys(e); const s = Date.now(); for (n = o.length - 1; n >= 0; --n) { const l = o[n]; if (l.charAt(0) !== '$') { if (l !== 'options') { const c = e[l]; let u = a[l]; const h = i.get(l); if (u) { if (h && u.active()) { u.update(h, c, s); continue }u.cancel() }h && h.duration ? (a[l] = u = new Cn(h, t, l, c), r.push(u)) : t[l] = c } else { r.push.apply(r, this._animateOptions(t, e)) } } } return r }, e.update = function (t, e) { if (this._properties.size === 0) { return (function (t, e) { const i = t.options; const r = e.options; i && r && (i.$shared && !r.$shared ? t.options = n({}, i, r, { $shared: !1 }) : n(i, r), delete e.options) }(t, e)), void n(t, e) } const i = this._createAnimations(t, e); return i.length ? (s.add(this._chart, i), !0) : void 0 }, t }()); function zn (t, e) { const n = t && t.options || {}; const i = n.reverse; const r = void 0 === n.min ? e : 0; const a = void 0 === n.max ? e : 0; return { start: i ? a : r, end: i ? r : a } } function In (t, e) { let n; let i; const r = []; const a = t._getSortedDatasetMetas(e); for (n = 0, i = a.length; n < i; ++n) { r.push(a[n].index) } return r } function Bn (t, e, n, i) { let r; let a; let o; let s; const l = t.keys; for (r = 0, a = l.length; r < a; ++r) { if ((o = +l[r]) === n) { if (i) { continue } break }s = t.values[o], isNaN(s) || e !== 0 && j(e) !== j(s) || (e += s) } return e } function Vn (t, e) { const n = t && t.options.stacked; return n || void 0 === n && void 0 !== e.stack } function Wn (t, e, n) { const i = t[e] || (t[e] = {}); return i[n] || (i[n] = {}) } function Nn (t, e) { for (let n = t.chart, i = t._cachedMeta, r = n._stacks || (n._stacks = {}), a = i.iScale, o = i.vScale, s = i.index, l = a.axis, c = o.axis, u = (function (t, e, n) { return t.id + '.' + e.id + '.' + n.stack + '.' + n.type }(a, o, i)), h = e.length, f = 0; f < h; ++f) { const d = e[f]; const p = d[l]; const g = d[c]; ((d._stacks || (d._stacks = {}))[c] = Wn(r, u, p))[s] = g } } function Hn (t, e) { const n = t.scales; return Object.keys(n).filter(function (t) { return n[t].axis === e }).shift() } const jn = function (t, e) { return e ? 'hover' + P(t) : t }; const Yn = function (t) { return t === 'reset' || t === 'none' }; const Un = (function () { function t (t, e) { this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedAnimations = {}, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this._config = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.$context = void 0, this.initialize() } const e = t.prototype; return e.initialize = function () { const t = this; const e = t._cachedMeta; t.configure(), t.linkScales(), e._stacked = Vn(e.vScale, e), t.addElements() }, e.updateIndex = function (t) { this.index = t }, e.linkScales = function () { const t = this; const e = t.chart; const n = t._cachedMeta; const i = t.getDataset(); const r = function (t, e, n, i) { return t === 'x' ? e : t === 'r' ? i : n }; const a = n.xAxisID = g(i.xAxisID, Hn(e, 'x')); const o = n.yAxisID = g(i.yAxisID, Hn(e, 'y')); const s = n.rAxisID = g(i.rAxisID, Hn(e, 'r')); const l = n.indexAxis; const c = n.iAxisID = r(l, a, o, s); const u = n.vAxisID = r(l, o, a, s); n.xScale = t.getScaleForId(a), n.yScale = t.getScaleForId(o), n.rScale = t.getScaleForId(s), n.iScale = t.getScaleForId(c), n.vScale = t.getScaleForId(u) }, e.getDataset = function () { return this.chart.data.datasets[this.index] }, e.getMeta = function () { return this.chart.getDatasetMeta(this.index) }, e.getScaleForId = function (t) { return this.chart.scales[t] }, e._getOtherScale = function (t) { const e = this._cachedMeta; return t === e.iScale ? e.vScale : e.iScale }, e.reset = function () { this._update('reset') }, e._destroy = function () { this._data && mt(this._data, this) }, e._dataCheck = function () { const t = this; const e = t.getDataset(); const n = e.data || (e.data = []); d(n) ? t._data = (function (t) { let e; let n; let i; const r = Object.keys(t); const a = new Array(r.length); for (e = 0, n = r.length; e < n; ++e) { i = r[e], a[e] = { x: i, y: t[i] } } return a }(n)) : t._data !== n && (t._data && mt(t._data, t), n && Object.isExtensible(n) && vt(n, t), t._data = n) }, e.addElements = function () { const t = this; const e = t._cachedMeta; t._dataCheck(); for (let n = t._data, i = e.data = new Array(n.length), r = 0, a = n.length; r < a; ++r) { i[r] = new t.dataElementType() }t.datasetElementType && (e.dataset = new t.datasetElementType()) }, e.buildOrUpdateElements = function () { const t = this; const e = t._cachedMeta; const n = t.getDataset(); let i = !1; t._dataCheck(), e._stacked = Vn(e.vScale, e), e.stack !== n.stack && (i = !0, e._parsed.forEach(function (t) { delete t._stacks[e.vScale.id][e.index] }), e.stack = n.stack), t._resyncElements(), i && Nn(t, e._parsed) }, e.configure = function () { let t; const e = this; e._config = w(Object.create(null), [A.controllers[e._type].datasets, (t = e.chart.options[e._type]) == null ? void 0 : t.datasets, e.getDataset()], { merger (t, e, n) { t !== 'data' && _(t, e, n) } }), e._parsing = jt([e._config.parsing, e.chart.options.parsing, !0]) }, e.parse = function (t, e) { let n; let i; let r; let a; const o = this; const s = o._cachedMeta; const l = o._data; const c = s.iScale; const u = s.vScale; const h = s._stacked; const p = c.axis; let g = !0; if (t > 0 && (g = s._sorted, a = s._parsed[t - 1]), !1 === o._parsing) { s._parsed = l, s._sorted = !0 } else { i = f(l[t]) ? o.parseArrayData(s, l, t, e) : d(l[t]) ? o.parseObjectData(s, l, t, e) : o.parsePrimitiveData(s, l, t, e); for (n = 0; n < e; ++n) { s._parsed[n + t] = r = i[n], g && ((isNaN(r[p]) || a && r[p] < a[p]) && (g = !1), a = r) }s._sorted = g }h && Nn(o, i), c.invalidateCaches(), u.invalidateCaches() }, e.parsePrimitiveData = function (t, e, n, i) { let r; let a; let o; const s = t.iScale; const l = t.vScale; const c = s.axis; const u = l.axis; const h = s.getLabels(); const f = s === l; const d = new Array(i); for (r = 0, a = i; r < a; ++r) { var p; o = r + n, d[r] = ((p = {})[c] = f || s.parse(h[o], o), p[u] = l.parse(e[o], o), p) } return d }, e.parseArrayData = function (t, e, n, i) { let r; let a; let o; let s; const l = t.xScale; const c = t.yScale; const u = new Array(i); for (r = 0, a = i; r < a; ++r) { s = e[o = r + n], u[r] = { x: l.parse(s[0], o), y: c.parse(s[1], o) } } return u }, e.parseObjectData = function (t, e, n, i) { let r; let a; let o; let s; const l = t.xScale; const c = t.yScale; const u = this._parsing; const h = u.xAxisKey; const f = void 0 === h ? 'x' : h; const d = u.yAxisKey; const p = void 0 === d ? 'y' : d; const g = new Array(i); for (r = 0, a = i; r < a; ++r) { s = e[o = r + n], g[r] = { x: l.parse(S(s, f), o), y: c.parse(S(s, p), o) } } return g }, e.getParsed = function (t) { return this._cachedMeta._parsed[t] }, e.getDataElement = function (t) { return this._cachedMeta.data[t] }, e.applyStack = function (t, e) { const n = this.chart; const i = this._cachedMeta; const r = e[t.axis]; return Bn({ keys: In(n, !0), values: e._stacks[t.axis] }, r, i.index) }, e.updateRangeFromParsed = function (t, e, n, i) { let r = n[e.axis]; const a = i && n._stacks[e.axis]; i && a && (i.values = a, t.min = Math.min(t.min, r), t.max = Math.max(t.max, r), r = Bn(i, r, this._cachedMeta.index, !0)), t.min = Math.min(t.min, r), t.max = Math.max(t.max, r) }, e.getMinMax = function (t, e) { let n; let i; let r; let a; const o = this; const s = o._cachedMeta; const l = s._parsed; const c = s._sorted && t === s.iScale; const u = l.length; const h = o._getOtherScale(t); const f = e && s._stacked && { keys: In(o.chart, !0), values: null }; const d = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }; const p = (function (t) { const e = t.getUserBounds(); const n = e.min; const i = e.max; const r = e.minDefined; const a = e.maxDefined; return { min: r ? n : Number.NEGATIVE_INFINITY, max: a ? i : Number.POSITIVE_INFINITY } }(h)); const g = p.min; const v = p.max; function m () { return r = l[n], i = r[t.axis], a = r[h.axis], isNaN(i) || isNaN(a) || g > a || v < a } for (n = 0; n < u && (m() || (o.updateRangeFromParsed(d, t, r, f), !c)); ++n) { ; } if (c) { for (n = u - 1; n >= 0; --n) { if (!m()) { o.updateRangeFromParsed(d, t, r, f); break } } } return d }, e.getAllParsedValues = function (t) { let e; let n; let i; const r = this._cachedMeta._parsed; const a = []; for (e = 0, n = r.length; e < n; ++e) { i = r[e][t.axis], isNaN(i) || a.push(i) } return a }, e.getMaxOverflow = function () { return !1 }, e.getLabelAndValue = function (t) { const e = this._cachedMeta; const n = e.iScale; const i = e.vScale; const r = this.getParsed(t); return { label: n ? '' + n.getLabelForValue(r[n.axis]) : '', value: i ? '' + i.getLabelForValue(r[i.axis]) : '' } }, e._update = function (t) { let e; let n; let i; let r; let a; const o = this; const s = o._cachedMeta; o.configure(), o._cachedAnimations = {}, o._cachedDataOpts = {}, o.update(t || 'default'), s._clip = (d(e = g(o._config.clip, (function (t, e, n) { if (!1 === n) { return !1 } const i = zn(t, n); const r = zn(e, n); return { top: r.end, right: i.end, bottom: r.start, left: i.start } }(s.xScale, s.yScale, o.getMaxOverflow())))) ? (n = e.top, i = e.right, r = e.bottom, a = e.left) : n = i = r = a = e, { top: n, right: i, bottom: r, left: a }) }, e.update = function (t) {}, e.draw = function () { let t; const e = this; const n = e._ctx; const i = e.chart; const r = e._cachedMeta; const a = r.data || []; const o = i.chartArea; const s = []; const l = e._drawStart || 0; const c = e._drawCount || a.length - l; for (r.dataset && r.dataset.draw(n, o, l, c), t = l; t < l + c; ++t) { const u = a[t]; u.active ? s.push(u) : u.draw(n, o) } for (t = 0; t < s.length; ++t) { s[t].draw(n, o) } }, e._addAutomaticHoverColors = function (t, e) { for (var n, i = this.getStyle(t), r = Object.keys(i).filter(function (t) { return t.includes('Color') && !(t in e) }), a = r.length - 1; a >= 0; a--) { n = r[a], e[n] = On(i[n]) } }, e.getStyle = function (t, e) { const n = this; const i = n._cachedMeta.dataset; n._config || n.configure(); const r = i && void 0 === t ? n.resolveDatasetElementOptions(e) : n.resolveDataElementOptions(t || 0, e && 'active'); return e && n._addAutomaticHoverColors(t, r), r }, e.getContext = function (t, e) { let n; const i = this; if (t >= 0 && t < i._cachedMeta.data.length) { const r = i._cachedMeta.data[t]; n = r.$context || (r.$context = (function (t, e, n, i) { return Object.create(t, { active: { writable: !0, value: !1 }, dataIndex: { value: e }, dataPoint: { value: n }, element: { value: i }, index: { get () { return this.dataIndex } } }) }(i.getContext(), t, i.getParsed(t), r))) } else { n = i.$context || (i.$context = (function (t, e, n) { return Object.create(t, { active: { writable: !0, value: !1 }, dataset: { value: n }, datasetIndex: { value: e }, index: { get () { return this.datasetIndex } } }) }(i.chart.getContext(), i.index, i.getDataset()))) } return n.active = !!e, n }, e.resolveDatasetElementOptions = function (t) { return this._resolveOptions(this.datasetElementOptions, { active: t, type: this.datasetElementType.id }) }, e.resolveDataElementOptions = function (t, e) { const i = this; const r = (e = e || 'default') === 'active'; const a = i._cachedDataOpts; const o = a[e]; const s = i.enableOptionSharing; if (o) { return (function (t, e) { return e ? t : n({}, t) }(o, s)) } const l = { cacheable: !r }; const c = i._resolveOptions(i.dataElementOptions, { index: t, active: r, info: l, type: i.dataElementType.id }); return l.cacheable && (c.$shared = s, a[e] = (function (t, e) { return e ? Object.freeze(t) : t }(c, s))), c }, e._resolveOptions = function (t, e) { for (var n = this, i = e.index, r = e.active, a = e.type, o = e.info, s = n._config, l = n.chart.options.elements[a] || {}, c = {}, u = n.getContext(i, r), h = (function (t) { return f(t) ? t : Object.keys(t) }(t)), d = 0, p = h.length; d < p; ++d) { const g = h[d]; const v = jn(g, r); const m = jt([s[t[v]], s[v], l[v]], u, i, o); void 0 !== m && (c[g] = m) } return c }, e._resolveAnimations = function (t, e, i) { const r = this; const a = r.chart; const o = r._cachedAnimations; if (o[e = e || 'default']) { return o[e] } const s = { cacheable: !0 }; const l = r.getContext(t, i); const c = jt([a.options.animation], l, t, s); const u = jt([r._config.animation], l, t, s); let h = c && M({}, [u, c]); h[e] && (h = n({}, h, h[e])); const f = new Fn(a, h); return s.cacheable && (o[e] = f && Object.freeze(f)), f }, e.getSharedOptions = function (t) { if (t.$shared) { return this._sharedOptions || (this._sharedOptions = n({}, t)) } }, e.includeOptions = function (t, e) { return !e || Yn(t) }, e.updateElement = function (t, e, i, r) { Yn(r) ? n(t, i) : this._resolveAnimations(e, r).update(t, i) }, e.updateSharedOptions = function (t, e, n) { t && this._resolveAnimations(void 0, e).update({ options: t }, { options: n }) }, e._setStyle = function (t, e, n, i) { t.active = i; const r = this.getStyle(e, i); this._resolveAnimations(e, n, i).update(t, { options: this.getSharedOptions(r) || r }) }, e.removeHoverStyle = function (t, e, n) { this._setStyle(t, n, 'active', !1) }, e.setHoverStyle = function (t, e, n) { this._setStyle(t, n, 'active', !0) }, e._removeDatasetHoverStyle = function () { const t = this._cachedMeta.dataset; t && this._setStyle(t, void 0, 'active', !1) }, e._setDatasetHoverStyle = function () { const t = this._cachedMeta.dataset; t && this._setStyle(t, void 0, 'active', !0) }, e._resyncElements = function () { const t = this; const e = t._cachedMeta; const n = e.data.length; const i = t._data.length; i > n ? t._insertElements(n, i - n) : i < n && (e.data.splice(i, n - i), e._parsed.splice(i, n - i)), t.parse(0, Math.min(i, n)) }, e._insertElements = function (t, e) { let n; let i; const r = this; const a = new Array(e); const o = r._cachedMeta; const s = o.data; for (n = 0; n < e; ++n) { a[n] = new r.dataElementType() }(s.splice.apply(s, [t, 0].concat(a)), r._parsing) && (i = o._parsed).splice.apply(i, [t, 0].concat(new Array(e))); r.parse(t, e), r.updateElements(s, t, e, 'reset') }, e.updateElements = function (t, e, n, i) {}, e._removeElements = function (t, e) { const n = this; n._parsing && n._cachedMeta._parsed.splice(t, e), n._cachedMeta.data.splice(t, e) }, e._onDataPush = function () { const t = arguments.length; this._insertElements(this.getDataset().data.length - t, t) }, e._onDataPop = function () { this._removeElements(this._cachedMeta.data.length - 1, 1) }, e._onDataShift = function () { this._removeElements(0, 1) }, e._onDataSplice = function (t, e) { this._removeElements(t, e), this._insertElements(t, arguments.length - 2) }, e._onDataUnshift = function () { this._insertElements(0, arguments.length) }, t }()); Un.defaults = {}, Un.prototype.datasetElementType = null, Un.prototype.dataElementType = null, Un.prototype.datasetElementOptions = ['backgroundColor', 'borderCapStyle', 'borderColor', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'borderWidth'], Un.prototype.dataElementOptions = ['backgroundColor', 'borderColor', 'borderWidth', 'pointStyle']; const Xn = (function () { function t () { this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0 } const e = t.prototype; return e.tooltipPosition = function (t) { const e = this.getProps(['x', 'y'], t); return { x: e.x, y: e.y } }, e.hasValue = function () { return V(this.x) && V(this.y) }, e.getProps = function (t, e) { const n = this; const i = this.$animations; if (!e || !i) { return n } const r = {}; return t.forEach(function (t) { r[t] = i[t] && i[t].active ? i[t]._to : n[t] }), r }, t }()); Xn.defaults = {}, Xn.defaultRoutes = void 0; const $n = new Map(); var Kn = { values (t) { return f(t) ? t : '' + t }, numeric (t, e, i) { if (t === 0) { return '0' } let r; const a = this.chart.options.locale; const o = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value)); (o < 1e-4 || o > 1e15) && (r = 'scientific'); let s = i.length > 3 ? i[2].value - i[1].value : i[1].value - i[0].value; Math.abs(s) > 1 && t !== Math.floor(t) && (s = t - Math.floor(t)); const l = B(Math.abs(s)); const c = Math.max(Math.min(-1 * Math.floor(l), 20), 0); const u = { notation: r, minimumFractionDigits: c, maximumFractionDigits: c }; n(u, this.options.ticks.format); const h = a + JSON.stringify(u); let f = $n.get(h); return f || (f = new Intl.NumberFormat(a, u), $n.set(h, f)), f.format(t) }, logarithmic (t, e, n) { if (t === 0) { return '0' } const i = t / Math.pow(10, Math.floor(B(t))); return i === 1 || i === 2 || i === 5 ? Kn.numeric.call(this, t, e, n) : '' } }; const qn = { formatters: Kn }; function Gn (t, e) { for (var n = [], i = t.length / e, r = t.length, a = 0; a < r; a += i) { n.push(t[Math.floor(a)]) } return n } function Zn (t, e, n) { let i; const r = t.ticks.length; const a = Math.min(e, r - 1); const o = t._startPixel; const s = t._endPixel; const l = 1e-6; let c = t.getPixelForTick(a); if (!(n && (i = r === 1 ? Math.max(c - o, s - c) : e === 0 ? (t.getPixelForTick(1) - c) / 2 : (c - t.getPixelForTick(a - 1)) / 2, (c += a < e ? i : -i) < o - l || c > s + l))) { return c } } function Qn (t) { return t.drawTicks ? t.tickMarkLength : 0 } function Jn (t, e) { if (!t.display) { return 0 } const n = Ht(t.font, e); const i = Nt(t.padding); return n.lineHeight + i.height } function ti (t, e, n, i, r) { let a; let o; let s; const l = g(i, 0); const c = Math.min(g(r, t.length), t.length); let u = 0; for (n = Math.ceil(n), r && (n = (a = r - i) / Math.floor(a / n)), s = l; s < 0;) { u++, s = Math.round(l + u * n) } for (o = Math.max(l, 0); o < c; o++) { o === s && (e.push(t[o]), u++, s = Math.round(l + u * n)) } }A.set('scale', { display: !0, offset: !1, reverse: !1, beginAtZero: !1, gridLines: { display: !0, color: 'rgba(0,0,0,0.1)', lineWidth: 1, drawBorder: !0, drawOnChartArea: !0, drawTicks: !0, tickMarkLength: 10, offsetGridLines: !1, borderDash: [], borderDashOffset: 0 }, scaleLabel: { display: !1, labelString: '', padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: !1, lineWidth: 0, strokeStyle: '', padding: 0, display: !0, autoSkip: !0, autoSkipPadding: 0, labelOffset: 0, callback: qn.formatters.values, minor: {}, major: {}, align: 'center', crossAlign: 'near' } }); const ei = (function (t) { function e (e) { let n; return (n = t.call(this) || this).id = e.id, n.type = e.type, n.options = void 0, n.ctx = e.ctx, n.chart = e.chart, n.top = void 0, n.bottom = void 0, n.left = void 0, n.right = void 0, n.width = void 0, n.height = void 0, n._margins = { left: 0, right: 0, top: 0, bottom: 0 }, n.maxWidth = void 0, n.maxHeight = void 0, n.paddingTop = void 0, n.paddingBottom = void 0, n.paddingLeft = void 0, n.paddingRight = void 0, n.axis = void 0, n.labelRotation = void 0, n.min = void 0, n.max = void 0, n.ticks = [], n._gridLineItems = null, n._labelItems = null, n._labelSizes = null, n._length = 0, n._longestTextCache = {}, n._startPixel = void 0, n._endPixel = void 0, n._reversePixels = !1, n._userMax = void 0, n._userMin = void 0, n._ticksLength = 0, n._borderValue = 0, n._cache = {}, n.$context = void 0, n }i(e, t); const r = e.prototype; return r.init = function (t) { const e = this; e.options = t, e.axis = e.isHorizontal() ? 'x' : 'y', e._userMin = e.parse(t.min), e._userMax = e.parse(t.max) }, r.parse = function (t, e) { return t }, r.getUserBounds = function () { let t = this._userMin; let e = this._userMax; return (h(t) || isNaN(t)) && (t = Number.POSITIVE_INFINITY), (h(e) || isNaN(e)) && (e = Number.NEGATIVE_INFINITY), { min: t, max: e, minDefined: p(t), maxDefined: p(e) } }, r.getMinMax = function (t) { let e; const n = this; const i = n.getUserBounds(); let r = i.min; let a = i.max; const o = i.minDefined; const s = i.maxDefined; if (o && s) { return { min: r, max: a } } for (let l = n.getMatchingVisibleMetas(), c = 0, u = l.length; c < u; ++c) { e = l[c].controller.getMinMax(n, t), o || (r = Math.min(r, e.min)), s || (a = Math.max(a, e.max)) } return { min: r, max: a } }, r.invalidateCaches = function () { this._cache = {} }, r.getPadding = function () { const t = this; return { left: t.paddingLeft || 0, top: t.paddingTop || 0, right: t.paddingRight || 0, bottom: t.paddingBottom || 0 } }, r.getTicks = function () { return this.ticks }, r.getLabels = function () { const t = this.chart.data; return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [] }, r.beforeUpdate = function () { v(this.options.beforeUpdate, [this]) }, r.update = function (t, e, i) { const r = this; const a = r.options.ticks; const o = a.sampleSize; r.beforeUpdate(), r.maxWidth = t, r.maxHeight = e, r._margins = n({ left: 0, right: 0, top: 0, bottom: 0 }, i), r.ticks = null, r._labelSizes = null, r._gridLineItems = null, r._labelItems = null, r.beforeSetDimensions(), r.setDimensions(), r.afterSetDimensions(), r.beforeDataLimits(), r.determineDataLimits(), r.afterDataLimits(), r.beforeBuildTicks(), r.ticks = r.buildTicks() || [], r.afterBuildTicks(); const s = o < r.ticks.length; r._convertTicksToLabels(s ? Gn(r.ticks, o) : r.ticks), r.configure(), r.beforeCalculateLabelRotation(), r.calculateLabelRotation(), r.afterCalculateLabelRotation(), r.beforeFit(), r.fit(), r.afterFit(), r.ticks = a.display && (a.autoSkip || a.source === 'auto') ? r._autoSkip(r.ticks) : r.ticks, s && r._convertTicksToLabels(r.ticks), r.afterUpdate() }, r.configure = function () { let t; let e; const n = this; let i = n.options.reverse; n.isHorizontal() ? (t = n.left, e = n.right) : (t = n.top, e = n.bottom, i = !i), n._startPixel = t, n._endPixel = e, n._reversePixels = i, n._length = e - t }, r.afterUpdate = function () { v(this.options.afterUpdate, [this]) }, r.beforeSetDimensions = function () { v(this.options.beforeSetDimensions, [this]) }, r.setDimensions = function () { const t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0 }, r.afterSetDimensions = function () { v(this.options.afterSetDimensions, [this]) }, r.beforeDataLimits = function () { v(this.options.beforeDataLimits, [this]) }, r.determineDataLimits = function () {}, r.afterDataLimits = function () { v(this.options.afterDataLimits, [this]) }, r.beforeBuildTicks = function () { v(this.options.beforeBuildTicks, [this]) }, r.buildTicks = function () { return [] }, r.afterBuildTicks = function () { v(this.options.afterBuildTicks, [this]) }, r.beforeTickToLabelConversion = function () { v(this.options.beforeTickToLabelConversion, [this]) }, r.generateTickLabels = function (t) { let e; let n; let i; const r = this.options.ticks; for (e = 0, n = t.length; e < n; e++) { (i = t[e]).label = v(r.callback, [i.value, e, t], this) } }, r.afterTickToLabelConversion = function () { v(this.options.afterTickToLabelConversion, [this]) }, r.beforeCalculateLabelRotation = function () { v(this.options.beforeCalculateLabelRotation, [this]) }, r.calculateLabelRotation = function () { let t; let e; let n; const i = this; const r = i.options; const a = r.ticks; const o = i.ticks.length; const s = a.minRotation || 0; const l = a.maxRotation; let c = s; if (!i._isVisible() || !a.display || s >= l || o <= 1 || !i.isHorizontal()) { i.labelRotation = s } else { const u = i._getLabelSizes(); const h = u.widest.width; const f = u.highest.height - u.highest.offset; const d = Math.min(i.maxWidth, i.chart.width - h); h + 6 > (t = r.offset ? i.maxWidth / o : d / (o - 1)) && (t = d / (o - (r.offset ? 0.5 : 1)), e = i.maxHeight - Qn(r.gridLines) - a.padding - Jn(r.scaleLabel, i.chart.options.font), n = Math.sqrt(h * h + f * f), c = U(Math.min(Math.asin(Math.min((u.highest.height + 6) / t, 1)), Math.asin(Math.min(e / n, 1)) - Math.asin(f / n))), c = Math.max(s, Math.min(l, c))), i.labelRotation = c } }, r.afterCalculateLabelRotation = function () { v(this.options.afterCalculateLabelRotation, [this]) }, r.beforeFit = function () { v(this.options.beforeFit, [this]) }, r.fit = function () { const t = this; const e = { width: 0, height: 0 }; const n = t.chart; const i = t.options; const r = i.ticks; const a = i.scaleLabel; const o = i.gridLines; const s = t._isVisible(); const l = i.position !== 'top' && t.axis === 'x'; const c = t.isHorizontal(); const u = s && Jn(a, n.options.font); if (c ? e.width = t.maxWidth : s && (e.width = Qn(o) + u), c ? s && (e.height = Qn(o) + u) : e.height = t.maxHeight, r.display && s && t.ticks.length) { const h = t._getLabelSizes(); const f = h.first; const d = h.last; const p = h.widest; const g = h.highest; const v = 0.8 * g.offset; const m = r.padding; if (c) { const b = t.labelRotation !== 0; const x = Y(t.labelRotation); const y = Math.cos(x); const _ = Math.sin(x); const w = _ * p.width + y * (g.height - (b ? g.offset : 0)) + (b ? 0 : v); e.height = Math.min(t.maxHeight, e.height + w + m); let M; let k; const S = t.getPixelForTick(0) - t.left; const P = t.right - t.getPixelForTick(t.ticks.length - 1); b ? (M = l ? y * f.width + _ * f.offset : _ * (f.height - f.offset), k = l ? _ * (d.height - d.offset) : y * d.width + _ * d.offset) : r.align === 'start' ? (M = 0, k = d.width) : r.align === 'end' ? (M = f.width, k = 0) : (M = f.width / 2, k = d.width / 2), t.paddingLeft = Math.max((M - S) * t.width / (t.width - S), 0) + 3, t.paddingRight = Math.max((k - P) * t.width / (t.width - P), 0) + 3 } else { const D = r.mirror ? 0 : p.width + m + v; e.width = Math.min(t.maxWidth, e.width + D); let A = d.height / 2; let T = f.height / 2; r.align === 'start' ? (A = 0, T = f.height) : r.align === 'end' && (A = d.height, T = 0), t.paddingTop = A, t.paddingBottom = T } }t._handleMargins(), c ? (t.width = t._length = n.width - t._margins.left - t._margins.right, t.height = e.height) : (t.width = e.width, t.height = t._length = n.height - t._margins.top - t._margins.bottom) }, r._handleMargins = function () { const t = this; t._margins && (t._margins.left = Math.max(t.paddingLeft, t._margins.left), t._margins.top = Math.max(t.paddingTop, t._margins.top), t._margins.right = Math.max(t.paddingRight, t._margins.right), t._margins.bottom = Math.max(t.paddingBottom, t._margins.bottom)) }, r.afterFit = function () { v(this.options.afterFit, [this]) }, r.isHorizontal = function () { const t = this.options; const e = t.axis; const n = t.position; return n === 'top' || n === 'bottom' || e === 'x' }, r.isFullWidth = function () { return this.options.fullWidth }, r._convertTicksToLabels = function (t) { const e = this; e.beforeTickToLabelConversion(), e.generateTickLabels(t), e.afterTickToLabelConversion() }, r._getLabelSizes = function () { const t = this; let e = t._labelSizes; return e || (t._labelSizes = e = t._computeLabelSizes()), e }, r._computeLabelSizes = function () { const t = this; const e = t.ctx; const n = t._longestTextCache; const i = t.options.ticks.sampleSize; const r = []; const a = []; const o = []; let s = 0; let l = 0; let c = t.ticks; i < c.length && (c = Gn(c, i)); let u; let d; let p; let g; let v; let b; let x; let y; let _; let w; let M; const k = c.length; for (u = 0; u < k; ++u) { if (g = c[u].label, v = t._resolveTickFontOptions(u), e.font = b = v.string, x = n[b] = n[b] || { data: {}, gc: [] }, y = v.lineHeight, _ = w = 0, h(g) || f(g)) { if (f(g)) { for (d = 0, p = g.length; d < p; ++d) { h(M = g[d]) || f(M) || (_ = et(e, x.data, x.gc, _, M), w += y) } } } else { _ = et(e, x.data, x.gc, _, g), w = y }r.push(_), a.push(w), o.push(y / 2), s = Math.max(_, s), l = Math.max(w, l) }!(function (t, e) { m(t, function (t) { let n; const i = t.gc; const r = i.length / 2; if (r > e) { for (n = 0; n < r; ++n) { delete t.data[i[n]] } i.splice(0, r) } }) }(n, k)); const S = r.indexOf(s); const P = a.indexOf(l); function D (t) { return { width: r[t] || 0, height: a[t] || 0, offset: o[t] || 0 } } return { first: D(0), last: D(k - 1), widest: D(S), highest: D(P) } }, r.getLabelForValue = function (t) { return t }, r.getPixelForValue = function (t, e) { return NaN }, r.getValueForPixel = function (t) {}, r.getPixelForTick = function (t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) }, r.getPixelForDecimal = function (t) { const e = this; return e._reversePixels && (t = 1 - t), J(e._startPixel + t * e._length) }, r.getDecimalForPixel = function (t) { const e = (t - this._startPixel) / this._length; return this._reversePixels ? 1 - e : e }, r.getBasePixel = function () { return this.getPixelForValue(this.getBaseValue()) }, r.getBaseValue = function () { const t = this.min; const e = this.max; return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0 }, r.getContext = function (t) { let e; let n; const i = this; const r = i.ticks || []; if (t >= 0 && t < r.length) { const a = r[t]; return a.$context || (a.$context = (function (t, e, n) { return Object.create(t, { tick: { value: n }, index: { value: e } }) }(i.getContext(), t, a))) } return i.$context || (i.$context = (e = i.chart.getContext(), n = i, Object.create(e, { scale: { value: n } }))) }, r._autoSkip = function (t) { const e = this; const n = e.options.ticks; const i = n.maxTicksLimit || e._length / e._tickSize(); const r = n.major.enabled ? (function (t) { let e; let n; const i = []; for (e = 0, n = t.length; e < n; e++) { t[e].major && i.push(e) } return i }(t)) : []; const a = r.length; const o = r[0]; const s = r[a - 1]; const l = []; if (a > i) { return (function (t, e, n, i) { let r; let a = 0; let o = n[0]; for (i = Math.ceil(i), r = 0; r < t.length; r++) { r === o && (e.push(t[r]), o = n[++a * i]) } }(t, l, r, a / i)), l } const c = (function (t, e, n) { const i = (function (t) { let e; let n; const i = t.length; if (i < 2) { return !1 } for (n = t[0], e = 1; e < i; ++e) { if (t[e] - t[e - 1] !== n) { return !1 } } return n }(t)); const r = e.length / n; if (!i) { return Math.max(r, 1) } for (let a = I(i), o = 0, s = a.length - 1; o < s; o++) { const l = a[o]; if (l > r) { return l } } return Math.max(r, 1) }(r, t, i)); if (a > 0) { let u; let f; const d = a > 1 ? Math.round((s - o) / (a - 1)) : null; for (ti(t, l, c, h(d) ? 0 : o - d, o), u = 0, f = a - 1; u < f; u++) { ti(t, l, c, r[u], r[u + 1]) } return ti(t, l, c, s, h(d) ? t.length : s + d), l } return ti(t, l, c), l }, r._tickSize = function () { const t = this; const e = t.options.ticks; const n = Y(t.labelRotation); const i = Math.abs(Math.cos(n)); const r = Math.abs(Math.sin(n)); const a = t._getLabelSizes(); const o = e.autoSkipPadding || 0; const s = a ? a.widest.width + o : 0; const l = a ? a.highest.height + o : 0; return t.isHorizontal() ? l * i > s * r ? s / i : l / r : l * r < s * i ? l / i : s / r }, r._isVisible = function () { const t = this.options.display; return t !== 'auto' ? !!t : this.getMatchingVisibleMetas().length > 0 }, r._computeGridLineItems = function (t) { let e; let n; let i; let r; let a; let o; let s; let l; let c; let u; let h; let f; const p = this; const g = p.axis; const v = p.chart; const m = p.options; const b = m.gridLines; const x = m.position; const y = b.offsetGridLines; const _ = p.isHorizontal(); const w = p.ticks.length + (y ? 1 : 0); const M = Qn(b); const k = []; let S = this.getContext(0); const P = b.drawBorder ? jt([b.borderWidth, b.lineWidth, 0], S, 0) : 0; const D = P / 2; const A = function (t) { return it(v, t, P) }; if (x === 'top') { e = A(p.bottom), o = p.bottom - M, l = e - D, u = A(t.top) + D, f = t.bottom } else if (x === 'bottom') { e = A(p.top), u = t.top, f = A(t.bottom) - D, o = e + D, l = p.top + M } else if (x === 'left') { e = A(p.right), a = p.right - M, s = e - D, c = A(t.left) + D, h = t.right } else if (x === 'right') { e = A(p.left), c = t.left, h = A(t.right) - D, a = e + D, s = p.left + M } else if (g === 'x') { if (x === 'center') { e = A((t.top + t.bottom) / 2) } else if (d(x)) { const T = Object.keys(x)[0]; const O = x[T]; e = A(p.chart.scales[T].getPixelForValue(O)) }u = t.top, f = t.bottom, l = (o = e + D) + M } else if (g === 'y') { if (x === 'center') { e = A((t.left + t.right) / 2) } else if (d(x)) { const E = Object.keys(x)[0]; const L = x[E]; e = A(p.chart.scales[E].getPixelForValue(L)) }s = (a = e - D) - M, c = t.left, h = t.right } for (n = 0; n < w; ++n) { S = this.getContext(n); const C = jt([b.lineWidth], S, n); const R = jt([b.color], S, n); const F = b.borderDash || []; const z = jt([b.borderDashOffset], S, n); void 0 !== (i = Zn(p, n, y)) && (r = it(v, i, C), _ ? a = s = c = h = r : o = l = u = f = r, k.push({ tx1: a, ty1: o, tx2: s, ty2: l, x1: c, y1: u, x2: h, y2: f, width: C, color: R, borderDash: F, borderDashOffset: z })) } return p._ticksLength = w, p._borderValue = e, k }, r._computeLabelItems = function (t) { let e; let n; let i; let r; let a; let o; let s; let l; let c; let u; let h; const p = this; const g = p.axis; const v = p.options; const m = v.position; const b = v.ticks; const x = p.isHorizontal(); const y = p.ticks; const _ = b.align; const w = b.crossAlign; const M = b.padding; const k = Qn(v.gridLines); const S = k + M; const P = -Y(p.labelRotation); const D = []; let A = 'middle'; if (m === 'top') { a = p.bottom - S, o = p._getXAxisLabelAlignment() } else if (m === 'bottom') { a = p.top + S, o = p._getXAxisLabelAlignment() } else if (m === 'left') { const T = this._getYAxisLabelAlignment(k); o = T.textAlign, r = T.x } else if (m === 'right') { const O = this._getYAxisLabelAlignment(k); o = O.textAlign, r = O.x } else if (g === 'x') { if (m === 'center') { a = (t.top + t.bottom) / 2 + S } else if (d(m)) { const E = Object.keys(m)[0]; const L = m[E]; a = p.chart.scales[E].getPixelForValue(L) + S }o = p._getXAxisLabelAlignment() } else if (g === 'y') { if (m === 'center') { r = (t.left + t.right) / 2 - S } else if (d(m)) { const C = Object.keys(m)[0]; const R = m[C]; r = p.chart.scales[C].getPixelForValue(R) }o = this._getYAxisLabelAlignment(k).textAlign }g === 'y' && (_ === 'start' ? A = 'top' : _ === 'end' && (A = 'bottom')); const F = p._getLabelSizes(); for (e = 0, n = y.length; e < n; ++e) { i = y[e].label, s = p.getPixelForTick(e) + b.labelOffset, c = (l = p._resolveTickFontOptions(e)).lineHeight; const z = (u = f(i) ? i.length : 1) / 2; x ? (r = s, m === 'top' ? w === 'near' || P !== 0 ? (h = (Math.sin(P) * z + 0.5) * c, h -= (P === 0 ? u - 0.5 : Math.cos(P) * z) * c) : w === 'center' ? (h = F.highest.height / 2 * -1, h -= z * c) : h = -1 * F.highest.height + 0.5 * c : m === 'bottom' && (w === 'near' || P !== 0 ? (h = Math.sin(P) * z * c, h += (P === 0 ? 0.5 : Math.cos(P) * z) * c) : w === 'center' ? (h = F.highest.height / 2, h -= z * c) : h = F.highest.height - (u - 0.5) * c)) : (a = s, h = (1 - u) * c / 2), D.push({ x: r, y: a, rotation: P, label: i, font: l, textOffset: h, textAlign: o, textBaseline: A }) } return D }, r._getXAxisLabelAlignment = function () { const t = this.options; const e = t.position; const n = t.ticks; if (-Y(this.labelRotation)) { return e === 'top' ? 'left' : 'right' } let i = 'center'; return n.align === 'start' ? i = 'left' : n.align === 'end' && (i = 'right'), i }, r._getYAxisLabelAlignment = function (t) { let e; let n; const i = this; const r = i.options; const a = r.position; const o = r.ticks; const s = o.crossAlign; const l = o.mirror; const c = o.padding; const u = t + c; const h = i._getLabelSizes().widest.width; return a === 'left' ? l ? (e = 'left', n = i.right - c) : (n = i.right - u, s === 'near' ? e = 'right' : s === 'center' ? (e = 'center', n -= h / 2) : (e = 'left', n -= h)) : a === 'right' ? l ? (e = 'right', n = i.left + c) : (n = i.left + u, s === 'near' ? e = 'left' : s === 'center' ? (e = 'center', n += h / 2) : (e = 'right', n += h)) : e = 'right', { textAlign: e, x: n } }, r.drawGrid = function (t) { let e; let n; const i = this; const r = i.options.gridLines; const a = i.ctx; const o = i.chart; let s = i.getContext(0); const l = r.drawBorder ? jt([r.borderWidth, r.lineWidth, 0], s, 0) : 0; const c = i._gridLineItems || (i._gridLineItems = i._computeGridLineItems(t)); if (r.display) { for (e = 0, n = c.length; e < n; ++e) { const u = c[e]; const h = u.width; const f = u.color; h && f && (a.save(), a.lineWidth = h, a.strokeStyle = f, a.setLineDash && (a.setLineDash(u.borderDash), a.lineDashOffset = u.borderDashOffset), a.beginPath(), r.drawTicks && (a.moveTo(u.tx1, u.ty1), a.lineTo(u.tx2, u.ty2)), r.drawOnChartArea && (a.moveTo(u.x1, u.y1), a.lineTo(u.x2, u.y2)), a.stroke(), a.restore()) } } if (l) { const d = l; s = i.getContext(i._ticksLength - 1); let p; let g; let v; let m; const b = jt([r.lineWidth, 1], s, i._ticksLength - 1); const x = i._borderValue; i.isHorizontal() ? (p = it(o, i.left, d) - d / 2, g = it(o, i.right, b) + b / 2, v = m = x) : (v = it(o, i.top, d) - d / 2, m = it(o, i.bottom, b) + b / 2, p = g = x), a.lineWidth = l, a.strokeStyle = jt([r.borderColor, r.color], s, 0), a.beginPath(), a.moveTo(p, v), a.lineTo(g, m), a.stroke() } }, r.drawLabels = function (t) { const e = this; if (e.options.ticks.display) { let n; let i; let r; let a; const o = e.ctx; const s = e._labelItems || (e._labelItems = e._computeLabelItems(t)); for (n = 0, r = s.length; n < r; ++n) { const l = s[n]; const c = l.font; const u = c.lineWidth > 0 && c.strokeStyle !== ''; o.save(), o.translate(l.x, l.y), o.rotate(l.rotation), o.font = c.string, o.fillStyle = c.color, o.textAlign = l.textAlign, o.textBaseline = l.textBaseline, u && (o.strokeStyle = c.strokeStyle, o.lineWidth = c.lineWidth); const h = l.label; let d = l.textOffset; if (f(h)) { for (i = 0, a = h.length; i < a; ++i) { u && o.strokeText('' + h[i], 0, d), o.fillText('' + h[i], 0, d), d += c.lineHeight } } else { u && o.strokeText(h, 0, d), o.fillText(h, 0, d) }o.restore() } } }, r.drawTitle = function (t) { const e = this; const n = e.ctx; const i = e.options; const r = i.scaleLabel; if (r.display) { let a; let o; let s; const l = Ht(r.font, e.chart.options.font); const c = Nt(r.padding); const u = l.lineHeight / 2; const h = r.align; const f = i.position; const d = e.options.reverse; let p = 0; if (e.isHorizontal()) { switch (h) { case 'start':o = e.left + (d ? e.width : 0), a = d ? 'right' : 'left'; break; case 'end':o = e.left + (d ? 0 : e.width), a = d ? 'left' : 'right'; break; default:o = e.left + e.width / 2, a = 'center' }s = f === 'top' ? e.top + u + c.top : e.bottom - u - c.bottom } else { const g = f === 'left'; switch (o = g ? e.left + u + c.top : e.right - u - c.top, h) { case 'start':s = e.top + (d ? 0 : e.height), a = d === g ? 'right' : 'left'; break; case 'end':s = e.top + (d ? e.height : 0), a = d === g ? 'left' : 'right'; break; default:s = e.top + e.height / 2, a = 'center' }p = g ? -R : R }n.save(), n.translate(o, s), n.rotate(p), n.textAlign = a, n.textBaseline = 'middle', n.fillStyle = l.color, n.font = l.string, n.fillText(r.labelString, 0, 0), n.restore() } }, r.draw = function (t) { const e = this; e._isVisible() && (e.drawGrid(t), e.drawTitle(), e.drawLabels(t)) }, r._layers = function () { const t = this; const e = t.options; const n = e.ticks && e.ticks.z || 0; const i = e.gridLines && e.gridLines.z || 0; return t._isVisible() && n !== i && t.draw === t._draw ? [{ z: i, draw (e) { t.drawGrid(e), t.drawTitle() } }, { z: n, draw (e) { t.drawLabels(e) } }] : [{ z: n, draw (e) { t.draw(e) } }] }, r.getMatchingVisibleMetas = function (t) { let e; let n; const i = this; const r = i.chart.getSortedVisibleDatasetMetas(); const a = i.axis + 'AxisID'; const o = []; for (e = 0, n = r.length; e < n; ++e) { const s = r[e]; s[a] !== i.id || t && s.type !== t || o.push(s) } return o }, r._resolveTickFontOptions = function (t) { const e = this; const n = e.chart; const i = e.options.ticks; const r = e.getContext(t); return Ht(jt([i.font], r), n.options.font) }, e }(Xn)); ei.prototype._draw = ei.prototype.draw; const ni = (function () { function t (t, e) { this.type = t, this.scope = e, this.items = Object.create(null) } const e = t.prototype; return e.isForType = function (t) { return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype) }, e.register = function (t) { let e; const i = Object.getPrototypeOf(t); (function (t) { return 'id' in t && 'defaults' in t })(i) && (e = this.register(i)); const r = this.items; const a = t.id; const o = this.scope; const s = o ? o + '.' + a : a; if (!a) { throw new Error('class does not have id: ' + t) } if (a in r) { return s } if (Object.keys(A.get(s)).length) { throw new Error('Can not register "' + a + '", because "defaults.' + s + '" would collide with existing defaults') } return r[a] = t, (function (t, e, i) { const r = i ? n({}, A.get(i), t.defaults) : t.defaults; A.set(e, r), t.defaultRoutes && (function (t, e) { Object.keys(e).forEach(function (n) { const i = e[n].split('.'); const r = i.pop(); const a = i.join('.'); A.route(t, n, a, r) }) }(e, t.defaultRoutes)) }(t, s, e)), s }, e.get = function (t) { return this.items[t] }, e.unregister = function (t) { const e = this.items; const n = t.id; const i = this.scope; n in e && delete e[n], i && n in A[i] ? delete A[i][n] : n in A && delete A[n] }, t }()); const ii = new (function () { function t () { this.controllers = new ni(Un, 'controllers'), this.elements = new ni(Xn, 'elements'), this.plugins = new ni(Object, 'plugins'), this.scales = new ni(ei, 'scales'), this._typedRegistries = [this.controllers, this.scales, this.elements] } const e = t.prototype; return e.add = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) { e[n] = arguments[n] } this._each('register', e) }, e.remove = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) { e[n] = arguments[n] } this._each('unregister', e) }, e.addControllers = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) { e[n] = arguments[n] } this._each('register', e, this.controllers) }, e.addElements = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) { e[n] = arguments[n] } this._each('register', e, this.elements) }, e.addPlugins = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) { e[n] = arguments[n] } this._each('register', e, this.plugins) }, e.addScales = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) { e[n] = arguments[n] } this._each('register', e, this.scales) }, e.getController = function (t) { return this._get(t, this.controllers, 'controller') }, e.getElement = function (t) { return this._get(t, this.elements, 'element') }, e.getPlugin = function (t) { return this._get(t, this.plugins, 'plugin') }, e.getScale = function (t) { return this._get(t, this.scales, 'scale') }, e.removeControllers = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) { e[n] = arguments[n] } this._each('unregister', e, this.controllers) }, e.removeElements = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) { e[n] = arguments[n] } this._each('unregister', e, this.elements) }, e.removePlugins = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) { e[n] = arguments[n] } this._each('unregister', e, this.plugins) }, e.removeScales = function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) { e[n] = arguments[n] } this._each('unregister', e, this.scales) }, e._each = function (t, e, n) { const i = this; [].concat(e).forEach(function (e) { const r = n || i._getRegistryForType(e); n || r.isForType(e) || r === i.plugins && e.id ? i._exec(t, r, e) : m(e, function (e) { const r = n || i._getRegistryForType(e); i._exec(t, r, e) }) }) }, e._exec = function (t, e, n) { const i = P(t); v(n['before' + i], [], n), e[t](n), v(n['after' + i], [], n) }, e._getRegistryForType = function (t) { for (let e = 0; e < this._typedRegistries.length; e++) { const n = this._typedRegistries[e]; if (n.isForType(t)) { return n } } return this.plugins }, e._get = function (t, e, n) { const i = e.get(t); if (void 0 === i) { throw new Error('"' + t + '" is not a registered ' + n + '.') } return i }, t }())(); const ri = (function () { function t () {} const e = t.prototype; return e.notify = function (t, e, n) { for (let i = this._descriptors(t), r = 0; r < i.length; ++r) { const a = i[r]; const o = a.plugin; const s = o[e]; if (typeof s === 'function') { const l = [t].concat(n || []); if (l.push(a.options), !1 === s.apply(o, l)) { return !1 } } } return !0 }, e.invalidate = function () { this._cache = void 0 }, e._descriptors = function (t) { if (this._cache) { return this._cache } const e = t && t.config; const n = e.options && e.options.plugins || {}; const i = (function (t, e) { for (var n = [], i = 0; i < t.length; i++) { const r = t[i]; const a = r.id; let o = e[a]; !1 !== o && (!0 === o && (o = {}), n.push({ plugin: r, options: M({}, [o, A.plugins[a]]) })) } return n }((function (t) { for (var e = [], n = Object.keys(ii.plugins.items), i = 0; i < n.length; i++) { e.push(ii.getPlugin(n[i])) } for (let r = t.plugins || [], a = 0; a < r.length; a++) { const o = r[a]; !e.includes(o) && e.push(o) } return e }(e)), n)); return this._cache = i, i }, t }()); function ai (t, e) { const n = (A.controllers[t] || {}).datasets || {}; return ((e[t] || {}).datasets || {}).indexAxis || e.indexAxis || n.indexAxis || 'x' } function oi (t, e) { return t === 'x' || t === 'y' || t === 'r' ? t : e.axis || ((n = e.position) === 'top' || n === 'bottom' ? 'x' : n === 'left' || n === 'right' ? 'y' : void 0) || t.charAt(0).toLowerCase(); let n } function si (t, e) { e = e || {}; const n = A.controllers[t.type] || { scales: {} }; const i = e.scales || {}; const r = ai(t.type, e); const a = Object.create(null); const o = Object.create(null); return Object.keys(i).forEach(function (t) { const e = i[t]; const s = oi(t, e); const l = (function (t, e) { return t === e ? '_index_' : '_value_' }(s, r)); a[s] = a[s] || t, o[t] = M(Object.create(null), [{ axis: s }, e, n.scales[s], n.scales[l]]) }), e.scale && (o[e.scale.id || 'r'] = M(Object.create(null), [{ axis: 'r' }, e.scale, n.scales.r]), a.r = a.r || e.scale.id || 'r'), t.data.datasets.forEach(function (n) { const r = n.type || t.type; const s = n.indexAxis || ai(r, e); const l = (A.controllers[r] || {}).scales || {}; Object.keys(l).forEach(function (t) { const e = (function (t, e) { let n = t; return t === '_index_' ? n = e : t === '_value_' && (n = e === 'x' ? 'y' : 'x'), n }(t, s)); const r = n[e + 'AxisID'] || a[e] || e; o[r] = o[r] || Object.create(null), M(o[r], [{ axis: e }, i[r], l[t]]) }) }), Object.keys(o).forEach(function (t) { const e = o[t]; M(e, [A.scales[e.type], A.scale]) }), o } function li (t, e) { return (function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) { e[n] = arguments[n] } return w(Object.create(null), e, { merger (t, e, n, i) { t !== 'scales' && t !== 'scale' && t !== 'controllers' && _(t, e, n, i) } }) }(A, A.controllers[e], t || {})) } const ci = (function () { function t (t) { this._config = (function (t) { const e = (t = t || {}).data = t.data || { datasets: [], labels: [] }; e.datasets = e.datasets || [], e.labels = e.labels || []; const n = si(t, t.options); const i = t.options = li(t.options, t.type); return i.hover = w(Object.create(null), [A.interaction, A.hover, i.interaction, i.hover]), i.scales = n, i.title = !1 !== i.title && w(Object.create(null), [A.plugins.title, i.title]), i.tooltips = !1 !== i.tooltips && w(Object.create(null), [A.interaction, A.plugins.tooltip, i.interaction, i.tooltips]), t }(t)) } return t.prototype.update = function (t) { const e = this._config; const n = si(e, t); (t = li(t, e.type)).scales = n, e.options = t }, e(t, [{ key: 'type', get () { return this._config.type } }, { key: 'data', get () { return this._config.data }, set (t) { this._config.data = t } }, { key: 'options', get () { return this._config.options } }, { key: 'plugins', get () { return this._config.plugins } }]), t }()); const ui = ['top', 'bottom', 'left', 'right', 'chartArea']; function hi (t, e) { return t === 'top' || t === 'bottom' || !ui.includes(t) && e === 'x' } function fi (t, e) { return function (n, i) { return n[t] === i[t] ? n[e] - i[e] : n[t] - i[t] } } function di (t) { const e = t.chart; const n = e.options.animation; e._plugins.notify(e, 'afterRender'), v(n && n.onComplete, [t], e) } function pi (t) { const e = t.chart; const n = e.options.animation; v(n && n.onProgress, [t], e) } function gi () { return typeof window !== 'undefined' && typeof document !== 'undefined' } function vi (t) { return gi() && typeof t === 'string' ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t } const mi = (function () { function t (e, n) { const i = this; this.config = n = new ci(n); const r = vi(e); const a = t.getChart(r); if (a) { throw new Error("Canvas is already in use. Chart with ID '" + a.id + "' must be destroyed before the canvas can be reused.") } this.platform = i._initializePlatform(r, n); const o = i.platform.acquireContext(r, n); const l = o && o.canvas; const c = l && l.height; const h = l && l.width; this.id = u(), this.ctx = o, this.canvas = l, this.width = h, this.height = c, this.aspectRatio = c ? h / c : null, this.options = n.options, this._layers = [], this._metasets = [], this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._sortedMetasets = [], this.scales = {}, this.scale = void 0, this._plugins = new ri(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, t.instances[i.id] = i, o && l ? (s.listen(i, 'complete', di), s.listen(i, 'progress', pi), i._initialize(), i.attached && i.update()) : console.error("Failed to create chart: can't acquire context from the given item") } const i = t.prototype; return i._initialize = function () { const t = this; return t._plugins.notify(t, 'beforeInit'), t.options.responsive ? t.resize() : Dt(t, t.options.devicePixelRatio), t.bindEvents(), t._plugins.notify(t, 'afterInit'), t }, i._initializePlatform = function (t, e) { return e.platform ? new e.platform() : !gi() || typeof OffscreenCanvas !== 'undefined' && t instanceof OffscreenCanvas ? new ee() : new ze() }, i.clear = function () { return rt(this), this }, i.stop = function () { return s.stop(this), this }, i.resize = function (t, e) { s.running(this) ? this._resizeBeforeDraw = { width: t, height: e } : this._resize(t, e) }, i._resize = function (t, e) { const n = this; const i = n.options; const r = n.canvas; const a = i.maintainAspectRatio && n.aspectRatio; const o = n.platform.getMaximumSize(r, t, e, a); const s = n.currentDevicePixelRatio; const l = i.devicePixelRatio || n.platform.getDevicePixelRatio(); n.width === o.width && n.height === o.height && s === l || (r.width = n.width = o.width, r.height = n.height = o.height, r.style && (r.style.width = o.width + 'px', r.style.height = o.height + 'px'), Dt(n, l), n._plugins.notify(n, 'resize', [o]), v(i.onResize, [o], n), n.attached && n.update('resize')) }, i.ensureScalesHaveIDs = function () { const t = this.options; const e = t.scales || {}; const n = t.scale; m(e, function (t, e) { t.id = e }), n && (n.id = n.id || 'scale') }, i.buildOrUpdateScales = function () { const t = this; const e = t.options; const n = e.scales; const i = t.scales || {}; const r = Object.keys(i).reduce(function (t, e) { return t[e] = !1, t }, {}); let a = []; n && (a = a.concat(Object.keys(n).map(function (t) { const e = n[t]; const i = oi(t, e); const r = i === 'r'; const a = i === 'x'; return { options: e, dposition: r ? 'chartArea' : a ? 'bottom' : 'left', dtype: r ? 'radialLinear' : a ? 'category' : 'linear' } }))), m(a, function (n) { const a = n.options; const o = a.id; const s = oi(o, a); const l = g(a.type, n.dtype); void 0 !== a.position && hi(a.position, s) === hi(n.dposition) || (a.position = n.dposition), r[o] = !0; let c = null; o in i && i[o].type === l ? c = i[o] : (c = new (ii.getScale(l))({ id: o, type: l, ctx: t.ctx, chart: t }), i[c.id] = c); c.init(a, e), n.isDefault && (t.scale = c) }), m(r, function (t, e) { t || delete i[e] }), t.scales = i, m(i, function (e) { e.fullWidth = e.options.fullWidth, e.position = e.options.position, e.weight = e.options.weight, Jt.addBox(t, e) }) }, i._updateMetasetIndex = function (t, e) { const n = this._metasets; const i = t.index; i !== e && (n[i] = n[e], n[e] = t, t.index = e) }, i._updateMetasets = function () { const t = this; const e = t._metasets; const n = t.data.datasets.length; const i = e.length; if (i > n) { for (let r = n; r < i; ++r) { t._destroyDatasetMeta(r) }e.splice(n, i - n) }t._sortedMetasets = e.slice(0).sort(fi('order', 'index')) }, i.buildOrUpdateControllers = function () { let t; let e; const i = this; const r = []; const a = i.data.datasets; for (t = 0, e = a.length; t < e; t++) { const o = a[t]; let s = i.getDatasetMeta(t); const l = o.type || i.config.type; if (s.type && s.type !== l && (i._destroyDatasetMeta(t), s = i.getDatasetMeta(t)), s.type = l, s.indexAxis = o.indexAxis || ai(l, i.options), s.order = o.order || 0, i._updateMetasetIndex(s, t), s.label = '' + o.label, s.visible = i.isDatasetVisible(t), s.controller) { s.controller.updateIndex(t), s.controller.linkScales() } else { const c = A.controllers[l]; const u = ii.getController(l); n(u.prototype, { dataElementType: ii.getElement(c.dataElementType), datasetElementType: c.datasetElementType && ii.getElement(c.datasetElementType), dataElementOptions: c.dataElementOptions, datasetElementOptions: c.datasetElementOptions }), s.controller = new u(i, t), r.push(s.controller) } } return i._updateMetasets(), r }, i._resetElements = function () { const t = this; m(t.data.datasets, function (e, n) { t.getDatasetMeta(n).controller.reset() }, t) }, i.reset = function () { this._resetElements(), this._plugins.notify(this, 'reset') }, i.update = function (t) { let e; let n; const i = this; const r = { mode: t }; if (m(i.scales, function (t) { Jt.removeBox(i, t) }), i.config.update(i.options), i.options = i.config.options, i._animationsDisabled = !i.options.animation, i.ensureScalesHaveIDs(), i.buildOrUpdateScales(), i._plugins.invalidate(), !1 !== i._plugins.notify(i, 'beforeUpdate', [r])) { const a = i.buildOrUpdateControllers(); for (e = 0, n = i.data.datasets.length; e < n; e++) { i.getDatasetMeta(e).controller.buildOrUpdateElements() }i._updateLayout(), m(a, function (t) { t.reset() }), i._updateDatasets(t), i._plugins.notify(i, 'afterUpdate', [r]), i._layers.sort(fi('z', '_idx')), i._lastEvent && i._eventHandler(i._lastEvent, !0), i.render() } }, i._updateLayout = function () { const t = this; !1 !== t._plugins.notify(t, 'beforeLayout') && (Jt.update(t, t.width, t.height), t._layers = [], m(t.boxes, function (e) { let n; e.configure && e.configure(), (n = t._layers).push.apply(n, e._layers()) }, t), t._layers.forEach(function (t, e) { t._idx = e }), t._plugins.notify(t, 'afterLayout')) }, i._updateDatasets = function (t) { const e = this; const n = typeof t === 'function'; const i = { mode: t }; if (!1 !== e._plugins.notify(e, 'beforeDatasetsUpdate', [i])) { for (let r = 0, a = e.data.datasets.length; r < a; ++r) { e._updateDataset(r, n ? t({ datasetIndex: r }) : t) }e._plugins.notify(e, 'afterDatasetsUpdate', [i]) } }, i._updateDataset = function (t, e) { const n = this; const i = n.getDatasetMeta(t); const r = { meta: i, index: t, mode: e }; !1 !== n._plugins.notify(n, 'beforeDatasetUpdate', [r]) && (i.controller._update(e), n._plugins.notify(n, 'afterDatasetUpdate', [r])) }, i.render = function () { const t = this; !1 !== t._plugins.notify(t, 'beforeRender') && (s.has(t) ? t.attached && !s.running(t) && s.start(t) : (t.draw(), di({ chart: t }))) }, i.draw = function () { let t; const e = this; if (e._resizeBeforeDraw) { const n = e._resizeBeforeDraw; const i = n.width; const r = n.height; e._resize(i, r), e._resizeBeforeDraw = null } if (e.clear(), !(e.width <= 0 || e.height <= 0) && !1 !== e._plugins.notify(e, 'beforeDraw')) { const a = e._layers; for (t = 0; t < a.length && a[t].z <= 0; ++t) { a[t].draw(e.chartArea) } for (e._drawDatasets(); t < a.length; ++t) { a[t].draw(e.chartArea) }e._plugins.notify(e, 'afterDraw') } }, i._getSortedDatasetMetas = function (t) { let e; let n; const i = this._sortedMetasets; const r = []; for (e = 0, n = i.length; e < n; ++e) { const a = i[e]; t && !a.visible || r.push(a) } return r }, i.getSortedVisibleDatasetMetas = function () { return this._getSortedDatasetMetas(!0) }, i._drawDatasets = function () { const t = this; if (!1 !== t._plugins.notify(t, 'beforeDatasetsDraw')) { for (let e = t.getSortedVisibleDatasetMetas(), n = e.length - 1; n >= 0; --n) { t._drawDataset(e[n]) }t._plugins.notify(t, 'afterDatasetsDraw') } }, i._drawDataset = function (t) { const e = this; const n = e.ctx; const i = t._clip; const r = e.chartArea; const a = { meta: t, index: t.index }; !1 !== e._plugins.notify(e, 'beforeDatasetDraw', [a]) && (st(n, { left: !1 === i.left ? 0 : r.left - i.left, right: !1 === i.right ? e.width : r.right + i.right, top: !1 === i.top ? 0 : r.top - i.top, bottom: !1 === i.bottom ? e.height : r.bottom + i.bottom }), t.controller.draw(), lt(n), e._plugins.notify(e, 'afterDatasetDraw', [a])) }, i.getElementsAtEventForMode = function (t, e, n, i) { const r = zt.modes[e]; return typeof r === 'function' ? r(this, t, n, i) : [] }, i.getDatasetMeta = function (t) { const e = this.data.datasets[t]; const n = this._metasets; let i = n.filter(function (t) { return t._dataset === e }).pop(); return i || (i = n[t] = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: e.order || 0, index: t, _dataset: e, _parsed: [], _sorted: !1 }), i }, i.getContext = function () { return this.$context || (this.$context = Object.create(null, { chart: { value: this } })) }, i.getVisibleDatasetCount = function () { return this.getSortedVisibleDatasetMetas().length }, i.isDatasetVisible = function (t) { const e = this.data.datasets[t]; if (!e) { return !1 } const n = this.getDatasetMeta(t); return typeof n.hidden === 'boolean' ? !n.hidden : !e.hidden }, i.setDatasetVisibility = function (t, e) { this.getDatasetMeta(t).hidden = !e }, i.toggleDataVisibility = function (t) { this._hiddenIndices[t] = !this._hiddenIndices[t] }, i.getDataVisibility = function (t) { return !this._hiddenIndices[t] }, i._updateDatasetVisibility = function (t, e) { const n = this; const i = e ? 'show' : 'hide'; const r = n.getDatasetMeta(t); const a = r.controller._resolveAnimations(void 0, i); n.setDatasetVisibility(t, e), a.update(r, { visible: e }), n.update(function (e) { return e.datasetIndex === t ? i : void 0 }) }, i.hide = function (t) { this._updateDatasetVisibility(t, !1) }, i.show = function (t) { this._updateDatasetVisibility(t, !0) }, i._destroyDatasetMeta = function (t) { const e = this; const n = e._metasets && e._metasets[t]; n && (n.controller._destroy(), delete e._metasets[t]) }, i.destroy = function () { let e; let n; const i = this; const r = i.canvas; for (i.stop(), s.remove(i), e = 0, n = i.data.datasets.length; e < n; ++e) { i._destroyDatasetMeta(e) }r && (i.unbindEvents(), rt(i), i.platform.releaseContext(i.ctx), i.canvas = null, i.ctx = null), i._plugins.notify(i, 'destroy'), delete t.instances[i.id] }, i.toBase64Image = function () { let t; return (t = this.canvas).toDataURL.apply(t, arguments) }, i.bindEvents = function () { const t = this; const e = t._listeners; const n = t.platform; const i = function (i, r) { n.addEventListener(t, i, r), e[i] = r }; const r = function (i, r) { e[i] && (n.removeEventListener(t, i, r), delete e[i]) }; let a = function (e, n, i) { e.offsetX = n, e.offsetY = i, t._eventHandler(e) }; if (m(t.options.events, function (t) { return i(t, a) }), t.options.responsive) { let o; a = function (e, n) { t.canvas && t.resize(e, n) }; const s = function e () { r('attach', e), t.attached = !0, t.resize(), i('resize', a), i('detach', o) }; o = function () { t.attached = !1, r('resize', a), i('attach', s) }, n.isAttached(t.canvas) ? s() : o() } else { t.attached = !0 } }, i.unbindEvents = function () { const t = this; const e = t._listeners; e && (delete t._listeners, m(e, function (e, n) { t.platform.removeEventListener(t, n, e) })) }, i.updateHoverStyle = function (t, e, n) { let i; let r; let a; const o = n ? 'set' : 'remove'; for (e === 'dataset' && this.getDatasetMeta(t[0].datasetIndex).controller['_' + o + 'DatasetHoverStyle'](), r = 0, a = t.length; r < a; ++r) { (i = t[r]) && this.getDatasetMeta(i.datasetIndex).controller[o + 'HoverStyle'](i.element, i.datasetIndex, i.index) } }, i.getActiveElements = function () { return this._active || [] }, i.setActiveElements = function (t) { const e = this; const n = e._active || []; const i = t.map(function (t) { const n = t.datasetIndex; const i = t.index; const r = e.getDatasetMeta(n); if (!r) { throw new Error('No dataset found at index ' + n) } return { datasetIndex: n, element: r.data[i], index: i } }); !b(i, n) && (e._active = i, e._updateHoverStyles(i, n)) }, i._updateHoverStyles = function (t, e) { const n = this; const i = (n.options || {}).hover; e.length && n.updateHoverStyle(e, i.mode, !1), t.length && i.mode && n.updateHoverStyle(t, i.mode, !0) }, i._eventHandler = function (t, e) { const n = this; if (!1 !== n._plugins.notify(n, 'beforeEvent', [t, e])) { return n._handleEvent(t, e), n._plugins.notify(n, 'afterEvent', [t, e]), n.render(), n } }, i._handleEvent = function (t, e) { let n; const i = this; const r = i._active || []; const a = i.options; const o = a.hover; const s = e; let l = []; return t.type === 'mouseout' ? i._lastEvent = null : (l = i.getElementsAtEventForMode(t, o.mode, o, s), i._lastEvent = t.type === 'click' ? i._lastEvent : t), v(a.onHover || a.hover.onHover, [t, l, i], i), t.type !== 'mouseup' && t.type !== 'click' && t.type !== 'contextmenu' || ot(t, i.chartArea) && v(a.onClick, [t, l, i], i), ((n = !b(l, r)) || e) && (i._active = l, i._updateHoverStyles(l, r)), n }, e(t, [{ key: 'data', get () { return this.config.data }, set (t) { this.config.data = t } }]), t }()); mi.defaults = A, mi.instances = {}, mi.registry = ii, mi.version = 'v3.0.0-beta.5', mi.getChart = function (t) { const e = vi(t); return Object.values(mi.instances).filter(function (t) { return t.canvas === e }).pop() }; const bi = function () { return m(mi.instances, function (t) { return t._plugins.invalidate() }) }; mi.register = function () { ii.add.apply(ii, arguments), bi() }, mi.unregister = function () { ii.remove.apply(ii, arguments), bi() }; const xi = Number.EPSILON || 1e-14; function yi (t, e, n, i) { const r = t.skip ? e : t; const a = e; const o = n.skip ? e : n; const s = Math.sqrt(Math.pow(a.x - r.x, 2) + Math.pow(a.y - r.y, 2)); const l = Math.sqrt(Math.pow(o.x - a.x, 2) + Math.pow(o.y - a.y, 2)); let c = s / (s + l); let u = l / (s + l); const h = i * (c = isNaN(c) ? 0 : c); const f = i * (u = isNaN(u) ? 0 : u); return { previous: { x: a.x - h * (o.x - r.x), y: a.y - h * (o.y - r.y) }, next: { x: a.x + f * (o.x - r.x), y: a.y + f * (o.y - r.y) } } } function _i (t) { let e; let n; let i; let r; let a; let o; let s; let l; let c; const u = (t || []).map(function (t) { return { model: t, deltaK: 0, mK: 0 } }); const h = u.length; for (e = 0; e < h; ++e) { if (!(i = u[e]).model.skip) { if (n = e > 0 ? u[e - 1] : null, (r = e < h - 1 ? u[e + 1] : null) && !r.model.skip) { const f = r.model.x - i.model.x; i.deltaK = f !== 0 ? (r.model.y - i.model.y) / f : 0 }!n || n.model.skip ? i.mK = i.deltaK : !r || r.model.skip ? i.mK = n.deltaK : j(n.deltaK) !== j(i.deltaK) ? i.mK = 0 : i.mK = (n.deltaK + i.deltaK) / 2 } } for (e = 0; e < h - 1; ++e) { i = u[e], r = u[e + 1], i.model.skip || r.model.skip || (W(i.deltaK, 0, xi) ? i.mK = r.mK = 0 : (a = i.mK / i.deltaK, o = r.mK / i.deltaK, (l = Math.pow(a, 2) + Math.pow(o, 2)) <= 9 || (s = 3 / Math.sqrt(l), i.mK = a * s * i.deltaK, r.mK = o * s * i.deltaK))) } for (e = 0; e < h; ++e) { (i = u[e]).model.skip || (n = e > 0 ? u[e - 1] : null, r = e < h - 1 ? u[e + 1] : null, n && !n.model.skip && (c = (i.model.x - n.model.x) / 3, i.model.controlPointPreviousX = i.model.x - c, i.model.controlPointPreviousY = i.model.y - c * i.mK), r && !r.model.skip && (c = (r.model.x - i.model.x) / 3, i.model.controlPointNextX = i.model.x + c, i.model.controlPointNextY = i.model.y + c * i.mK)) } } function wi (t, e, n) { return Math.max(Math.min(t, n), e) } function Mi (t, e, n, i) { let r, a, o, s; if (e.spanGaps && (t = t.filter(function (t) { return !t.skip })), e.cubicInterpolationMode === 'monotone') { _i(t) } else { let l = i ? t[t.length - 1] : t[0]; for (r = 0, a = t.length; r < a; ++r) { s = yi(l, o = t[r], t[Math.min(r + 1, a - (i ? 0 : 1)) % a], e.tension), o.controlPointPreviousX = s.previous.x, o.controlPointPreviousY = s.previous.y, o.controlPointNextX = s.next.x, o.controlPointNextY = s.next.y, l = o } }e.capBezierPoints && (function (t, e) { let n, i, r; for (n = 0, i = t.length; n < i; ++n) { ot(r = t[n], e) && (n > 0 && ot(t[n - 1], e) && (r.controlPointPreviousX = wi(r.controlPointPreviousX, e.left, e.right), r.controlPointPreviousY = wi(r.controlPointPreviousY, e.top, e.bottom)), n < t.length - 1 && ot(t[n + 1], e) && (r.controlPointNextX = wi(r.controlPointNextX, e.left, e.right), r.controlPointNextY = wi(r.controlPointNextY, e.top, e.bottom))) } }(t, n)) } function ki (t, e, n, i) { return { x: t.x + n * (e.x - t.x), y: t.y + n * (e.y - t.y) } } function Si (t, e, n, i) { return { x: t.x + n * (e.x - t.x), y: i === 'middle' ? n < 0.5 ? t.y : e.y : i === 'after' ? n < 1 ? t.y : e.y : n > 0 ? e.y : t.y } } function Pi (t, e, n, i) { const r = { x: t.controlPointNextX, y: t.controlPointNextY }; const a = { x: e.controlPointPreviousX, y: e.controlPointPreviousY }; const o = ki(t, r, n); const s = ki(r, a, n); const l = ki(a, e, n); const c = ki(o, s, n); const u = ki(s, l, n); return ki(c, u, n) } function Di (t, e, n) { return t ? (function (t, e) { return { x (n) { return t + t + e - n }, setWidth (t) { e = t }, textAlign (t) { return t === 'center' ? t : t === 'right' ? 'left' : 'right' }, xPlus (t, e) { return t - e }, leftForLtr (t, e) { return t - e } } }(e, n)) : { x (t) { return t }, setWidth (t) {}, textAlign (t) { return t }, xPlus (t, e) { return t + e }, leftForLtr (t, e) { return t } } } function Ai (t, e) { let n, i; e !== 'ltr' && e !== 'rtl' || (i = [(n = t.canvas.style).getPropertyValue('direction'), n.getPropertyPriority('direction')], n.setProperty('direction', e, 'important'), t.prevTextDirection = i) } function Ti (t, e) { void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty('direction', e[0], e[1])) } function Oi (t) { return t === 'angle' ? { between: Z, compare: q, normalize: G } : { between (t, e, n) { return t >= e && t <= n }, compare (t, e) { return t - e }, normalize (t) { return t } } } function Ei (t, e, n, i) { return { start: t % i, end: e % i, loop: n && (e - t + 1) % i == 0 } } function Li (t, e, n) { if (!n) { return [t] } for (var i, r, a, o = n.property, s = n.start, l = n.end, c = e.length, u = Oi(o), h = u.compare, f = u.between, d = u.normalize, p = (function (t, e, n) { let i; let r; const a = n.property; const o = n.start; const s = n.end; const l = Oi(a); const c = l.between; const u = l.normalize; const h = e.length; let f = t.start; let d = t.end; const p = t.loop; if (p) { for (f += h, d += h, i = 0, r = h; i < r && c(u(e[f % h][a]), o, s); ++i) { f--, d-- }f %= h, d %= h } return d < f && (d += h), { start: f, end: d, loop: p } }(t, e, n)), g = p.start, v = p.end, m = p.loop, b = [], x = !1, y = null, _ = function () { return x || f(s, a, i) && h(s, a) !== 0 }, w = function () { return !x || h(l, i) === 0 || f(l, a, i) }, M = g, k = g; M <= v; ++M) { (r = e[M % c]).skip || (i = d(r[o]), x = f(i, s, l), y === null && _() && (y = h(i, s) === 0 ? M : k), y !== null && w() && (b.push(Ei(y, M, m, c)), y = null), k = M, a = i) } return y !== null && b.push(Ei(y, v, m, c)), b } function Ci (t, e) { for (var n = [], i = t.segments, r = 0; r < i.length; r++) { const a = Li(i[r], t.points, e); a.length && n.push.apply(n, a) } return n } function Ri (t) { const e = t.points; const n = t.options.spanGaps; const i = e.length; if (!i) { return [] } const r = !!t._loop; const a = (function (t, e, n, i) { let r = 0; let a = e - 1; if (n && !i) { for (;r < e && !t[r].skip;) { r++ } } for (;r < e && t[r].skip;) { r++ } for (r %= e, n && (a += r); a > r && t[a % e].skip;) { a-- } return { start: r, end: a %= e } }(e, i, r, n)); const o = a.start; const s = a.end; return !0 === n ? [{ start: o, end: s, loop: r }] : (function (t, e, n, i) { let r; const a = t.length; const o = []; let s = e; let l = t[e]; for (r = e + 1; r <= n; ++r) { const c = t[r % a]; c.skip || c.stop ? l.skip || (i = !1, o.push({ start: e % a, end: (r - 1) % a, loop: i }), e = s = c.stop ? r : null) : (s = r, l.skip && (e = r)), l = c } return s !== null && o.push({ start: e % a, end: s % a, loop: i }), o }(e, o, s < o ? s + i : s, !!t._fullLoop && o === 0 && s === i - 1)) } const Fi = Object.freeze({ __proto__: null, easingEffects: Ke, color: Tn, getHoverColor: On, requestAnimFrame: a, fontString (t, e, n) { return e + ' ' + t + 'px ' + n }, noop: l, uid: u, isNullOrUndef: h, isArray: f, isObject: d, isFinite: p, valueOrDefault: g, callback: v, each: m, _elementsEqual: b, clone: x, _merger: _, merge: w, mergeIf: M, _mergerIf: k, _deprecated (t, e, n, i) { void 0 !== e && console.warn(t + ': "' + n + '" is deprecated. Please use "' + i + '" instead') }, resolveObjectKey: S, _capitalize: P, toFontString: tt, _measureText: et, _longestText: nt, _alignPixel: it, clear: rt, drawPoint: at, _isPointInArea: ot, clipArea: st, unclipArea: lt, _steppedLineTo: ct, _bezierCurveTo: ut, _lookup: ht, _lookupByKey: ft, _rlookupByKey: dt, _filterBetween: pt, listenArrayEvents: vt, unlistenArrayEvents: mt, _arrayUnique: bt, splineCurve: yi, splineCurveMonotone: _i, _updateBezierControlPoints: Mi, _getParentNode: xt, getStyle: wt, getRelativePosition: St, getMaximumSize: Pt, retinaScale: Dt, supportsEventListenerOptions: At, readUsedSize: Tt, _pointInLine: ki, _steppedInterpolation: Si, _bezierInterpolation: Pi, toLineHeight: It, toTRBL: Vt, toTRBLCorners: Wt, toPadding: Nt, toFont: Ht, resolve: jt, PI: T, TAU: O, PITAU: E, INFINITY: L, RAD_PER_DEG: C, HALF_PI: R, QUARTER_PI: F, TWO_THIRDS_PI: z, _factorize: I, log10: B, isNumber: V, almostEquals: W, almostWhole: N, _setMinAndMaxByKey: H, sign: j, toRadians: Y, toDegrees: U, _decimalPlaces: X, getAngleFromPoint: $, distanceBetweenPoints: K, _angleDiff: q, _normalizeAngle: G, _angleBetween: Z, _limitValue: Q, _int16Range: J, getRtlAdapter: Di, overrideTextDirection: Ai, restoreTextDirection: Ti, _boundSegment: Li, _boundSegments: Ci, _computeSegments: Ri }); function zi () { throw new Error('This method is not implemented: either no adapter can be found or an incomplete integration was provided.') } const Ii = (function () { function t (t) { this.options = t || {} } const e = t.prototype; return e.formats = function () { return zi() }, e.parse = function (t, e) { return zi() }, e.format = function (t, e) { return zi() }, e.add = function (t, e, n) { return zi() }, e.diff = function (t, e, n) { return zi() }, e.startOf = function (t, e, n) { return zi() }, e.endOf = function (t, e) { return zi() }, t }()); Ii.override = function (t) { n(Ii.prototype, t) }; const Bi = { _date: Ii }; function Vi (t) { let e; let n; let i; let r; const a = (function (t) { if (!t._cache.$bar) { for (var e = t.getMatchingVisibleMetas('bar'), n = [], i = 0, r = e.length; i < r; i++) { n = n.concat(e[i].controller.getAllParsedValues(t)) }t._cache.$bar = bt(n.sort(function (t, e) { return t - e })) } return t._cache.$bar }(t)); let o = t._length; const s = function () { o = Math.min(o, e && Math.abs(i - r) || o), r = i }; for (e = 0, n = a.length; e < n; ++e) { i = t.getPixelForValue(a[e]), s() } for (e = 0, n = t.ticks.length; e < n; ++e) { i = t.getPixelForTick(e), s() } return o } function Wi (t, e, n, i) { return f(t) ? (function (t, e, n, i) { const r = n.parse(t[0], i); const a = n.parse(t[1], i); const o = Math.min(r, a); const s = Math.max(r, a); let l = o; let c = s; Math.abs(o) > Math.abs(s) && (l = s, c = o), e[n.axis] = c, e._custom = { barStart: l, barEnd: c, start: r, end: a, min: o, max: s } }(t, e, n, i)) : e[n.axis] = n.parse(t, i), e } function Ni (t, e, n, i) { let r; let a; let o; let s; const l = t.iScale; const c = t.vScale; const u = l.getLabels(); const h = l === c; const f = []; for (r = n, a = n + i; r < a; ++r) { s = e[r], (o = {})[l.axis] = h || l.parse(u[r], r), f.push(Wi(s, o, c, r)) } return f } function Hi (t) { return t && void 0 !== t.barStart && void 0 !== t.barEnd } const ji = (function (t) { function e () { return t.apply(this, arguments) || this }i(e, t); const n = e.prototype; return n.parsePrimitiveData = function (t, e, n, i) { return Ni(t, e, n, i) }, n.parseArrayData = function (t, e, n, i) { return Ni(t, e, n, i) }, n.parseObjectData = function (t, e, n, i) { let r; let a; let o; let s; const l = t.iScale; const c = t.vScale; const u = this._parsing; const h = u.xAxisKey; const f = void 0 === h ? 'x' : h; const d = u.yAxisKey; const p = void 0 === d ? 'y' : d; const g = l.axis === 'x' ? f : p; const v = c.axis === 'x' ? f : p; const m = []; for (r = n, a = n + i; r < a; ++r) { s = e[r], (o = {})[l.axis] = l.parse(S(s, g), r), m.push(Wi(S(s, v), o, c, r)) } return m }, n.updateRangeFromParsed = function (e, n, i, r) { t.prototype.updateRangeFromParsed.call(this, e, n, i, r); const a = i._custom; a && n === this._cachedMeta.vScale && (e.min = Math.min(e.min, a.min), e.max = Math.max(e.max, a.max)) }, n.getLabelAndValue = function (t) { const e = this._cachedMeta; const n = e.iScale; const i = e.vScale; const r = this.getParsed(t); const a = r._custom; const o = Hi(a) ? '[' + a.start + ', ' + a.end + ']' : '' + i.getLabelForValue(r[i.axis]); return { label: '' + n.getLabelForValue(r[n.axis]), value: o } }, n.initialize = function () { const e = this; e.enableOptionSharing = !0, t.prototype.initialize.call(this), e._cachedMeta.stack = e.getDataset().stack }, n.update = function (t) { const e = this._cachedMeta; this.updateElements(e.data, 0, e.data.length, t) }, n.updateElements = function (t, e, n, i) { const r = this; const a = i === 'reset'; const o = r._cachedMeta.vScale; const s = o.getBasePixel(); const l = o.isHorizontal(); const c = r._getRuler(); const u = r.resolveDataElementOptions(e, i); const h = r.getSharedOptions(u); const f = r.includeOptions(i, h); r.updateSharedOptions(h, i, u); for (let d = e; d < e + n; d++) { const p = h || r.resolveDataElementOptions(d, i); const g = r._calculateBarValuePixels(d, p); const v = r._calculateBarIndexPixels(d, c, p); const m = { horizontal: l, base: a ? s : g.base, x: l ? a ? s : g.head : v.center, y: l ? v.center : a ? s : g.head, height: l ? v.size : void 0, width: l ? void 0 : v.size }; f && (m.options = p), r.updateElement(t[d], d, m, i) } }, n._getStacks = function (t, e) { let n; let i; const r = this._cachedMeta.iScale; const a = r.getMatchingVisibleMetas(this._type); const o = r.options.stacked; const s = a.length; const l = []; for (n = 0; n < s; ++n) { if (i = a[n], void 0 !== e) { const c = i.controller.getParsed(e)[i.controller._cachedMeta.vScale.axis]; if (h(c) || isNaN(c)) { continue } } if ((!1 === o || !l.includes(i.stack) || void 0 === o && void 0 === i.stack) && l.push(i.stack), i.index === t) { break } } return l.length || l.push(void 0), l }, n._getStackCount = function (t) { return this._getStacks(void 0, t).length }, n._getStackIndex = function (t, e) { const n = this._getStacks(t); const i = void 0 !== e ? n.indexOf(e) : -1; return i === -1 ? n.length - 1 : i }, n._getRuler = function () { let t; let e; const n = this; const i = n._cachedMeta; const r = i.iScale; const a = []; for (t = 0, e = i.data.length; t < e; ++t) { a.push(r.getPixelForValue(n.getParsed(t)[r.axis], t)) } return { min: Vi(r), pixels: a, start: r._startPixel, end: r._endPixel, stackCount: n._getStackCount(), scale: r } }, n._calculateBarValuePixels = function (t, e) { let n; let i; const r = this; const a = r._cachedMeta; const o = a.vScale; const s = e.base; const l = e.minBarLength; const c = r.getParsed(t); const u = c._custom; const f = Hi(u); let d = c[o.axis]; let p = 0; let g = a._stacked ? r.applyStack(o, c) : d; g !== d && (p = g - d, g = d), f && (d = u.barStart, g = u.barEnd - u.barStart, d !== 0 && j(d) !== j(u.barEnd) && (p = 0), p += d); const v = h(s) || f ? p : s; let m = Q(o.getPixelForValue(v), o._startPixel - 10, o._endPixel + 10); return i = (n = this.chart.getDataVisibility(t) ? o.getPixelForValue(p + g) : m) - m, void 0 !== l && Math.abs(i) < l && (i = i < 0 ? -l : l, d === 0 && (m -= i / 2), n = m + i), { size: i, base: m, head: n, center: n + i / 2 } }, n._calculateBarIndexPixels = function (t, e, n) { const i = this; const r = i.chart.options.skipNull ? i._getStackCount(t) : e.stackCount; const a = n.barThickness === 'flex' ? (function (t, e, n, i) { const r = e.pixels; const a = r[t]; let o = t > 0 ? r[t - 1] : null; let s = t < r.length - 1 ? r[t + 1] : null; const l = n.categoryPercentage; o === null && (o = a - (s === null ? e.end - e.start : s - a)), s === null && (s = a + a - o); const c = a - (a - Math.min(o, s)) / 2 * l; return { chunk: Math.abs(s - o) / 2 * l / i, ratio: n.barPercentage, start: c } }(t, e, n, r)) : (function (t, e, n, i) { let r; let a; const o = n.barThickness; return h(o) ? (r = e.min * n.categoryPercentage, a = n.barPercentage) : (r = o * i, a = 1), { chunk: r / i, ratio: a, start: e.pixels[t] - r / 2 } }(t, e, n, r)); const o = i._getStackIndex(i.index, i._cachedMeta.stack); const s = a.start + a.chunk * o + a.chunk / 2; const l = Math.min(g(n.maxBarThickness, 1 / 0), a.chunk * a.ratio); return { base: s - l / 2, head: s + l / 2, center: s, size: l } }, n.draw = function () { const t = this; const e = t.chart; const n = t._cachedMeta; const i = n.vScale; const r = n.data; const a = r.length; let o = 0; for (st(e.ctx, e.chartArea); o < a; ++o) { isNaN(t.getParsed(o)[i.axis]) || r[o].draw(t._ctx) }lt(e.ctx) }, e }(Un)); ji.id = 'bar', ji.defaults = { datasetElementType: !1, dataElementType: 'bar', dataElementOptions: ['backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth', 'borderRadius', 'barPercentage', 'barThickness', 'base', 'categoryPercentage', 'maxBarThickness', 'minBarLength'], interaction: { mode: 'index' }, hover: {}, datasets: { categoryPercentage: 0.8, barPercentage: 0.9, animation: { numbers: { type: 'number', properties: ['x', 'y', 'base', 'width', 'height'] } } }, scales: { _index_: { type: 'category', offset: !0, gridLines: { offsetGridLines: !0 } }, _value_: { type: 'linear', beginAtZero: !0 } } }; const Yi = (function (t) { function e () { return t.apply(this, arguments) || this }i(e, t); const r = e.prototype; return r.initialize = function () { this.enableOptionSharing = !0, t.prototype.initialize.call(this) }, r.parseObjectData = function (t, e, n, i) { let r; let a; let o; const s = t.xScale; const l = t.yScale; const c = this._parsing; const u = c.xAxisKey; const h = void 0 === u ? 'x' : u; const f = c.yAxisKey; const d = void 0 === f ? 'y' : f; const p = []; for (r = n, a = n + i; r < a; ++r) { o = e[r], p.push({ x: s.parse(S(o, h), r), y: l.parse(S(o, d), r), _custom: o && o.r && +o.r }) } return p }, r.getMaxOverflow = function () { for (var t = (this._cachedMeta.data || []).length - 1, e = 0; t >= 0; --t) { e = Math.max(e, this.getStyle(t, !0).radius) } return e > 0 && e }, r.getLabelAndValue = function (t) { const e = this._cachedMeta; const n = e.xScale; const i = e.yScale; const r = this.getParsed(t); const a = n.getLabelForValue(r.x); const o = i.getLabelForValue(r.y); const s = r._custom; return { label: e.label, value: '(' + a + ', ' + o + (s ? ', ' + s : '') + ')' } }, r.update = function (t) { const e = this._cachedMeta.data; this.updateElements(e, 0, e.length, t) }, r.updateElements = function (t, e, n, i) { for (var r = this, a = i === 'reset', o = r._cachedMeta, s = o.xScale, l = o.yScale, c = r.resolveDataElementOptions(e, i), u = r.getSharedOptions(c), h = r.includeOptions(i, u), f = e; f < e + n; f++) { const d = t[f]; const p = !a && r.getParsed(f); const g = a ? s.getPixelForDecimal(0.5) : s.getPixelForValue(p.x); const v = a ? l.getBasePixel() : l.getPixelForValue(p.y); const m = { x: g, y: v, skip: isNaN(g) || isNaN(v) }; h && (m.options = r.resolveDataElementOptions(f, i), a && (m.options.radius = 0)), r.updateElement(d, f, m, i) }r.updateSharedOptions(u, i, c) }, r.resolveDataElementOptions = function (e, i) { const r = this; const a = r.chart; const o = r.getParsed(e); let s = t.prototype.resolveDataElementOptions.call(this, e, i); const l = r.getContext(e, i === 'active'); return s.$shared && (s = n({}, s, { $shared: !1 })), i !== 'active' && (s.radius = 0), s.radius += jt([o && o._custom, r._config.radius, a.options.elements.point.radius], l, e), s }, e }(Un)); Yi.id = 'bubble', Yi.defaults = { datasetElementType: !1, dataElementType: 'point', dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'hitRadius', 'radius', 'pointStyle', 'rotation'], animation: { numbers: { properties: ['x', 'y', 'borderWidth', 'radius'] } }, scales: { x: { type: 'linear' }, y: { type: 'linear' } }, tooltips: { callbacks: { title () { return '' } } } }; const Ui = (function (t) { function e (e, n) { let i; return (i = t.call(this, e, n) || this).enableOptionSharing = !0, i.innerRadius = void 0, i.outerRadius = void 0, i.offsetX = void 0, i.offsetY = void 0, i }i(e, t); const n = e.prototype; return n.linkScales = function () {}, n.parse = function (t, e) { let n; let i; const r = this.getDataset().data; const a = this._cachedMeta; for (n = t, i = t + e; n < i; ++n) { a._parsed[n] = +r[n] } }, n.getRingIndex = function (t) { for (var e = 0, n = 0; n < t; ++n) { this.chart.isDatasetVisible(n) && ++e } return e }, n._getRotationExtents = function () { for (var t = O, e = -O, n = this, i = n.chart.options, r = 0; r < n.chart.data.datasets.length; ++r) { if (n.chart.isDatasetVisible(r)) { const a = n.chart.data.datasets[r]; const o = Y(g(a.rotation, i.rotation) - 90); const s = Y(g(a.circumference, i.circumference)); t = Math.min(t, o), e = Math.max(e, o + s) } } return { rotation: t, circumference: e - t } }, n.update = function (t) { const e = this; const n = e.chart; const i = n.chartArea; const r = n.options; const a = e._cachedMeta; const o = a.data; const s = r.cutoutPercentage / 100 || 0; const l = e._getRingWeight(e.index); const c = e._getRotationExtents(); const u = c.circumference; const h = (function (t, e, n) { let i = 1; let r = 1; let a = 0; let o = 0; if (e < O) { let s = t % O; const l = (s += s >= T ? -O : s < -T ? O : 0) + e; const c = Math.cos(s); const u = Math.sin(s); const h = Math.cos(l); const f = Math.sin(l); const d = s <= 0 && l >= 0 || l >= O; const p = s <= R && l >= R || l >= O + R; const g = s <= -R && l >= -R || l >= T + R; const v = s === -T || l >= T ? -1 : Math.min(c, c * n, h, h * n); const m = g ? -1 : Math.min(u, u * n, f, f * n); const b = d ? 1 : Math.max(c, c * n, h, h * n); const x = p ? 1 : Math.max(u, u * n, f, f * n); i = (b - v) / 2, r = (x - m) / 2, a = -(b + v) / 2, o = -(x + m) / 2 } return { ratioX: i, ratioY: r, offsetX: a, offsetY: o } }(c.rotation, u, s)); const f = h.ratioX; const d = h.ratioY; const p = h.offsetX; const g = h.offsetY; const v = e.getMaxBorderWidth() + e.getMaxOffset(o); const m = (i.right - i.left - v) / f; const b = (i.bottom - i.top - v) / d; const x = Math.max(Math.min(m, b) / 2, 0); const y = (x - Math.max(x * s, 0)) / e._getVisibleDatasetWeightTotal(); e.offsetX = p * x, e.offsetY = g * x, a.total = e.calculateTotal(), e.outerRadius = x - y * e._getRingWeightOffset(e.index), e.innerRadius = Math.max(e.outerRadius - y * l, 0), e.updateElements(o, 0, o.length, t) }, n._circumference = function (t, e) { const n = this; const i = n.chart.options; const r = n._cachedMeta; const a = Y(g(n._config.circumference, i.circumference)); return e && i.animation.animateRotate ? 0 : this.chart.getDataVisibility(t) ? n.calculateCircumference(r._parsed[t] * a / O) : 0 }, n.updateElements = function (t, e, n, i) { let r; const a = this; const o = i === 'reset'; const s = a.chart; const l = s.chartArea; const c = s.options; const u = c.animation; const h = (l.left + l.right) / 2; const f = (l.top + l.bottom) / 2; const d = o && u.animateScale; const p = d ? 0 : a.innerRadius; const v = d ? 0 : a.outerRadius; const m = a.resolveDataElementOptions(e, i); const b = a.getSharedOptions(m); const x = a.includeOptions(i, b); let y = Y(g(a._config.rotation, c.rotation) - 90); for (r = 0; r < e; ++r) { y += a._circumference(r, o) } for (r = e; r < e + n; ++r) { const _ = a._circumference(r, o); const w = t[r]; const M = { x: h + a.offsetX, y: f + a.offsetY, startAngle: y, endAngle: y + _, circumference: _, outerRadius: v, innerRadius: p }; x && (M.options = b || a.resolveDataElementOptions(r, i)), y += _, a.updateElement(w, r, M, i) }a.updateSharedOptions(b, i, m) }, n.calculateTotal = function () { let t; const e = this._cachedMeta; const n = e.data; let i = 0; for (t = 0; t < n.length; t++) { const r = e._parsed[t]; !isNaN(r) && this.chart.getDataVisibility(t) && (i += Math.abs(r)) } return i }, n.calculateCircumference = function (t) { const e = this._cachedMeta.total; return e > 0 && !isNaN(t) ? O * (Math.abs(t) / e) : 0 }, n.getLabelAndValue = function (t) { const e = this._cachedMeta; return { label: (this.chart.data.labels || [])[t] || '', value: e._parsed[t] } }, n.getMaxBorderWidth = function (t) { let e; let n; let i; let r; let a; let o = 0; const s = this.chart; if (!t) { for (e = 0, n = s.data.datasets.length; e < n; ++e) { if (s.isDatasetVisible(e)) { t = (i = s.getDatasetMeta(e)).data, (r = i.controller) !== this && r.configure(); break } } } if (!t) { return 0 } for (e = 0, n = t.length; e < n; ++e) { (a = r.resolveDataElementOptions(e)).borderAlign !== 'inner' && (o = Math.max(o, a.borderWidth || 0, a.hoverBorderWidth || 0)) } return o }, n.getMaxOffset = function (t) { for (var e = 0, n = 0, i = t.length; n < i; ++n) { const r = this.resolveDataElementOptions(n); e = Math.max(e, r.offset || 0, r.hoverOffset || 0) } return e }, n._getRingWeightOffset = function (t) { for (var e = 0, n = 0; n < t; ++n) { this.chart.isDatasetVisible(n) && (e += this._getRingWeight(n)) } return e }, n._getRingWeight = function (t) { return Math.max(g(this.chart.data.datasets[t].weight, 1), 0) }, n._getVisibleDatasetWeightTotal = function () { return this._getRingWeightOffset(this.chart.data.datasets.length) || 1 }, e }(Un)); Ui.id = 'doughnut', Ui.defaults = { datasetElementType: !1, dataElementType: 'arc', dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'offset'], animation: { numbers: { type: 'number', properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth'] }, animateRotate: !0, animateScale: !1 }, aspectRatio: 1, legend: { labels: { generateLabels (t) { const e = t.data; return e.labels.length && e.datasets.length ? e.labels.map(function (e, n) { const i = t.getDatasetMeta(0).controller.getStyle(n); return { text: e, fillStyle: i.backgroundColor, strokeStyle: i.borderColor, lineWidth: i.borderWidth, hidden: !t.getDataVisibility(n), index: n } }) : [] } }, onClick (t, e, n) { n.chart.toggleDataVisibility(e.index), n.chart.update() } }, cutoutPercentage: 50, rotation: 0, circumference: 360, tooltips: { callbacks: { title () { return '' }, label (t) { let e = t.label; const n = ': ' + t.formattedValue; return f(e) ? (e = e.slice())[0] += n : e += n, e } } } }; const Xi = (function (t) { function e () { return t.apply(this, arguments) || this }i(e, t); const r = e.prototype; return r.initialize = function () { this.enableOptionSharing = !0, t.prototype.initialize.call(this) }, r.update = function (t) { const e = this; const i = e._cachedMeta; const r = i.dataset; const a = i.data; const o = void 0 === a ? [] : a; const s = e.chart._animationsDisabled; const l = (function (t, e, n) { const i = e.length; let r = 0; let a = i; if (t._sorted) { const o = t.iScale; const s = t._parsed; const l = o.axis; const c = o.getUserBounds(); const u = c.min; const h = c.max; const f = c.minDefined; const d = c.maxDefined; f && (r = Q(Math.min(ft(s, o.axis, u).lo, n ? i : ft(e, l, o.getPixelForValue(u)).lo), 0, i - 1)), a = d ? Q(Math.max(ft(s, o.axis, h).hi + 1, n ? 0 : ft(e, l, o.getPixelForValue(h)).hi + 1), r, i) - r : i - r } return { start: r, count: a } }(i, o, s)); let c = l.start; let u = l.count; if (e._drawStart = c, e._drawCount = u, (function (t) { const e = t.xScale; const i = t.yScale; const r = t._scaleRanges; const a = { xmin: e.min, xmax: e.max, ymin: i.min, ymax: i.max }; if (!r) { return t._scaleRanges = a, !0 } const o = r.xmin !== e.min || r.xmax !== e.max || r.ymin !== i.min || r.ymax !== i.max; return n(r, a), o }(i)) && !s && (c = 0, u = o.length), t !== 'resize') { const h = { points: o, options: e.resolveDatasetElementOptions() }; e.updateElement(r, void 0, h, t) }e.updateElements(o, c, u, t) }, r.updateElements = function (t, e, n, i) { for (var r = this, a = i === 'reset', o = r._cachedMeta, s = o.xScale, l = o.yScale, c = o._stacked, u = r.resolveDataElementOptions(e, i), h = r.getSharedOptions(u), f = r.includeOptions(i, h), d = g(r._config.spanGaps, r.chart.options.spanGaps), p = V(d) ? d : Number.POSITIVE_INFINITY, v = e > 0 && r.getParsed(e - 1), m = e; m < e + n; ++m) { const b = t[m]; const x = r.getParsed(m); const y = s.getPixelForValue(x.x, m); const _ = a ? l.getBasePixel() : l.getPixelForValue(c ? r.applyStack(l, x) : x.y, m); const w = { x: y, y: _, skip: isNaN(y) || isNaN(_), stop: m > 0 && x.x - v.x > p }; f && (w.options = h || r.resolveDataElementOptions(m, i)), r.updateElement(b, m, w, i), v = x }r.updateSharedOptions(h, i, u) }, r.resolveDatasetElementOptions = function (e) { const n = this._config; const i = this.chart.options; const r = i.elements.line; const a = t.prototype.resolveDatasetElementOptions.call(this, e); const o = g(n.showLine, i.showLine); return a.spanGaps = g(n.spanGaps, i.spanGaps), a.tension = g(n.tension, r.tension), a.stepped = jt([n.stepped, r.stepped]), o || (a.borderWidth = 0), a }, r.getMaxOverflow = function () { const t = this._cachedMeta; const e = t.dataset.options.borderWidth || 0; const n = t.data || []; if (!n.length) { return e } const i = n[0].size(); const r = n[n.length - 1].size(); return Math.max(e, i, r) / 2 }, r.draw = function () { this._cachedMeta.dataset.updateControlPoints(this.chart.chartArea), t.prototype.draw.call(this) }, e }(Un)); Xi.id = 'line', Xi.defaults = { datasetElementType: 'line', datasetElementOptions: ['backgroundColor', 'borderCapStyle', 'borderColor', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'borderWidth', 'capBezierPoints', 'cubicInterpolationMode', 'fill'], dataElementType: 'point', dataElementOptions: { backgroundColor: 'pointBackgroundColor', borderColor: 'pointBorderColor', borderWidth: 'pointBorderWidth', hitRadius: 'pointHitRadius', hoverHitRadius: 'pointHitRadius', hoverBackgroundColor: 'pointHoverBackgroundColor', hoverBorderColor: 'pointHoverBorderColor', hoverBorderWidth: 'pointHoverBorderWidth', hoverRadius: 'pointHoverRadius', pointStyle: 'pointStyle', radius: 'pointRadius', rotation: 'pointRotation' }, showLine: !0, spanGaps: !1, interaction: { mode: 'index' }, hover: {}, scales: { _index_: { type: 'category' }, _value_: { type: 'linear' } } }; const $i = (function (t) { function e (e, n) { let i; return (i = t.call(this, e, n) || this).innerRadius = void 0, i.outerRadius = void 0, i }i(e, t); const n = e.prototype; return n.update = function (t) { const e = this._cachedMeta.data; this._updateRadius(), this.updateElements(e, 0, e.length, t) }, n._updateRadius = function () { const t = this; const e = t.chart; const n = e.chartArea; const i = e.options; const r = Math.min(n.right - n.left, n.bottom - n.top); const a = Math.max(r / 2, 0); const o = (a - Math.max(i.cutoutPercentage ? a / 100 * i.cutoutPercentage : 1, 0)) / e.getVisibleDatasetCount(); t.outerRadius = a - o * t.index, t.innerRadius = t.outerRadius - o }, n.updateElements = function (t, e, n, i) { let r; const a = this; const o = i === 'reset'; const s = a.chart; const l = a.getDataset(); const c = s.options; const u = c.animation; const h = a._cachedMeta.rScale; const f = h.xCenter; const d = h.yCenter; const p = Y(c.startAngle) - 0.5 * T; let g = p; for (a._cachedMeta.count = a.countVisibleElements(), r = 0; r < e; ++r) { g += a._computeAngle(r, i) } for (r = e; r < e + n; r++) { const v = t[r]; let m = g; let b = g + a._computeAngle(r, i); let x = this.chart.getDataVisibility(r) ? h.getDistanceFromCenterForValue(l.data[r]) : 0; g = b, o && (u.animateScale && (x = 0), u.animateRotate && (m = p, b = p)); const y = { x: f, y: d, innerRadius: 0, outerRadius: x, startAngle: m, endAngle: b, options: a.resolveDataElementOptions(r, i) }; a.updateElement(v, r, y, i) } }, n.countVisibleElements = function () { const t = this; const e = this.getDataset(); const n = this._cachedMeta; let i = 0; return n.data.forEach(function (n, r) { !isNaN(e.data[r]) && t.chart.getDataVisibility(r) && i++ }), i }, n._computeAngle = function (t, e) { const n = this; const i = n._cachedMeta.count; const r = n.getDataset(); if (isNaN(r.data[t]) || !this.chart.getDataVisibility(t)) { return 0 } const a = n.getContext(t, e === 'active'); return Y(jt([n.chart.options.elements.arc.angle, 360 / i], a, t)) }, e }(Un)); $i.id = 'polarArea', $i.defaults = { dataElementType: 'arc', dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'offset'], animation: { numbers: { type: 'number', properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius'] }, animateRotate: !0, animateScale: !0 }, aspectRatio: 1, datasets: { indexAxis: 'r' }, scales: { r: { type: 'radialLinear', angleLines: { display: !1 }, beginAtZero: !0, gridLines: { circular: !0 }, pointLabels: { display: !1 } } }, startAngle: 0, legend: { labels: { generateLabels (t) { const e = t.data; return e.labels.length && e.datasets.length ? e.labels.map(function (e, n) { const i = t.getDatasetMeta(0).controller.getStyle(n); return { text: e, fillStyle: i.backgroundColor, strokeStyle: i.borderColor, lineWidth: i.borderWidth, hidden: !t.getDataVisibility(n), index: n } }) : [] } }, onClick (t, e, n) { n.chart.toggleDataVisibility(e.index), n.chart.update() } }, tooltips: { callbacks: { title () { return '' }, label (t) { return t.chart.data.labels[t.dataIndex] + ': ' + t.formattedValue } } } }; const Ki = (function (t) { function e () { return t.apply(this, arguments) || this } return i(e, t), e }(Ui)); Ki.id = 'pie', Ki.defaults = { cutoutPercentage: 0 }; const qi = (function (t) { function e () { return t.apply(this, arguments) || this }i(e, t); const n = e.prototype; return n.getLabelAndValue = function (t) { const e = this._cachedMeta.vScale; const n = this.getParsed(t); return { label: e.getLabels()[t], value: '' + e.getLabelForValue(n[e.axis]) } }, n.update = function (t) { const e = this; const n = e._cachedMeta; const i = n.dataset; const r = n.data || []; const a = n.iScale.getLabels(); if (t !== 'resize') { const o = { points: r, _loop: !0, _fullLoop: a.length === r.length, options: e.resolveDatasetElementOptions() }; e.updateElement(i, void 0, o, t) }e.updateElements(r, 0, r.length, t) }, n.updateElements = function (t, e, n, i) { for (let r = this, a = r.getDataset(), o = r._cachedMeta.rScale, s = i === 'reset', l = e; l < e + n; l++) { const c = t[l]; const u = r.resolveDataElementOptions(l, i); const h = o.getPointPositionForValue(l, a.data[l]); const f = s ? o.xCenter : h.x; const d = s ? o.yCenter : h.y; const p = { x: f, y: d, angle: h.angle, skip: isNaN(f) || isNaN(d), options: u }; r.updateElement(c, l, p, i) } }, n.resolveDatasetElementOptions = function (e) { const n = this._config; const i = this.chart.options; const r = t.prototype.resolveDatasetElementOptions.call(this, e); const a = g(n.showLine, i.showLine); return r.spanGaps = g(n.spanGaps, i.spanGaps), r.tension = g(n.tension, i.elements.line.tension), a || (r.borderWidth = 0), r }, e }(Un)); qi.id = 'radar', qi.defaults = { datasetElementType: 'line', datasetElementOptions: ['backgroundColor', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'borderWidth', 'fill'], dataElementType: 'point', dataElementOptions: { backgroundColor: 'pointBackgroundColor', borderColor: 'pointBorderColor', borderWidth: 'pointBorderWidth', hitRadius: 'pointHitRadius', hoverBackgroundColor: 'pointHoverBackgroundColor', hoverBorderColor: 'pointHoverBorderColor', hoverBorderWidth: 'pointHoverBorderWidth', hoverRadius: 'pointHoverRadius', pointStyle: 'pointStyle', radius: 'pointRadius', rotation: 'pointRotation' }, aspectRatio: 1, spanGaps: !1, scales: { r: { type: 'radialLinear' } }, datasets: { indexAxis: 'r' }, elements: { line: { fill: 'start', tension: 0 } } }; const Gi = (function (t) { function e () { return t.apply(this, arguments) || this } return i(e, t), e }(Xi)); Gi.id = 'scatter', Gi.defaults = { scales: { x: { type: 'linear' }, y: { type: 'linear' } }, datasets: { showLine: !1, fill: !1 }, tooltips: { callbacks: { title () { return '' }, label (t) { return '(' + t.label + ', ' + t.formattedValue + ')' } } } }; const Zi = Object.freeze({ __proto__: null, BarController: ji, BubbleController: Yi, DoughnutController: Ui, LineController: Xi, PolarAreaController: $i, PieController: Ki, RadarController: qi, ScatterController: Gi }); function Qi (t, e) { const n = e.startAngle; const i = e.endAngle; const r = e.pixelMargin; const a = e.x; const o = e.y; const s = e.outerRadius; const l = e.innerRadius; let c = r / s; t.beginPath(), t.arc(a, o, s, n - c, i + c), l > r ? (c = r / l, t.arc(a, o, l, i + c, n - c, !0)) : t.arc(a, o, r, i + R, n - R), t.closePath(), t.clip() } function Ji (t, e) { const n = e.x; const i = e.y; const r = e.startAngle; const a = e.endAngle; const o = e.pixelMargin; const s = Math.max(e.outerRadius - o, 0); const l = e.innerRadius + o; t.beginPath(), t.arc(n, i, s, r, a), t.arc(n, i, l, a, r, !0), t.closePath() } function tr (t, e) { const n = e.x; const i = e.y; const r = e.startAngle; const a = e.endAngle; const o = e.pixelMargin; const s = e.options; const l = e.outerRadius; const c = e.innerRadius + o; const u = s.borderAlign === 'inner'; s.borderWidth && (u ? (t.lineWidth = 2 * s.borderWidth, t.lineJoin = 'round') : (t.lineWidth = s.borderWidth, t.lineJoin = 'bevel'), e.fullCircles && (function (t, e, n) { let i; const r = e.x; const a = e.y; const o = e.startAngle; const s = e.endAngle; const l = e.pixelMargin; const c = Math.max(e.outerRadius - l, 0); const u = e.innerRadius + l; for (n && (e.endAngle = e.startAngle + O, Qi(t, e), e.endAngle = s, e.endAngle === e.startAngle && (e.endAngle += O, e.fullCircles--)), t.beginPath(), t.arc(r, a, u, o + O, o, !0), i = 0; i < e.fullCircles; ++i) { t.stroke() } for (t.beginPath(), t.arc(r, a, c, o, o + O), i = 0; i < e.fullCircles; ++i) { t.stroke() } }(t, e, u)), u && Qi(t, e), t.beginPath(), t.arc(n, i, l, r, a), t.arc(n, i, c, a, r, !0), t.closePath(), t.stroke()) } const er = (function (t) { function e (e) { let i; return (i = t.call(this) || this).options = void 0, i.circumference = void 0, i.startAngle = void 0, i.endAngle = void 0, i.innerRadius = void 0, i.outerRadius = void 0, i.pixelMargin = 0, i.fullCircles = 0, e && n(r(i), e), i }i(e, t); const a = e.prototype; return a.inRange = function (t, e, n) { const i = $(this.getProps(['x', 'y'], n), { x: t, y: e }); const r = i.angle; const a = i.distance; const o = this.getProps(['startAngle', 'endAngle', 'innerRadius', 'outerRadius', 'circumference'], n); const s = o.startAngle; const l = o.endAngle; const c = o.innerRadius; const u = o.outerRadius; return (o.circumference >= O || Z(r, s, l)) && (a >= c && a <= u) }, a.getCenterPoint = function (t) { const e = this.getProps(['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius'], t); const n = e.x; const i = e.y; const r = (e.startAngle + e.endAngle) / 2; const a = (e.innerRadius + e.outerRadius) / 2; return { x: n + Math.cos(r) * a, y: i + Math.sin(r) * a } }, a.tooltipPosition = function (t) { return this.getCenterPoint(t) }, a.draw = function (t) { const e = this; const n = e.options; const i = n.offset || 0; if (e.pixelMargin = n.borderAlign === 'inner' ? 0.33 : 0, e.fullCircles = Math.floor(e.circumference / O), e.circumference !== 0) { if (t.save(), i && e.circumference < O) { const r = (e.startAngle + e.endAngle) / 2; t.translate(Math.cos(r) * i, Math.sin(r) * i) }t.fillStyle = n.backgroundColor, t.strokeStyle = n.borderColor, (function (t, e) { if (e.fullCircles) { e.endAngle = e.startAngle + O, Ji(t, e); for (let n = 0; n < e.fullCircles; ++n) { t.fill() }e.endAngle = e.startAngle + e.circumference % O }Ji(t, e), t.fill() }(t, e)), tr(t, e), t.restore() } }, e }(Xn)); function nr (t, e, n) { t.lineTo(n.x, n.y) } function ir (t, e, n) { n = n || {}; const i = t.length; const r = Math.max(n.start || 0, e.start); const a = Math.min(n.end || i - 1, e.end); return { count: i, start: r, loop: e.loop, ilen: a < r ? i + a - r : a - r } } function rr (t, e, n, i) { let r; let a; let o; const s = e.points; const l = e.options; const c = ir(s, n, i); const u = c.count; const h = c.start; const f = c.loop; const d = c.ilen; const p = (function (t) { return t.stepped ? ct : t.tension ? ut : nr }(l)); const g = i || {}; const v = g.move; let m = void 0 === v || v; const b = g.reverse; for (r = 0; r <= d; ++r) { (a = s[(h + (b ? d - r : r)) % u]).skip || (m ? (t.moveTo(a.x, a.y), m = !1) : p(t, o, a, b, l.stepped), o = a) } return f && p(t, o, a = s[(h + (b ? d : 0)) % u], b, l.stepped), !!f } function ar (t, e, n, i) { let r; let a; let o; let s; let l; let c; const u = e.points; const h = ir(u, n, i); const f = h.count; const d = h.start; const p = h.ilen; const g = i || {}; const v = g.move; const m = void 0 === v || v; const b = g.reverse; let x = 0; let y = 0; const _ = function (t) { return (d + (b ? p - t : t)) % f }; const w = function () { s !== l && (t.lineTo(x, l), t.lineTo(x, s), t.lineTo(x, c)) }; for (m && (a = u[_(0)], t.moveTo(a.x, a.y)), r = 0; r <= p; ++r) { if (!(a = u[_(r)]).skip) { const M = a.x; const k = a.y; const S = 0 | M; S === o ? (k < s ? s = k : k > l && (l = k), x = (y * x + M) / ++y) : (w(), t.lineTo(M, k), o = S, y = 0, s = l = k), c = k } }w() } function or (t) { const e = t.options; const n = e.borderDash && e.borderDash.length; return !(t._loop || e.tension || e.stepped || n) ? ar : rr }er.id = 'arc', er.defaults = { borderAlign: 'center', borderColor: '#fff', borderWidth: 2, offset: 0 }, er.defaultRoutes = { backgroundColor: 'color' }; const sr = (function (t) { function a (e) { let i; return (i = t.call(this) || this).options = void 0, i._loop = void 0, i._fullLoop = void 0, i._points = void 0, i._segments = void 0, i._pointsUpdated = !1, e && n(r(i), e), i }i(a, t); const o = a.prototype; return o.updateControlPoints = function (t) { const e = this; const n = e.options; if (n.tension && !n.stepped && !e._pointsUpdated) { const i = n.spanGaps ? e._loop : e._fullLoop; Mi(e._points, n, t, i), e._pointsUpdated = !0 } }, o.first = function () { const t = this.segments; const e = this.points; return t.length && e[t[0].start] }, o.last = function () { const t = this.segments; const e = this.points; const n = t.length; return n && e[t[n - 1].end] }, o.interpolate = function (t, e) { const n = this; const i = n.options; const r = t[e]; const a = n.points; const o = Ci(n, { property: e, start: r, end: r }); if (o.length) { let s; let l; const c = []; const u = (function (t) { return t.stepped ? Si : t.tension ? Pi : ki }(i)); for (s = 0, l = o.length; s < l; ++s) { const h = o[s]; const f = h.start; const d = h.end; const p = a[f]; const g = a[d]; if (p !== g) { const v = u(p, g, Math.abs((r - p[e]) / (g[e] - p[e])), i.stepped); v[e] = t[e], c.push(v) } else { c.push(p) } } return c.length === 1 ? c[0] : c } }, o.pathSegment = function (t, e, n) { return or(this)(t, this, e, n) }, o.path = function (t, e, n) { const i = this; const r = i.segments; const a = r.length; const o = or(i); let s = i._loop; e = e || 0, n = n || i.points.length - e; for (let l = 0; l < a; ++l) { s &= o(t, i, r[l], { start: e, end: e + n - 1 }) } return !!s }, o.draw = function (t, e, n, i) { const r = this.options || {}; (this.points || []).length && r.borderWidth && (t.save(), (function (t, e) { t.lineCap = e.borderCapStyle, t.setLineDash(e.borderDash), t.lineDashOffset = e.borderDashOffset, t.lineJoin = e.borderJoinStyle, t.lineWidth = e.borderWidth, t.strokeStyle = e.borderColor }(t, r)), t.beginPath(), this.path(t, n, i) && t.closePath(), t.stroke(), t.restore(), this._pointsUpdated = !1) }, e(a, [{ key: 'points', set (t) { this._points = t, delete this._segments }, get () { return this._points } }, { key: 'segments', get () { return this._segments || (this._segments = Ri(this)) } }]), a }(Xn)); sr.id = 'line', sr.defaults = { borderCapStyle: 'butt', borderDash: [], borderDashOffset: 0, borderJoinStyle: 'miter', borderWidth: 3, capBezierPoints: !0, fill: !0, tension: 0 }, sr.defaultRoutes = { backgroundColor: 'color', borderColor: 'color' }; const lr = (function (t) { function e (e) { let i; return (i = t.call(this) || this).options = void 0, i.skip = void 0, i.stop = void 0, e && n(r(i), e), i }i(e, t); const a = e.prototype; return a.inRange = function (t, e, n) { const i = this.options; const r = this.getProps(['x', 'y'], n); const a = r.x; const o = r.y; return Math.pow(t - a, 2) + Math.pow(e - o, 2) < Math.pow(i.hitRadius + i.radius, 2) }, a.inXRange = function (t, e) { const n = this.options; const i = this.getProps(['x'], e).x; return Math.abs(t - i) < n.radius + n.hitRadius }, a.inYRange = function (t, e) { const n = this.options; const i = this.getProps(['x'], e).y; return Math.abs(t - i) < n.radius + n.hitRadius }, a.getCenterPoint = function (t) { const e = this.getProps(['x', 'y'], t); return { x: e.x, y: e.y } }, a.size = function () { const t = this.options || {}; const e = Math.max(t.radius, t.hoverRadius) || 0; return 2 * (e + (e && t.borderWidth || 0)) }, a.draw = function (t) { const e = this; const n = e.options; e.skip || n.radius <= 0 || (t.strokeStyle = n.borderColor, t.lineWidth = n.borderWidth, t.fillStyle = n.backgroundColor, at(t, n, e.x, e.y)) }, a.getRange = function () { const t = this.options || {}; return t.radius + t.hitRadius }, e }(Xn)); function cr (t, e) { let n; let i; let r; let a; let o; const s = t.getProps(['x', 'y', 'base', 'width', 'height'], e); const l = s.x; const c = s.y; const u = s.base; const h = s.width; const f = s.height; return t.horizontal ? (o = f / 2, n = Math.min(l, u), i = Math.max(l, u), r = c - o, a = c + o) : (n = l - (o = h / 2), i = l + o, r = Math.min(c, u), a = Math.max(c, u)), { left: n, top: r, right: i, bottom: a } } function ur (t) { let e = t.options.borderSkipped; const n = {}; return e ? (n[e = t.horizontal ? hr(e, 'left', 'right', t.base > t.x) : hr(e, 'bottom', 'top', t.base < t.y)] = !0, n) : n } function hr (t, e, n, i) { let r, a, o; return i ? (o = n, t = fr(t = (r = t) === (a = e) ? o : r === o ? a : r, n, e)) : t = fr(t, e, n), t } function fr (t, e, n) { return t === 'start' ? e : t === 'end' ? n : t } function dr (t, e, n, i) { return t ? 0 : Math.max(Math.min(e, i), n) } function pr (t) { const e = cr(t); const n = e.right - e.left; const i = e.bottom - e.top; const r = (function (t, e, n) { const i = t.options.borderWidth; const r = ur(t); const a = Vt(i); return { t: dr(r.top, a.top, 0, n), r: dr(r.right, a.right, 0, e), b: dr(r.bottom, a.bottom, 0, n), l: dr(r.left, a.left, 0, e) } }(t, n / 2, i / 2)); const a = (function (t, e, n) { const i = Wt(t.options.borderRadius); const r = Math.min(e, n); const a = ur(t); return { topLeft: dr(a.top || a.left, i.topLeft, 0, r), topRight: dr(a.top || a.right, i.topRight, 0, r), bottomLeft: dr(a.bottom || a.left, i.bottomLeft, 0, r), bottomRight: dr(a.bottom || a.right, i.bottomRight, 0, r) } }(t, n / 2, i / 2)); return { outer: { x: e.left, y: e.top, w: n, h: i, radius: a }, inner: { x: e.left + r.l, y: e.top + r.t, w: n - r.l - r.r, h: i - r.t - r.b, radius: { topLeft: Math.max(0, a.topLeft - Math.max(r.t, r.l)), topRight: Math.max(0, a.topRight - Math.max(r.t, r.r)), bottomLeft: Math.max(0, a.bottomLeft - Math.max(r.b, r.l)), bottomRight: Math.max(0, a.bottomRight - Math.max(r.b, r.r)) } } } } function gr (t, e, n, i) { const r = e === null; const a = n === null; const o = t && !(r && a) && cr(t, i); return o && (r || e >= o.left && e <= o.right) && (a || n >= o.top && n <= o.bottom) } function vr (t, e) { const n = e.x; const i = e.y; const r = e.w; const a = e.h; const o = e.radius; t.arc(n + o.topLeft, i + o.topLeft, o.topLeft, -R, T, !0), t.lineTo(n, i + a - o.bottomLeft), t.arc(n + o.bottomLeft, i + a - o.bottomLeft, o.bottomLeft, T, R, !0), t.lineTo(n + r - o.bottomRight, i + a), t.arc(n + r - o.bottomRight, i + a - o.bottomRight, o.bottomRight, R, 0, !0), t.lineTo(n + r, i + o.topRight), t.arc(n + r - o.topRight, i + o.topRight, o.topRight, 0, -R, !0), t.lineTo(n + o.topLeft, i) } function mr (t, e) { t.rect(e.x, e.y, e.w, e.h) }lr.id = 'point', lr.defaults = { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: 'circle', radius: 3 }, lr.defaultRoutes = { backgroundColor: 'color', borderColor: 'color' }; const br = (function (t) { function e (e) { let i; return (i = t.call(this) || this).options = void 0, i.horizontal = void 0, i.base = void 0, i.width = void 0, i.height = void 0, e && n(r(i), e), i }i(e, t); const a = e.prototype; return a.draw = function (t) { let e; const n = this.options; const i = pr(this); const r = i.inner; const a = i.outer; const o = (e = a.radius).topLeft || e.topRight || e.bottomLeft || e.bottomRight ? vr : mr; t.save(), a.w === r.w && a.h === r.h || (t.beginPath(), o(t, a), t.clip(), o(t, r), t.fillStyle = n.borderColor, t.fill('evenodd')), t.beginPath(), o(t, r), t.fillStyle = n.backgroundColor, t.fill(), t.restore() }, a.inRange = function (t, e, n) { return gr(this, t, e, n) }, a.inXRange = function (t, e) { return gr(this, t, null, e) }, a.inYRange = function (t, e) { return gr(this, null, t, e) }, a.getCenterPoint = function (t) { const e = this.getProps(['x', 'y', 'base', 'horizontal'], t); const n = e.x; const i = e.y; const r = e.base; const a = e.horizontal; return { x: a ? (n + r) / 2 : n, y: a ? i : (i + r) / 2 } }, a.getRange = function (t) { return t === 'x' ? this.width / 2 : this.height / 2 }, e }(Xn)); br.id = 'bar', br.defaults = { borderSkipped: 'start', borderWidth: 0, borderRadius: 0 }, br.defaultRoutes = { backgroundColor: 'color', borderColor: 'color' }; const xr = Object.freeze({ __proto__: null, ArcElement: er, LineElement: sr, PointElement: lr, BarElement: br }); function yr (t, e, n) { const i = (function (t) { const e = t.options; const n = e.fill; let i = g(n && n.target, n); return void 0 === i && (i = !!e.backgroundColor), !1 !== i && i !== null && (!0 === i ? 'origin' : i) }(t)); if (d(i)) { return !isNaN(i.value) && i } let r = parseFloat(i); return p(r) && Math.floor(r) === r ? (i[0] !== '-' && i[0] !== '+' || (r = e + r), !(r === e || r < 0 || r >= n) && r) : ['origin', 'start', 'end', 'stack'].includes(i) && i } const _r = (function () { function t (t) { this.x = t.x, this.y = t.y, this.radius = t.radius } const e = t.prototype; return e.pathSegment = function (t, e, n) { const i = this.x; const r = this.y; const a = this.radius; return e = e || { start: 0, end: O }, n.reverse ? t.arc(i, r, a, e.end, e.start, !0) : t.arc(i, r, a, e.start, e.end), !n.bounds }, e.interpolate = function (t, e) { const n = this.x; const i = this.y; const r = this.radius; const a = t.angle; if (e === 'angle') { return { x: n + Math.cos(a) * r, y: i + Math.sin(a) * r, angle: a } } }, t }()); function wr (t) { return (t.scale || {}).getPointPositionForValue ? (function (t) { let e; let n; let i; const r = t.scale; const a = t.fill; const o = r.options; const s = r.getLabels().length; const l = []; const c = o.reverse ? r.max : r.min; const u = o.reverse ? r.min : r.max; if (i = a === 'start' ? c : a === 'end' ? u : d(a) ? a.value : r.getBaseValue(), o.gridLines.circular) { return n = r.getPointPositionForValue(0, c), new _r({ x: n.x, y: n.y, radius: r.getDistanceFromCenterForValue(i) }) } for (e = 0; e < s; ++e) { l.push(r.getPointPositionForValue(e, i)) } return l }(t)) : (function (t) { let e; const n = t.scale; const i = void 0 === n ? {} : n; const r = t.fill; let a = null; return r === 'start' ? a = i.bottom : r === 'end' ? a = i.top : d(r) ? a = i.getPixelForValue(r.value) : i.getBasePixel && (a = i.getBasePixel()), p(a) ? { x: (e = i.isHorizontal()) ? a : null, y: e ? null : a } : null }(t)) } function Mr (t) { const e = t.chart; const n = t.scale; const i = t.index; const r = t.line; const a = []; const o = r.segments; const s = r.points; const l = (function (t, e) { for (var n = [], i = t.getSortedVisibleDatasetMetas(), r = 0; r < i.length; r++) { const a = i[r]; if (a.index === e) { break } kr(a) && n.unshift(a.dataset) } return n }(e, i)); l.push(Dr({ x: null, y: n.bottom }, r)); for (let c = 0; c < o.length; c++) { for (let u = o[c], h = u.start; h <= u.end; h++) { Sr(a, s[h], l) } } return new sr({ points: a, options: {} }) } var kr = function (t) { return t.type === 'line' && !t.hidden }; function Sr (t, e, n) { for (var i = [], r = 0; r < n.length; r++) { const a = Pr(n[r], e, 'x'); const o = a.first; const s = a.last; const l = a.point; if (!(!l || o && s)) { if (o) { i.unshift(l) } else if (t.push(l), !s) { break } } }t.push.apply(t, i) } function Pr (t, e, n) { const i = t.interpolate(e, n); if (!i) { return {} } for (var r = i[n], a = t.segments, o = t.points, s = !1, l = !1, c = 0; c < a.length; c++) { const u = a[c]; const h = o[u.start][n]; const f = o[u.end][n]; if (r >= h && r <= f) { s = r === h, l = r === f; break } } return { first: s, last: l, point: i } } function Dr (t, e) { let n = []; let i = !1; return f(t) ? (i = !0, n = t) : n = (function (t, e) { const n = t || {}; const i = n.x; const r = void 0 === i ? null : i; const a = n.y; const o = void 0 === a ? null : a; const s = e.points; const l = []; return e.segments.forEach(function (t) { const e = s[t.start]; const n = s[t.end]; o !== null ? (l.push({ x: e.x, y: o }), l.push({ x: n.x, y: o })) : r !== null && (l.push({ x: r, y: e.y }), l.push({ x: r, y: n.y })) }), l }(t, e)), n.length ? new sr({ points: n, options: { tension: 0 }, _loop: i, _fullLoop: i }) : null } function Ar (t, e, n) { let i; let r = t[e].fill; const a = [e]; if (!n) { return r } for (;!1 !== r && !a.includes(r);) { if (!p(r)) { return r } if (!(i = t[r])) { return !1 } if (i.visible) { return r } a.push(r), r = i.fill } return !1 } function Tr (t, e, n) { t.beginPath(), e.path(t), t.lineTo(e.last().x, n), t.lineTo(e.first().x, n), t.closePath(), t.clip() } function Or (t, e, n, i) { if (!i) { let r = e[t]; let a = n[t]; return t === 'angle' && (r = G(r), a = G(a)), { property: t, start: r, end: a } } } function Er (t, e, n, i) { return t && e ? i(t[n], e[n]) : t ? t[n] : e ? e[n] : 0 } function Lr (t, e, n) { const i = e.chart.chartArea; const r = i.top; const a = i.bottom; const o = n || {}; const s = o.property; const l = o.start; const c = o.end; s === 'x' && (t.beginPath(), t.rect(l, r, c - l, a - r), t.clip()) } function Cr (t, e, n, i) { const r = e.interpolate(n, i); r && t.lineTo(r.x, r.y) } function Rr (t, e) { const n = e.line; const i = e.target; const r = e.property; const a = e.color; const o = e.scale; const s = (function (t, e, n) { for (var i = t.segments, r = t.points, a = e.points, o = [], s = 0; s < i.length; s++) { const l = i[s]; const c = Or(n, r[l.start], r[l.end], l.loop); if (e.segments) { for (let u = Ci(e, c), h = 0; h < u.length; ++h) { for (let f = u[h], d = Or(n, a[f.start], a[f.end], f.loop), p = Li(l, r, d), g = 0; g < p.length; g++) { var v, m; o.push({ source: p[g], target: f, start: (v = {}, v[n] = Er(c, d, 'start', Math.max), v), end: (m = {}, m[n] = Er(c, d, 'end', Math.min), m) }) } } } else { o.push({ source: l, target: c, start: r[l.start], end: r[l.end] }) } } return o }(n, i, r)); t.fillStyle = a; for (let l = 0, c = s.length; l < c; ++l) { const u = s[l]; const h = u.source; const f = u.target; const d = u.start; const p = u.end; t.save(), Lr(t, o, Or(r, d, p)), t.beginPath(); const g = !!n.pathSegment(t, h); g ? t.closePath() : Cr(t, i, p, r); const v = !!i.pathSegment(t, f, { move: g, reverse: !0 }); const m = g && v; m || Cr(t, i, d, r), t.closePath(), t.fill(m ? 'evenodd' : 'nonzero'), t.restore() } } const Fr = { id: 'filler', afterDatasetsUpdate (t, e, n) { let i; let r; let a; let o; const s = (t.data.datasets || []).length; const l = n.propagate; const c = []; for (r = 0; r < s; ++r) { o = null, (a = (i = t.getDatasetMeta(r)).dataset) && a.options && a instanceof sr && (o = { visible: t.isDatasetVisible(r), index: r, fill: yr(a, r, s), chart: t, scale: i.vScale, line: a }), i.$filler = o, c.push(o) } for (r = 0; r < s; ++r) { (o = c[r]) && !1 !== o.fill && (o.fill = Ar(c, r, l)) } }, beforeDatasetsDraw (t) { let e; let n; const i = t.getSortedVisibleDatasetMetas(); const r = t.chartArea; for (e = i.length - 1; e >= 0; --e) { (n = i[e].$filler) && n.line.updateControlPoints(r) } }, beforeDatasetDraw (t, e) { const n = t.chartArea; const i = t.ctx; const r = e.meta.$filler; if (r && !1 !== r.fill) { const a = (function (t) { const e = t.chart; const n = t.fill; const i = t.line; if (p(n)) { return (function (t, e) { const n = t.getDatasetMeta(e); return n && t.isDatasetVisible(e) ? n.dataset : null }(e, n)) } if (n === 'stack') { return Mr(t) } const r = wr(t); return r instanceof _r ? r : Dr(r, i) }(r)); const o = r.line; const s = r.scale; const l = o.options; const c = l.fill; const u = l.backgroundColor; const h = c || {}; const f = h.above; const d = void 0 === f ? u : f; const g = h.below; const v = void 0 === g ? u : g; a && o.points.length && (st(i, n), (function (t, e) { const n = e.line; const i = e.target; const r = e.above; const a = e.below; const o = e.area; const s = e.scale; const l = n._loop ? 'angle' : 'x'; t.save(), l === 'x' && a !== r && (Tr(t, i, o.top), Rr(t, { line: n, target: i, color: r, scale: s, property: l }), t.restore(), t.save(), Tr(t, i, o.bottom)), Rr(t, { line: n, target: i, color: a, scale: s, property: l }), t.restore() }(i, { line: o, target: a, above: d, below: v, area: n, scale: s })), lt(i)) } }, defaults: { propagate: !0 } }; function zr (t, e) { const n = t.boxWidth; return t.usePointStyle && n > e || h(n) ? e : n } function Ir (t, e) { const n = t.boxHeight; return t.usePointStyle && n > e || h(n) ? e : n } const Br = (function (t) { function e (e) { let i; return n(r(i = t.call(this) || this), e), i.legendHitBoxes = [], i._hoveredItem = null, i.doughnutMode = !1, i.chart = e.chart, i.options = e.options, i.ctx = e.ctx, i.legendItems = void 0, i.columnWidths = void 0, i.columnHeights = void 0, i.lineWidths = void 0, i._minSize = void 0, i.maxHeight = void 0, i.maxWidth = void 0, i.top = void 0, i.bottom = void 0, i.left = void 0, i.right = void 0, i.height = void 0, i.width = void 0, i._margins = void 0, i.paddingTop = void 0, i.paddingBottom = void 0, i.paddingLeft = void 0, i.paddingRight = void 0, i.position = void 0, i.weight = void 0, i.fullWidth = void 0, i }i(e, t); const a = e.prototype; return a.beforeUpdate = function () {}, a.update = function (t, e, n) { const i = this; i.beforeUpdate(), i.maxWidth = t, i.maxHeight = e, i._margins = n, i.beforeSetDimensions(), i.setDimensions(), i.afterSetDimensions(), i.beforeBuildLabels(), i.buildLabels(), i.afterBuildLabels(), i.beforeFit(), i.fit(), i.afterFit(), i.afterUpdate() }, a.afterUpdate = function () {}, a.beforeSetDimensions = function () {}, a.setDimensions = function () { const t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t._minSize = { width: 0, height: 0 } }, a.afterSetDimensions = function () {}, a.beforeBuildLabels = function () {}, a.buildLabels = function () { const t = this; const e = t.options.labels || {}; let n = v(e.generateLabels, [t.chart], t) || []; e.filter && (n = n.filter(function (n) { return e.filter(n, t.chart.data) })), e.sort && (n = n.sort(function (n, i) { return e.sort(n, i, t.chart.data) })), t.options.reverse && n.reverse(), t.legendItems = n }, a.afterBuildLabels = function () {}, a.beforeFit = function () {}, a.fit = function () { const t = this; const e = t.options; const n = e.labels; const i = e.display; const r = t.ctx; const a = Ht(n.font, t.chart.options.font); const o = a.size; const s = zr(n, o); const l = Ir(n, o); const c = Math.max(l, o); const u = t.legendHitBoxes = []; const h = t._minSize; const f = t.isHorizontal(); const d = t._computeTitleHeight(); if (f ? (h.width = t.maxWidth, h.height = i ? 10 : 0) : (h.width = i ? 10 : 0, h.height = t.maxHeight), i) { if (r.font = a.string, f) { const p = t.lineWidths = [0]; let g = d; r.textAlign = 'left', r.textBaseline = 'middle', t.legendItems.forEach(function (t, e) { const i = s + o / 2 + r.measureText(t.text).width; (e === 0 || p[p.length - 1] + i + 2 * n.padding > h.width) && (g += c + n.padding, p[p.length - (e > 0 ? 0 : 1)] = 0), u[e] = { left: 0, top: 0, width: i, height: c }, p[p.length - 1] += i + n.padding }), h.height += g } else { const v = n.padding; const m = t.columnWidths = []; const b = t.columnHeights = []; let x = n.padding; let y = 0; let _ = 0; const w = h.height - d; t.legendItems.forEach(function (t, e) { const i = s + o / 2 + r.measureText(t.text).width; e > 0 && _ + o + 2 * v > w && (x += y + n.padding, m.push(y), b.push(_), y = 0, _ = 0), y = Math.max(y, i), _ += o + v, u[e] = { left: 0, top: 0, width: i, height: c } }), x += y, m.push(y), b.push(_), h.width += x }t.width = Math.min(h.width, e.maxWidth || L), t.height = Math.min(h.height, e.maxHeight || L) } else { t.width = h.width = t.height = h.height = 0 } }, a.afterFit = function () {}, a.isHorizontal = function () { return this.options.position === 'top' || this.options.position === 'bottom' }, a.draw = function () { const t = this; const e = t.options; const n = e.labels; const i = A.color; const r = t.height; const a = t.columnHeights; const o = t.width; const s = t.lineWidths; if (e.display) { t.drawTitle(); let l; const c = Di(e.rtl, t.left, t._minSize.width); const u = t.ctx; const h = Ht(n.font, t.chart.options.font); const f = h.color; const d = h.size; u.textAlign = c.textAlign('left'), u.textBaseline = 'middle', u.lineWidth = 0.5, u.strokeStyle = f, u.fillStyle = f, u.font = h.string; const p = zr(n, d); const v = Ir(n, d); const m = Math.max(d, v); const b = t.legendHitBoxes; const x = function (t, i) { switch (e.align) { case 'start':return n.padding; case 'end':return t - i; default:return (t - i + n.padding) / 2 } }; const y = t.isHorizontal(); const _ = this._computeTitleHeight(); l = y ? { x: t.left + x(o, s[0]), y: t.top + n.padding + _, line: 0 } : { x: t.left + n.padding, y: t.top + x(r, a[0]) + _, line: 0 }, Ai(t.ctx, e.textDirection); const w = m + n.padding; t.legendItems.forEach(function (e, h) { const f = u.measureText(e.text).width; const _ = p + d / 2 + f; let M = l.x; let k = l.y; c.setWidth(t._minSize.width), y ? h > 0 && M + _ + n.padding > t.left + t._minSize.width && (k = l.y += w, l.line++, M = l.x = t.left + x(o, s[l.line])) : h > 0 && k + w > t.top + t._minSize.height && (M = l.x = M + t.columnWidths[l.line] + n.padding, l.line++, k = l.y = t.top + x(r, a[l.line])); const S = c.x(M); !(function (t, e, r) { if (!(isNaN(p) || p <= 0 || isNaN(v) || v < 0)) { u.save(); const a = g(r.lineWidth, 1); if (u.fillStyle = g(r.fillStyle, i), u.lineCap = g(r.lineCap, 'butt'), u.lineDashOffset = g(r.lineDashOffset, 0), u.lineJoin = g(r.lineJoin, 'miter'), u.lineWidth = a, u.strokeStyle = g(r.strokeStyle, i), u.setLineDash && u.setLineDash(g(r.lineDash, [])), n && n.usePointStyle) { const o = { radius: p * Math.SQRT2 / 2, pointStyle: r.pointStyle, rotation: r.rotation, borderWidth: a }; const s = c.xPlus(t, p / 2); at(u, o, s, e + d / 2) } else { const l = e + Math.max((d - v) / 2, 0); u.fillRect(c.leftForLtr(t, p), l, p, v), a !== 0 && u.strokeRect(c.leftForLtr(t, p), l, p, v) }u.restore() } }(S, k, e)), b[h].left = c.leftForLtr(S, b[h].width), b[h].top = k, (function (t, e, n, i) { const r = d / 2; const a = c.xPlus(t, p + r); const o = e + m / 2; u.fillText(n.text, a, o), n.hidden && (u.beginPath(), u.lineWidth = 2, u.moveTo(a, o), u.lineTo(c.xPlus(a, i), o), u.stroke()) }(S, k, e, f)), y ? l.x += _ + n.padding : l.y += w }), Ti(t.ctx, e.textDirection) } }, a.drawTitle = function () { const t = this; const e = t.options; const n = e.title; const i = Ht(n.font, t.chart.options.font); const r = Nt(n.padding); if (n.display) { let a; let o; const s = Di(e.rtl, t.left, t._minSize.width); const l = t.ctx; const c = n.position; const u = i.size / 2; let h = t.top + r.top + u; let f = t.left; let d = t.width; if (this.isHorizontal()) { switch (d = Math.max.apply(Math, t.lineWidths), e.align) { case 'start':break; case 'end':f = t.right - d; break; default:f = (t.left + t.right) / 2 - d / 2 } } else { const p = Math.max.apply(Math, t.columnHeights); switch (e.align) { case 'start':break; case 'end':h += t.height - p; break; default:h += (t.height - p) / 2 } } switch (c) { case 'start':a = f, o = 'left'; break; case 'end':a = f + d, o = 'right'; break; default:a = f + d / 2, o = 'center' }l.textAlign = s.textAlign(o), l.textBaseline = 'middle', l.strokeStyle = i.color, l.fillStyle = i.color, l.font = i.string, l.fillText(n.text, a, h) } }, a._computeTitleHeight = function () { const t = this.options.title; const e = Ht(t.font, this.chart.options.font); const n = Nt(t.padding); return t.display ? e.lineHeight + n.height : 0 }, a._getLegendItemAt = function (t, e) { let n; let i; let r; const a = this; if (t >= a.left && t <= a.right && e >= a.top && e <= a.bottom) { for (r = a.legendHitBoxes, n = 0; n < r.length; ++n) { if (t >= (i = r[n]).left && t <= i.left + i.width && e >= i.top && e <= i.top + i.height) { return a.legendItems[n] } } } return null }, a.handleEvent = function (t) { const e = this; const n = e.options; const i = t.type === 'mouseup' ? 'click' : t.type; if (i === 'mousemove') { if (!n.onHover && !n.onLeave) { return } } else { if (i !== 'click') { return } if (!n.onClick) { return } } const r = e._getLegendItemAt(t.x, t.y); i === 'click' ? r && v(n.onClick, [t, r, e], e) : (n.onLeave && r !== e._hoveredItem && (e._hoveredItem && v(n.onLeave, [t, e._hoveredItem, e], e), e._hoveredItem = r), r && v(n.onHover, [t, r, e], e)) }, e }(Xn)); function Vr (t) { return !1 !== t && w(Object.create(null), [A.plugins.legend, t]) } function Wr (t, e) { const n = new Br({ ctx: t.ctx, options: e, chart: t }); Jt.configure(t, n, e), Jt.addBox(t, n), t.legend = n } const Nr = { id: 'legend', _element: Br, beforeInit (t) { const e = Vr(t.options.legend); e && Wr(t, e) }, beforeUpdate (t) { const e = Vr(t.options.legend); const n = t.legend; e ? n ? (Jt.configure(t, n, e), n.options = e) : Wr(t, e) : n && (Jt.removeBox(t, n), delete t.legend) }, afterUpdate (t) { t.legend && t.legend.buildLabels() }, afterEvent (t, e) { const n = t.legend; n && n.handleEvent(e) }, defaults: { display: !0, position: 'top', align: 'center', fullWidth: !0, reverse: !1, weight: 1e3, onClick (t, e, n) { const i = e.datasetIndex; const r = n.chart; r.isDatasetVisible(i) ? (r.hide(i), e.hidden = !0) : (r.show(i), e.hidden = !1) }, onHover: null, onLeave: null, labels: { boxWidth: 40, padding: 10, generateLabels (t) { const e = t.data.datasets; const n = t.legend.options.labels; const i = n.usePointStyle; const r = n.pointStyle; return t._getSortedDatasetMetas().map(function (t) { const n = t.controller.getStyle(i ? 0 : void 0); const a = d(n.borderWidth) ? (g(n.borderWidth.top, 0) + g(n.borderWidth.left, 0) + g(n.borderWidth.bottom, 0) + g(n.borderWidth.right, 0)) / 4 : n.borderWidth; return { text: e[t.index].label, fillStyle: n.backgroundColor, hidden: !t.visible, lineCap: n.borderCapStyle, lineDash: n.borderDash, lineDashOffset: n.borderDashOffset, lineJoin: n.borderJoinStyle, lineWidth: a, strokeStyle: n.borderColor, pointStyle: r || n.pointStyle, rotation: n.rotation, datasetIndex: t.index } }, this) } }, title: { display: !1, position: 'center', text: '' } } }; const Hr = (function (t) { function e (e) { let i; return n(r(i = t.call(this) || this), e), i.chart = e.chart, i.options = e.options, i.ctx = e.ctx, i._margins = void 0, i._padding = void 0, i.top = void 0, i.bottom = void 0, i.left = void 0, i.right = void 0, i.width = void 0, i.height = void 0, i.maxWidth = void 0, i.maxHeight = void 0, i.position = void 0, i.weight = void 0, i.fullWidth = void 0, i }i(e, t); const a = e.prototype; return a.beforeUpdate = function () {}, a.update = function (t, e, n) { const i = this; i.beforeUpdate(), i.maxWidth = t, i.maxHeight = e, i._margins = n, i.beforeSetDimensions(), i.setDimensions(), i.afterSetDimensions(), i.beforeBuildLabels(), i.buildLabels(), i.afterBuildLabels(), i.beforeFit(), i.fit(), i.afterFit(), i.afterUpdate() }, a.afterUpdate = function () {}, a.beforeSetDimensions = function () {}, a.setDimensions = function () { const t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height) }, a.afterSetDimensions = function () {}, a.beforeBuildLabels = function () {}, a.buildLabels = function () {}, a.afterBuildLabels = function () {}, a.beforeFit = function () {}, a.fit = function () { const t = this; const e = t.options; const n = {}; const i = t.isHorizontal(); if (e.display) { const r = f(e.text) ? e.text.length : 1; t._padding = Nt(e.padding); const a = r * Ht(e.font, t.chart.options.font).lineHeight + t._padding.height; t.width = n.width = i ? t.maxWidth : a, t.height = n.height = i ? a : t.maxHeight } else { t.width = n.width = t.height = n.height = 0 } }, a.afterFit = function () {}, a.isHorizontal = function () { const t = this.options.position; return t === 'top' || t === 'bottom' }, a.draw = function () { const t = this; const e = t.ctx; const n = t.options; if (n.display) { let i; let r; let a; let o; const s = Ht(n.font, t.chart.options.font); const l = s.lineHeight; const c = l / 2 + t._padding.top; let u = 0; const h = t.top; const d = t.left; const p = t.bottom; const g = t.right; if (t.isHorizontal()) { switch (n.align) { case 'start':r = d, o = 'left'; break; case 'end':r = g, o = 'right'; break; default:r = d + (g - d) / 2, o = 'center' }a = h + c, i = g - d } else { switch (r = n.position === 'left' ? d + c : g - c, n.align) { case 'start':a = n.position === 'left' ? p : h, o = 'left'; break; case 'end':a = n.position === 'left' ? h : p, o = 'right'; break; default:a = h + (p - h) / 2, o = 'center' }i = p - h, u = T * (n.position === 'left' ? -0.5 : 0.5) }e.save(), e.fillStyle = s.color, e.font = s.string, e.translate(r, a), e.rotate(u), e.textAlign = o, e.textBaseline = 'middle'; const v = n.text; if (f(v)) { for (let m = 0, b = 0; b < v.length; ++b) { e.fillText(v[b], 0, m, i), m += l } } else { e.fillText(v, 0, 0, i) }e.restore() } }, e }(Xn)); function jr (t, e) { const n = new Hr({ ctx: t.ctx, options: e, chart: t }); Jt.configure(t, n, e), Jt.addBox(t, n), t.titleBlock = n } const Yr = { id: 'title', _element: Hr, beforeInit (t) { const e = t.options.title; e && jr(t, e) }, beforeUpdate (t) { const e = t.options.title; const n = t.titleBlock; e ? (M(e, A.plugins.title), n ? (Jt.configure(t, n, e), n.options = e) : jr(t, e)) : n && (Jt.removeBox(t, n), delete t.titleBlock) }, defaults: { align: 'center', display: !1, font: { style: 'bold' }, fullWidth: !0, padding: 10, position: 'top', text: '', weight: 2e3 } }; const Ur = { average (t) { if (!t.length) { return !1 } let e; let n; let i = 0; let r = 0; let a = 0; for (e = 0, n = t.length; e < n; ++e) { const o = t[e].element; if (o && o.hasValue()) { const s = o.tooltipPosition(); i += s.x, r += s.y, ++a } } return { x: i / a, y: r / a } }, nearest (t, e) { let n; let i; let r; let a = e.x; let o = e.y; let s = Number.POSITIVE_INFINITY; for (n = 0, i = t.length; n < i; ++n) { const l = t[n].element; if (l && l.hasValue()) { const c = K(e, l.getCenterPoint()); c < s && (s = c, r = l) } } if (r) { const u = r.tooltipPosition(); a = u.x, o = u.y } return { x: a, y: o } } }; function Xr (t, e) { return e && (f(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t } function $r (t) { return (typeof t === 'string' || t instanceof String) && t.includes('\n') ? t.split('\n') : t } function Kr (t, e) { const n = e.element; const i = e.datasetIndex; const r = e.index; const a = t.getDatasetMeta(i).controller; const o = a.getLabelAndValue(r); const s = o.label; const l = o.value; return { chart: t, label: s, dataPoint: a.getParsed(r), formattedValue: l, dataset: a.getDataset(), dataIndex: r, datasetIndex: i, element: n } } function qr (t) { const e = t._chart.ctx; const n = t.body; const i = t.footer; const r = t.options; const a = t.title; const o = r.bodyFont; const s = r.footerFont; const l = r.titleFont; const c = r.boxWidth; const u = r.boxHeight; const h = a.length; const f = i.length; const d = n.length; let p = 2 * r.yPadding; let g = 0; let v = n.reduce(function (t, e) { return t + e.before.length + e.lines.length + e.after.length }, 0); (v += t.beforeBody.length + t.afterBody.length, h && (p += h * l.size + (h - 1) * r.titleSpacing + r.titleMarginBottom), v) && (p += d * (r.displayColors ? Math.max(u, o.size) : o.size) + (v - d) * o.size + (v - 1) * r.bodySpacing); f && (p += r.footerMarginTop + f * s.size + (f - 1) * r.footerSpacing); let b = 0; const x = function (t) { g = Math.max(g, e.measureText(t).width + b) }; return e.save(), e.font = l.string, m(t.title, x), e.font = o.string, m(t.beforeBody.concat(t.afterBody), x), b = r.displayColors ? c + 2 : 0, m(n, function (t) { m(t.before, x), m(t.lines, x), m(t.after, x) }), b = 0, e.font = s.string, m(t.footer, x), e.restore(), { width: g += 2 * r.xPadding, height: p } } function Gr (t, e, n) { let i; let r; const a = n.x; const o = n.y; const s = n.width; const l = n.height; const c = t.chartArea; let u = 'center'; let h = 'center'; o < l / 2 ? h = 'top' : o > t.height - l / 2 && (h = 'bottom'); const f = (c.left + c.right) / 2; const d = (c.top + c.bottom) / 2; h === 'center' ? (i = function (t) { return t <= f }, r = function (t) { return t > f }) : (i = function (t) { return t <= s / 2 }, r = function (e) { return e >= t.width - s / 2 }); const p = function (t) { return t <= d ? 'top' : 'bottom' }; return i(a) ? (u = 'left', a + s + e.caretSize + e.caretPadding > t.width && (u = 'center', h = p(o))) : r(a) && (u = 'right', (function (t) { return t - s - e.caretSize - e.caretPadding < 0 }(a)) && (u = 'center', h = p(o))), { xAlign: e.xAlign ? e.xAlign : u, yAlign: e.yAlign ? e.yAlign : h } } function Zr (t, e, n, i) { const r = t.caretSize; const a = t.caretPadding; const o = t.cornerRadius; const s = n.xAlign; const l = n.yAlign; const c = r + a; const u = o + a; let h = (function (t, e, n) { let i = t.x; const r = t.width; return e === 'right' ? i -= r : e === 'center' && ((i -= r / 2) + r > n && (i = n - r), i < 0 && (i = 0)), i }(e, s, i.width)); return l === 'center' ? s === 'left' ? h += c : s === 'right' && (h -= c) : s === 'left' ? h -= u : s === 'right' && (h += u), { x: h, y: (function (t, e, n) { let i = t.y; const r = t.height; return e === 'top' ? i += n : i -= e === 'bottom' ? r + n : r / 2, i }(e, l, c)) } } function Qr (t, e) { const n = t.options; return e === 'center' ? t.x + t.width / 2 : e === 'right' ? t.x + t.width - n.xPadding : t.x + n.xPadding } function Jr (t) { return Xr([], $r(t)) } const ta = (function (t) { function e (e) { let n; return (n = t.call(this) || this).opacity = 0, n._active = [], n._chart = e._chart, n._eventPosition = void 0, n._size = void 0, n._cachedAnimations = void 0, n.$animations = void 0, n.options = void 0, n.dataPoints = void 0, n.title = void 0, n.beforeBody = void 0, n.body = void 0, n.afterBody = void 0, n.footer = void 0, n.xAlign = void 0, n.yAlign = void 0, n.x = void 0, n.y = void 0, n.height = void 0, n.width = void 0, n.caretX = void 0, n.caretY = void 0, n.labelColors = void 0, n.labelPointStyles = void 0, n.labelTextColors = void 0, n.initialize(), n }i(e, t); const r = e.prototype; return r.initialize = function () { let t; let e; const n = this; const i = n._chart.options; n.options = (t = i.tooltips, e = i.font, (t = w(Object.create(null), [A.plugins.tooltip, t])).bodyFont = Ht(t.bodyFont, e), t.titleFont = Ht(t.titleFont, e), t.footerFont = Ht(t.footerFont, e), t.boxHeight = g(t.boxHeight, t.bodyFont.size), t.boxWidth = g(t.boxWidth, t.bodyFont.size), t), n._cachedAnimations = void 0 }, r._resolveAnimations = function () { const t = this; const e = t._cachedAnimations; if (e) { return e } const n = t._chart; const i = t.options; const r = i.enabled && n.options.animation && i.animation; const a = new Fn(t._chart, r); return t._cachedAnimations = Object.freeze(a), a }, r.getTitle = function (t) { const e = this; const n = e.options.callbacks; const i = n.beforeTitle.apply(e, [t]); const r = n.title.apply(e, [t]); const a = n.afterTitle.apply(e, [t]); let o = []; return o = Xr(o, $r(i)), o = Xr(o, $r(r)), o = Xr(o, $r(a)) }, r.getBeforeBody = function (t) { return Jr(this.options.callbacks.beforeBody.apply(this, [t])) }, r.getBody = function (t) { const e = this; const n = e.options.callbacks; const i = []; return m(t, function (t) { const r = { before: [], lines: [], after: [] }; Xr(r.before, $r(n.beforeLabel.call(e, t))), Xr(r.lines, n.label.call(e, t)), Xr(r.after, $r(n.afterLabel.call(e, t))), i.push(r) }), i }, r.getAfterBody = function (t) { return Jr(this.options.callbacks.afterBody.apply(this, [t])) }, r.getFooter = function (t) { const e = this; const n = e.options.callbacks; const i = n.beforeFooter.apply(e, [t]); const r = n.footer.apply(e, [t]); const a = n.afterFooter.apply(e, [t]); let o = []; return o = Xr(o, $r(i)), o = Xr(o, $r(r)), o = Xr(o, $r(a)) }, r._createItems = function () { let t; let e; const n = this; const i = n._active; const r = n.options; const a = n._chart.data; const o = []; const s = []; const l = []; let c = []; for (t = 0, e = i.length; t < e; ++t) { c.push(Kr(n._chart, i[t])) } return r.filter && (c = c.filter(function (t, e, n) { return r.filter(t, e, n, a) })), r.itemSort && (c = c.sort(function (t, e) { return r.itemSort(t, e, a) })), m(c, function (t) { o.push(r.callbacks.labelColor.call(n, t)), s.push(r.callbacks.labelPointStyle.call(n, t)), l.push(r.callbacks.labelTextColor.call(n, t)) }), n.labelColors = o, n.labelPointStyles = s, n.labelTextColors = l, n.dataPoints = c, c }, r.update = function (t) { let e; const i = this; const r = i.options; const a = i._active; if (a.length) { const o = Ur[r.position].call(i, a, i._eventPosition); const s = i._createItems(); i.title = i.getTitle(s), i.beforeBody = i.getBeforeBody(s), i.body = i.getBody(s), i.afterBody = i.getAfterBody(s), i.footer = i.getFooter(s); const l = i._size = qr(i); const c = n({}, o, l); const u = Gr(i._chart, r, c); const h = Zr(r, c, u, i._chart); i.xAlign = u.xAlign, i.yAlign = u.yAlign, e = { opacity: 1, x: h.x, y: h.y, width: l.width, height: l.height, caretX: o.x, caretY: o.y } } else { i.opacity !== 0 && (e = { opacity: 0 }) } e && i._resolveAnimations().update(i, e), t && r.custom && r.custom.call(i, { chart: i._chart, tooltip: i }) }, r.drawCaret = function (t, e, n) { const i = this.getCaretPosition(t, n); e.lineTo(i.x1, i.y1), e.lineTo(i.x2, i.y2), e.lineTo(i.x3, i.y3) }, r.getCaretPosition = function (t, e) { let n; let i; let r; let a; let o; let s; const l = this.xAlign; const c = this.yAlign; const u = this.options; const h = u.cornerRadius; const f = u.caretSize; const d = t.x; const p = t.y; const g = e.width; const v = e.height; return c === 'center' ? (o = p + v / 2, l === 'left' ? (i = (n = d) - f, a = o + f, s = o - f) : (i = (n = d + g) + f, a = o - f, s = o + f), r = n) : (i = l === 'left' ? d + h + f : l === 'right' ? d + g - h - f : this.caretX, c === 'top' ? (o = (a = p) - f, n = i - f, r = i + f) : (o = (a = p + v) + f, n = i + f, r = i - f), s = a), { x1: n, x2: i, x3: r, y1: a, y2: o, y3: s } }, r.drawTitle = function (t, e) { let n; let i; let r; const a = this; const o = a.options; const s = a.title; const l = s.length; if (l) { const c = Di(o.rtl, a.x, a.width); for (t.x = Qr(a, o.titleAlign), e.textAlign = c.textAlign(o.titleAlign), e.textBaseline = 'middle', n = o.titleFont, i = o.titleSpacing, e.fillStyle = o.titleFont.color, e.font = n.string, r = 0; r < l; ++r) { e.fillText(s[r], c.x(t.x), t.y + n.size / 2), t.y += n.size + i, r + 1 === l && (t.y += o.titleMarginBottom - i) } } }, r._drawColorBox = function (t, e, n, i) { const r = this; const a = r.options; const o = r.labelColors[n]; const s = r.labelPointStyles[n]; const l = a.boxHeight; const c = a.boxWidth; const u = a.bodyFont; const h = Qr(r, 'left'); const f = i.x(h); const d = l < u.size ? (u.size - l) / 2 : 0; const p = e.y + d; if (a.usePointStyle) { const g = { radius: Math.min(c, l) / 2, pointStyle: s.pointStyle, rotation: s.rotation, borderWidth: 1 }; const v = i.leftForLtr(f, c) + c / 2; const m = p + l / 2; t.strokeStyle = a.multiKeyBackground, t.fillStyle = a.multiKeyBackground, at(t, g, v, m), t.strokeStyle = o.borderColor, t.fillStyle = o.backgroundColor, at(t, g, v, m) } else { t.fillStyle = a.multiKeyBackground, t.fillRect(i.leftForLtr(f, c), p, c, l), t.lineWidth = 1, t.strokeStyle = o.borderColor, t.strokeRect(i.leftForLtr(f, c), p, c, l), t.fillStyle = o.backgroundColor, t.fillRect(i.leftForLtr(i.xPlus(f, 1), c - 2), p + 1, c - 2, l - 2) }t.fillStyle = r.labelTextColors[n] }, r.drawBody = function (t, e) { let n; let i; let r; let a; let o; let s; let l; const c = this; const u = c.body; const h = c.options; const f = h.bodyFont; const d = h.bodySpacing; const p = h.bodyAlign; const g = h.displayColors; const v = h.boxHeight; const b = h.boxWidth; let x = f.size; let y = 0; const _ = Di(h.rtl, c.x, c.width); const w = function (n) { e.fillText(n, _.x(t.x + y), t.y + x / 2), t.y += x + d }; const M = _.textAlign(p); for (e.textAlign = p, e.textBaseline = 'middle', e.font = f.string, t.x = Qr(c, M), e.fillStyle = f.color, m(c.beforeBody, w), y = g && M !== 'right' ? p === 'center' ? b / 2 + 1 : b + 2 : 0, a = 0, s = u.length; a < s; ++a) { for (n = u[a], i = c.labelTextColors[a], e.fillStyle = i, m(n.before, w), r = n.lines, g && r.length && (c._drawColorBox(e, t, a, _), x = Math.max(f.size, v)), o = 0, l = r.length; o < l; ++o) { w(r[o]), x = f.size }m(n.after, w) }y = 0, x = f.size, m(c.afterBody, w), t.y -= d }, r.drawFooter = function (t, e) { let n; let i; const r = this; const a = r.options; const o = r.footer; const s = o.length; if (s) { const l = Di(a.rtl, r.x, r.width); for (t.x = Qr(r, a.footerAlign), t.y += a.footerMarginTop, e.textAlign = l.textAlign(a.footerAlign), e.textBaseline = 'middle', n = a.footerFont, e.fillStyle = a.footerFont.color, e.font = n.string, i = 0; i < s; ++i) { e.fillText(o[i], l.x(t.x), t.y + n.size / 2), t.y += n.size + a.footerSpacing } } }, r.drawBackground = function (t, e, n) { const i = this.xAlign; const r = this.yAlign; const a = this.options; const o = t.x; const s = t.y; const l = n.width; const c = n.height; const u = a.cornerRadius; e.fillStyle = a.backgroundColor, e.strokeStyle = a.borderColor, e.lineWidth = a.borderWidth, e.beginPath(), e.moveTo(o + u, s), r === 'top' && this.drawCaret(t, e, n), e.lineTo(o + l - u, s), e.quadraticCurveTo(o + l, s, o + l, s + u), r === 'center' && i === 'right' && this.drawCaret(t, e, n), e.lineTo(o + l, s + c - u), e.quadraticCurveTo(o + l, s + c, o + l - u, s + c), r === 'bottom' && this.drawCaret(t, e, n), e.lineTo(o + u, s + c), e.quadraticCurveTo(o, s + c, o, s + c - u), r === 'center' && i === 'left' && this.drawCaret(t, e, n), e.lineTo(o, s + u), e.quadraticCurveTo(o, s, o + u, s), e.closePath(), e.fill(), a.borderWidth > 0 && e.stroke() }, r._updateAnimationTarget = function () { const t = this; const e = t._chart; const i = t.options; const r = t.$animations; const a = r && r.x; const o = r && r.y; if (a || o) { const s = Ur[i.position].call(t, t._active, t._eventPosition); if (!s) { return } const l = t._size = qr(t); const c = n({}, s, t._size); const u = Gr(e, i, c); const h = Zr(i, c, u, e); a._to === h.x && o._to === h.y || (t.xAlign = u.xAlign, t.yAlign = u.yAlign, t.width = l.width, t.height = l.height, t.caretX = s.x, t.caretY = s.y, t._resolveAnimations().update(t, h)) } }, r.draw = function (t) { const e = this; const n = e.options; let i = e.opacity; if (i) { e._updateAnimationTarget(); const r = { width: e.width, height: e.height }; const a = { x: e.x, y: e.y }; i = Math.abs(i) < 0.001 ? 0 : i; const o = e.title.length || e.beforeBody.length || e.body.length || e.afterBody.length || e.footer.length; n.enabled && o && (t.save(), t.globalAlpha = i, e.drawBackground(a, t, r), Ai(t, n.textDirection), a.y += n.yPadding, e.drawTitle(a, t), e.drawBody(a, t), e.drawFooter(a, t), Ti(t, n.textDirection), t.restore()) } }, r.getActiveElements = function () { return this._active || [] }, r.setActiveElements = function (t, e) { const n = this; const i = n._active; const r = t.map(function (t) { const e = t.datasetIndex; const i = t.index; const r = n._chart.getDatasetMeta(e); if (!r) { throw new Error('Cannot find a dataset at index ' + e) } return { datasetIndex: e, element: r.data[i], index: i } }); const a = !b(i, r); const o = n._positionChanged(r, e); (a || o) && (n._active = r, n._eventPosition = e, n.update(!0)) }, r.handleEvent = function (t, e) { let n; const i = this; const r = i.options; const a = i._active || []; let o = []; t.type !== 'mouseout' && (o = i._chart.getElementsAtEventForMode(t, r.mode, r, e), r.reverse && o.reverse()); const s = i._positionChanged(o, t); return (n = e || !b(o, a) || s) && (i._active = o, (r.enabled || r.custom) && (i._eventPosition = { x: t.x, y: t.y }, i.update(!0))), n }, r._positionChanged = function (t, e) { const n = this; const i = Ur[n.options.position].call(n, t, e); return n.caretX !== i.x || n.caretY !== i.y }, e }(Xn)); ta.positioners = Ur; const ea = { id: 'tooltip', _element: ta, positioners: Ur, afterInit (t) { t.options.tooltips && (t.tooltip = new ta({ _chart: t })) }, beforeUpdate (t) { t.tooltip && t.tooltip.initialize() }, reset (t) { t.tooltip && t.tooltip.initialize() }, afterDraw (t) { const e = t.tooltip; const n = { tooltip: e }; !1 !== t._plugins.notify(t, 'beforeTooltipDraw', [n]) && (e && e.draw(t.ctx), t._plugins.notify(t, 'afterTooltipDraw', [n])) }, afterEvent (t, e, n) { if (t.tooltip) { const i = n; t.tooltip.handleEvent(e, i) } }, defaults: { enabled: !0, custom: null, position: 'average', backgroundColor: 'rgba(0,0,0,0.8)', titleFont: { style: 'bold', color: '#fff' }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: 'left', bodySpacing: 2, bodyFont: { color: '#fff' }, bodyAlign: 'left', footerSpacing: 2, footerMarginTop: 6, footerFont: { color: '#fff', style: 'bold' }, footerAlign: 'left', yPadding: 6, xPadding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, multiKeyBackground: '#fff', displayColors: !0, borderColor: 'rgba(0,0,0,0)', borderWidth: 0, animation: { duration: 400, easing: 'easeOutQuart', numbers: { type: 'number', properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'] }, opacity: { easing: 'linear', duration: 200 } }, callbacks: { beforeTitle: l, title (t) { if (t.length > 0) { const e = t[0]; const n = e.chart.data.labels; const i = n ? n.length : 0; if (e.label) { return e.label } if (i > 0 && e.dataIndex < i) { return n[e.dataIndex] } } return '' }, afterTitle: l, beforeBody: l, beforeLabel: l, label (t) { let e = t.dataset.label || ''; e && (e += ': '); const n = t.formattedValue; return h(n) || (e += n), e }, labelColor (t) { const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { borderColor: e.borderColor, backgroundColor: e.backgroundColor } }, labelTextColor () { return this.options.bodyFont.color }, labelPointStyle (t) { const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { pointStyle: e.pointStyle, rotation: e.rotation } }, afterLabel: l, afterBody: l, beforeFooter: l, footer: l, afterFooter: l } } }; const na = Object.freeze({ __proto__: null, Filler: Fr, Legend: Nr, Title: Yr, Tooltip: ea }); const ia = (function (t) { function e (e) { let n; return (n = t.call(this, e) || this)._startValue = void 0, n._valueRange = 0, n }i(e, t); const n = e.prototype; return n.parse = function (t, e) { const n = this.getLabels(); if (n[e] === t) { return e } const i = n.indexOf(t); const r = n.lastIndexOf(t); return i === -1 || i !== r ? e : i }, n.determineDataLimits = function () { const t = this; const e = t.getLabels().length - 1; t.min = Math.max(t._userMin || 0, 0), t.max = Math.min(t._userMax || e, e) }, n.buildTicks = function () { const t = this; const e = t.min; const n = t.max; const i = t.options.offset; const r = []; let a = t.getLabels(); a = e === 0 && n === a.length - 1 ? a : a.slice(e, n + 1), t._valueRange = Math.max(a.length - (i ? 0 : 1), 1), t._startValue = t.min - (i ? 0.5 : 0); for (let o = e; o <= n; o++) { r.push({ value: o }) } return r }, n.getLabelForValue = function (t) { const e = this.getLabels(); return t >= 0 && t < e.length ? e[t] : t }, n.configure = function () { const e = this; t.prototype.configure.call(this), e.isHorizontal() || (e._reversePixels = !e._reversePixels) }, n.getPixelForValue = function (t) { const e = this; return typeof t !== 'number' && (t = e.parse(t)), e.getPixelForDecimal((t - e._startValue) / e._valueRange) }, n.getPixelForTick = function (t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) }, n.getValueForPixel = function (t) { const e = this; const n = Math.round(e._startValue + e.getDecimalForPixel(t) * e._valueRange); return Math.min(Math.max(n, 0), e.ticks.length - 1) }, n.getBasePixel = function () { return this.bottom }, e }(ei)); function ra (t) { const e = Math.floor(B(t)); const n = t / Math.pow(10, e); return (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * Math.pow(10, e) }ia.id = 'category', ia.defaults = { ticks: { callback: ia.prototype.getLabelForValue } }; const aa = (function (t) { function e (e) { let n; return (n = t.call(this, e) || this).start = void 0, n.end = void 0, n._startValue = void 0, n._endValue = void 0, n._valueRange = 0, n }i(e, t); const n = e.prototype; return n.parse = function (t, e) { return h(t) || (typeof t === 'number' || t instanceof Number) && !isFinite(+t) ? NaN : +t }, n.handleTickRangeOptions = function () { const t = this; const e = t.options; if (e.beginAtZero) { const n = j(t.min); const i = j(t.max); n < 0 && i < 0 ? t.max = 0 : n > 0 && i > 0 && (t.min = 0) } const r = void 0 !== e.min || void 0 !== e.suggestedMin; const a = void 0 !== e.max || void 0 !== e.suggestedMax; void 0 !== e.min ? t.min = e.min : void 0 !== e.suggestedMin && (t.min === null ? t.min = e.suggestedMin : t.min = Math.min(t.min, e.suggestedMin)), void 0 !== e.max ? t.max = e.max : void 0 !== e.suggestedMax && (t.max === null ? t.max = e.suggestedMax : t.max = Math.max(t.max, e.suggestedMax)), r !== a && t.min >= t.max && (r ? t.max = t.min + 1 : t.min = t.max - 1), t.min === t.max && (t.max++, e.beginAtZero || t.min--) }, n.getTickLimit = function () { let t; const e = this; const n = e.options.ticks; let i = n.maxTicksLimit; const r = n.stepSize; return r ? t = Math.ceil(e.max / r) - Math.floor(e.min / r) + 1 : (t = e.computeTickLimit(), i = i || 11), i && (t = Math.min(i, t)), t }, n.computeTickLimit = function () { return Number.POSITIVE_INFINITY }, n.buildTicks = function () { const t = this; const e = t.options; const n = e.ticks; let i = t.getTickLimit(); const r = (function (t, e) { let n; let i; let r; let a; const o = []; const s = t.stepSize; const l = t.min; const c = t.max; const u = t.precision; const f = s || 1; const d = t.maxTicks - 1; const p = e.min; const g = e.max; let v = ra((g - p) / d / f) * f; if (v < 1e-14 && h(l) && h(c)) { return [{ value: p }, { value: g }] } (a = Math.ceil(g / v) - Math.floor(p / v)) > d && (v = ra(a * v / d / f) * f), s || h(u) ? n = Math.pow(10, X(v)) : (n = Math.pow(10, u), v = Math.ceil(v * n) / n), i = Math.floor(p / v) * v, r = Math.ceil(g / v) * v, !s || h(l) || h(c) || N((c - l) / s, v / 1e3) && (i = l, r = c), a = W(a = (r - i) / v, Math.round(a), v / 1e3) ? Math.round(a) : Math.ceil(a), i = Math.round(i * n) / n, r = Math.round(r * n) / n, o.push({ value: h(l) ? i : l }); for (let m = 1; m < a; ++m) { o.push({ value: Math.round((i + m * v) * n) / n }) } return o.push({ value: h(c) ? r : c }), o }({ maxTicks: i = Math.max(2, i), min: e.min, max: e.max, precision: n.precision, stepSize: g(n.fixedStepSize, n.stepSize) }, t)); return H(r, t, 'value'), e.reverse ? (r.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max), r }, n.configure = function () { const e = this; const n = e.ticks; let i = e.min; let r = e.max; if (t.prototype.configure.call(this), e.options.offset && n.length) { const a = (r - i) / Math.max(n.length - 1, 1) / 2; i -= a, r += a }e._startValue = i, e._endValue = r, e._valueRange = r - i }, n.getLabelForValue = function (t) { return new Intl.NumberFormat(this.options.locale).format(t) }, e }(ei)); const oa = (function (t) { function e () { return t.apply(this, arguments) || this }i(e, t); const n = e.prototype; return n.determineDataLimits = function () { const t = this; const e = t.options; const n = t.getMinMax(!0); const i = n.min; const r = n.max; t.min = p(i) ? i : g(e.suggestedMin, 0), t.max = p(r) ? r : g(e.suggestedMax, 1), e.stacked && i > 0 && (t.min = 0), t.handleTickRangeOptions() }, n.computeTickLimit = function () { const t = this; if (t.isHorizontal()) { return Math.ceil(t.width / 40) } const e = t._resolveTickFontOptions(0); return Math.ceil(t.height / e.lineHeight) }, n.getPixelForValue = function (t) { const e = this; return e.getPixelForDecimal((t - e._startValue) / e._valueRange) }, n.getValueForPixel = function (t) { return this._startValue + this.getDecimalForPixel(t) * this._valueRange }, e }(aa)); function sa (t) { return t / Math.pow(10, Math.floor(B(t))) === 1 } function la (t, e) { return p(t) ? t : e }oa.id = 'linear', oa.defaults = { ticks: { callback: qn.formatters.numeric } }; const ca = (function (t) { function e (e) { let n; return (n = t.call(this, e) || this).start = void 0, n.end = void 0, n._startValue = void 0, n._valueRange = 0, n }i(e, t); const n = e.prototype; return n.parse = function (t, e) { const n = aa.prototype.parse.apply(this, [t, e]); if (n !== 0) { return p(n) && n > 0 ? n : NaN } this._zero = !0 }, n.determineDataLimits = function () { const t = this; const e = t.getMinMax(!0); const n = e.min; const i = e.max; t.min = p(n) ? Math.max(0, n) : null, t.max = p(i) ? Math.max(0, i) : null, t.options.beginAtZero && (t._zero = !0), t.handleTickRangeOptions() }, n.handleTickRangeOptions = function () { const t = this; const e = t.options; const n = e.suggestedMax; const i = e.suggestedMin; let r = t.min; let a = t.max; h(i) || (r = Math.min(r, i)), h(n) || (a = Math.max(a, n)), r === a && (r <= 0 ? (r = 1, a = 10) : (r = Math.pow(10, Math.floor(B(r)) - 1), a = Math.pow(10, Math.floor(B(a)) + 1))), r <= 0 && (r = Math.pow(10, Math.floor(B(a)) - 1)), a <= 0 && (a = Math.pow(10, Math.floor(B(r)) + 1)), !t._userMin && t._zero && r === Math.pow(10, Math.floor(B(t.min))) && (r = Math.pow(10, Math.floor(B(r)) - 1)), t.min = r, t.max = a }, n.buildTicks = function () { const t = this; const e = t.options; const n = (function (t, e) { const n = Math.floor(B(e.max)); const i = Math.ceil(e.max / Math.pow(10, n)); const r = []; let a = la(t.min, Math.pow(10, Math.floor(B(e.min)))); let o = Math.floor(B(a)); let s = Math.floor(a / Math.pow(10, o)); let l = o < 0 ? Math.pow(10, Math.abs(o)) : 1; do { r.push({ value: a, major: sa(a) }), ++s == 10 && (s = 1, l = ++o >= 0 ? 1 : l), a = Math.round(s * Math.pow(10, o) * l) / l } while (o < n || o === n && s < i); const c = la(t.max, a); return r.push({ value: c, major: sa(a) }), r }({ min: t._userMin, max: t._userMax }, t)); let i = !t.isHorizontal(); return H(n, t, 'value'), e.reverse ? (i = !i, t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max), i && n.reverse(), n }, n.getLabelForValue = function (t) { return void 0 === t ? '0' : new Intl.NumberFormat(this.options.locale).format(t) }, n.configure = function () { const e = this; const n = e.min; t.prototype.configure.call(this), e._startValue = B(n), e._valueRange = B(e.max) - B(n) }, n.getPixelForValue = function (t) { const e = this; return void 0 !== t && t !== 0 || (t = e.min), e.getPixelForDecimal(t === e.min ? 0 : (B(t) - e._startValue) / e._valueRange) }, n.getValueForPixel = function (t) { const e = this; const n = e.getDecimalForPixel(t); return Math.pow(10, e._startValue + n * e._valueRange) }, e }(ei)); function ua (t) { const e = t.ticks; return e.display && t.display ? g(e.font && e.font.size, A.font.size) + 2 * e.backdropPaddingY : 0 } function ha (t, e, n, i, r) { return t === i || t === r ? { start: e - n / 2, end: e + n / 2 } : t < i || t > r ? { start: e - n, end: e } : { start: e, end: e + n } } function fa (t) { return t === 0 || t === 180 ? 'center' : t < 180 ? 'left' : 'right' } function da (t, e, n, i) { let r; let a; let o = n.y + i / 2; if (f(e)) { for (r = 0, a = e.length; r < a; ++r) { t.fillText(e[r], n.x, o), o += i } } else { t.fillText(e, n.x, o) } } function pa (t, e, n) { t === 90 || t === 270 ? n.y -= e.h / 2 : (t > 270 || t < 90) && (n.y -= e.h) } function ga (t) { return V(t) ? t : 0 }ca.id = 'logarithmic', ca.defaults = { ticks: { callback: qn.formatters.logarithmic, major: { enabled: !0 } } }; const va = (function (t) { function e (e) { let n; return (n = t.call(this, e) || this).xCenter = void 0, n.yCenter = void 0, n.drawingArea = void 0, n.pointLabels = [], n }i(e, t); const n = e.prototype; return n.init = function (e) { t.prototype.init.call(this, e), this.axis = 'r' }, n.setDimensions = function () { const t = this; t.width = t.maxWidth, t.height = t.maxHeight, t.paddingTop = ua(t.options) / 2, t.xCenter = Math.floor(t.width / 2), t.yCenter = Math.floor((t.height - t.paddingTop) / 2), t.drawingArea = Math.min(t.height - t.paddingTop, t.width) / 2 }, n.determineDataLimits = function () { const t = this; const e = t.getMinMax(!1); const n = e.min; const i = e.max; t.min = p(n) && !isNaN(n) ? n : 0, t.max = p(i) && !isNaN(i) ? i : 0, t.handleTickRangeOptions() }, n.computeTickLimit = function () { return Math.ceil(this.drawingArea / ua(this.options)) }, n.generateTickLabels = function (t) { const e = this; aa.prototype.generateTickLabels.call(e, t), e.pointLabels = e.chart.data.labels.map(function (t, n) { const i = v(e.options.pointLabels.callback, [t, n], e); return i || i === 0 ? i : '' }) }, n.fit = function () { const t = this; const e = t.options; e.display && e.pointLabels.display ? (function (t) { let e; let n; let i; const r = { l: 0, r: t.width, t: 0, b: t.height - t.paddingTop }; const a = {}; t._pointLabelSizes = []; let o; let s; let l; const c = t.chart.data.labels.length; for (e = 0; e < c; e++) { i = t.getPointPosition(e, t.drawingArea + 5); const u = t.getContext(e); const h = Ht(jt([t.options.pointLabels.font], u, e), t.chart.options.font); t.ctx.font = h.string, o = t.ctx, s = h.lineHeight, n = f(l = t.pointLabels[e]) ? { w: nt(o, o.font, l), h: l.length * s } : { w: o.measureText(l).width, h: s }, t._pointLabelSizes[e] = n; const d = t.getIndexAngle(e); const p = U(d); const g = ha(p, i.x, n.w, 0, 180); const v = ha(p, i.y, n.h, 90, 270); g.start < r.l && (r.l = g.start, a.l = d), g.end > r.r && (r.r = g.end, a.r = d), v.start < r.t && (r.t = v.start, a.t = d), v.end > r.b && (r.b = v.end, a.b = d) }t._setReductions(t.drawingArea, r, a) }(t)) : t.setCenterPoint(0, 0, 0, 0) }, n._setReductions = function (t, e, n) { const i = this; let r = e.l / Math.sin(n.l); let a = Math.max(e.r - i.width, 0) / Math.sin(n.r); let o = -e.t / Math.cos(n.t); let s = -Math.max(e.b - (i.height - i.paddingTop), 0) / Math.cos(n.b); r = ga(r), a = ga(a), o = ga(o), s = ga(s), i.drawingArea = Math.min(Math.floor(t - (r + a) / 2), Math.floor(t - (o + s) / 2)), i.setCenterPoint(r, a, o, s) }, n.setCenterPoint = function (t, e, n, i) { const r = this; const a = r.width - e - r.drawingArea; const o = t + r.drawingArea; const s = n + r.drawingArea; const l = r.height - r.paddingTop - i - r.drawingArea; r.xCenter = Math.floor((o + a) / 2 + r.left), r.yCenter = Math.floor((s + l) / 2 + r.top + r.paddingTop) }, n.getIndexAngle = function (t) { const e = this.chart; return G(t * (O / e.data.labels.length) + Y((e.options || {}).startAngle || 0)) }, n.getDistanceFromCenterForValue = function (t) { const e = this; if (h(t)) { return NaN } const n = e.drawingArea / (e.max - e.min); return e.options.reverse ? (e.max - t) * n : (t - e.min) * n }, n.getValueForDistanceFromCenter = function (t) { if (h(t)) { return NaN } const e = this; const n = t / (e.drawingArea / (e.max - e.min)); return e.options.reverse ? e.max - n : e.min + n }, n.getPointPosition = function (t, e) { const n = this; const i = n.getIndexAngle(t) - R; return { x: Math.cos(i) * e + n.xCenter, y: Math.sin(i) * e + n.yCenter, angle: i } }, n.getPointPositionForValue = function (t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)) }, n.getBasePosition = function (t) { return this.getPointPositionForValue(t || 0, this.getBaseValue()) }, n.drawGrid = function () { let t; let e; let n; const i = this; const r = i.ctx; const a = i.options; const o = a.gridLines; const s = a.angleLines; if (a.pointLabels.display && (function (t) { const e = t.ctx; const n = t.options; const i = n.pointLabels; const r = ua(n); const a = t.getDistanceFromCenterForValue(n.ticks.reverse ? t.min : t.max); e.save(), e.textBaseline = 'middle'; for (let o = t.chart.data.labels.length - 1; o >= 0; o--) { const s = o === 0 ? r / 2 : 0; const l = t.getPointPosition(o, a + s + 5); const c = t.getContext(o); const u = Ht(jt([i.font], c, o), t.chart.options.font); e.font = u.string, e.fillStyle = u.color; const h = U(t.getIndexAngle(o)); e.textAlign = fa(h), pa(h, t._pointLabelSizes[o], l), da(e, t.pointLabels[o], l, u.lineHeight) }e.restore() }(i)), o.display && i.ticks.forEach(function (t, n) { n !== 0 && (e = i.getDistanceFromCenterForValue(i.ticks[n].value), (function (t, e, n, i) { let r; const a = t.ctx; const o = e.circular; const s = t.chart.data.labels.length; const l = t.getContext(i); const c = jt([e.color], l, i - 1); const u = jt([e.lineWidth], l, i - 1); if ((o || s) && c && u) { if (a.save(), a.strokeStyle = c, a.lineWidth = u, a.setLineDash && (a.setLineDash(jt([e.borderDash, []], l)), a.lineDashOffset = jt([e.borderDashOffset], l, i - 1)), a.beginPath(), o) { a.arc(t.xCenter, t.yCenter, n, 0, O) } else { r = t.getPointPosition(0, n), a.moveTo(r.x, r.y); for (let h = 1; h < s; h++) { r = t.getPointPosition(h, n), a.lineTo(r.x, r.y) } }a.closePath(), a.stroke(), a.restore() } }(i, o, e, n))) }), s.display) { for (r.save(), t = i.chart.data.labels.length - 1; t >= 0; t--) { const l = i.getContext(t); const c = jt([s.lineWidth, o.lineWidth], l, t); const u = jt([s.color, o.color], l, t); c && u && (r.lineWidth = c, r.strokeStyle = u, r.setLineDash && (r.setLineDash(jt([s.borderDash, o.borderDash, []], l)), r.lineDashOffset = jt([s.borderDashOffset, o.borderDashOffset, 0], l, t)), e = i.getDistanceFromCenterForValue(a.ticks.reverse ? i.min : i.max), n = i.getPointPosition(t, e), r.beginPath(), r.moveTo(i.xCenter, i.yCenter), r.lineTo(n.x, n.y), r.stroke()) }r.restore() } }, n.drawLabels = function () { const t = this; const e = t.ctx; const n = t.options; const i = n.ticks; if (i.display) { let r; let a; const o = t.getIndexAngle(0); e.save(), e.translate(t.xCenter, t.yCenter), e.rotate(o), e.textAlign = 'center', e.textBaseline = 'middle', t.ticks.forEach(function (o, s) { if (s !== 0 || n.reverse) { const l = t.getContext(s); const c = t._resolveTickFontOptions(s); e.font = c.string, r = t.getDistanceFromCenterForValue(t.ticks[s].value), jt([i.showLabelBackdrop], l, s) && (a = e.measureText(o.label).width, e.fillStyle = jt([i.backdropColor], l, s), e.fillRect(-a / 2 - i.backdropPaddingX, -r - c.size / 2 - i.backdropPaddingY, a + 2 * i.backdropPaddingX, c.size + 2 * i.backdropPaddingY)), e.fillStyle = c.color, e.fillText(o.label, 0, -r) } }), e.restore() } }, n.drawTitle = function () {}, e }(aa)); va.id = 'radialLinear', va.defaults = { display: !0, animate: !0, position: 'chartArea', angleLines: { display: !0, color: 'rgba(0,0,0,0.1)', lineWidth: 1, borderDash: [], borderDashOffset: 0 }, gridLines: { circular: !1 }, ticks: { showLabelBackdrop: !0, backdropColor: 'rgba(255,255,255,0.75)', backdropPaddingY: 2, backdropPaddingX: 2, callback: qn.formatters.numeric }, pointLabels: { display: !0, font: { size: 10 }, callback (t) { return t } } }; const ma = Number.MAX_SAFE_INTEGER || 9007199254740991; const ba = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }; const xa = Object.keys(ba); function ya (t, e) { return t - e } function _a (t, e) { if (h(e)) { return null } const n = t._adapter; const i = t.options.time; const r = i.parser; const a = i.round; const o = i.isoWeekday; let s = e; return typeof r === 'function' && (s = r(s)), p(s) || (s = typeof r === 'string' ? n.parse(s, r) : n.parse(s)), s === null ? s : (a && (s = a !== 'week' || !V(o) && !0 !== o ? t._adapter.startOf(s, a) : t._adapter.startOf(s, 'isoWeek', o)), +s) } function wa (t, e, n, i) { for (var r = xa.length, a = xa.indexOf(t); a < r - 1; ++a) { const o = ba[xa[a]]; const s = o.steps ? o.steps : ma; if (o.common && Math.ceil((n - e) / (s * o.size)) <= i) { return xa[a] } } return xa[r - 1] } function Ma (t, e, n) { if (n) { if (n.length) { const i = ht(n, e); const r = i.lo; const a = i.hi; t[n[r] >= e ? n[r] : n[a]] = !0 } } else { t[e] = !0 } } function ka (t, e, n) { let i; let r; const a = []; const o = {}; const s = e.length; for (i = 0; i < s; ++i) { o[r = e[i]] = i, a.push({ value: r, major: !1 }) } return s !== 0 && n ? (function (t, e, n, i) { let r; let a; const o = t._adapter; const s = +o.startOf(e[0].value, i); const l = e[e.length - 1].value; for (r = s; r <= l; r = +o.add(r, 1, i)) { (a = n[r]) >= 0 && (e[a].major = !0) } return e }(t, a, o, n)) : a } const Sa = (function (t) { function e (e) { let n; return (n = t.call(this, e) || this)._cache = { data: [], labels: [], all: [] }, n._unit = 'day', n._majorUnit = void 0, n._offsets = {}, n._normalized = !1, n }i(e, t); const n = e.prototype; return n.init = function (e, n) { const i = e.time || (e.time = {}); const r = this._adapter = new Bi._date(e.adapters.date); M(i.displayFormats, r.formats()), t.prototype.init.call(this, e), this._normalized = n.normalized }, n.parse = function (t, e) { return void 0 === t ? NaN : _a(this, t) }, n.invalidateCaches = function () { this._cache = { data: [], labels: [], all: [] } }, n.determineDataLimits = function () { const t = this; const e = t.options; const n = t._adapter; const i = e.time.unit || 'day'; const r = t.getUserBounds(); let a = r.min; let o = r.max; const s = r.minDefined; const l = r.maxDefined; function c (t) { s || isNaN(t.min) || (a = Math.min(a, t.min)), l || isNaN(t.max) || (o = Math.max(o, t.max)) }s && l || (c(t._getLabelBounds()), e.bounds === 'ticks' && e.ticks.source === 'labels' || c(t.getMinMax(!1))), a = p(a) && !isNaN(a) ? a : +n.startOf(Date.now(), i), o = p(o) && !isNaN(o) ? o : +n.endOf(Date.now(), i) + 1, t.min = Math.min(a, o), t.max = Math.max(a + 1, o) }, n._getLabelBounds = function () { const t = this.getLabelTimestamps(); let e = Number.POSITIVE_INFINITY; let n = Number.NEGATIVE_INFINITY; return t.length && (e = t[0], n = t[t.length - 1]), { min: e, max: n } }, n.buildTicks = function () { const t = this; const e = t.options; const n = e.time; const i = e.ticks; const r = i.source === 'labels' ? t.getLabelTimestamps() : t._generate(); e.bounds === 'ticks' && r.length && (t.min = t._userMin || r[0], t.max = t._userMax || r[r.length - 1]); const a = t.min; const o = pt(r, a, t.max); return t._unit = n.unit || (i.autoSkip ? wa(n.minUnit, t.min, t.max, t._getLabelCapacity(a)) : (function (t, e, n, i, r) { for (let a = xa.length - 1; a >= xa.indexOf(n); a--) { const o = xa[a]; if (ba[o].common && t._adapter.diff(r, i, o) >= e - 1) { return o } } return xa[n ? xa.indexOf(n) : 0] }(t, o.length, n.minUnit, t.min, t.max))), t._majorUnit = i.major.enabled && t._unit !== 'year' ? (function (t) { for (let e = xa.indexOf(t) + 1, n = xa.length; e < n; ++e) { if (ba[xa[e]].common) { return xa[e] } } }(t._unit)) : void 0, t.initOffsets(r), e.reverse && o.reverse(), ka(t, o, t._majorUnit) }, n.initOffsets = function (t) { let e; let n; const i = this; let r = 0; let a = 0; i.options.offset && t.length && (e = i.getDecimalForValue(t[0]), r = t.length === 1 ? 1 - e : (i.getDecimalForValue(t[1]) - e) / 2, n = i.getDecimalForValue(t[t.length - 1]), a = t.length === 1 ? n : (n - i.getDecimalForValue(t[t.length - 2])) / 2), i._offsets = { start: r, end: a, factor: 1 / (r + 1 + a) } }, n._generate = function () { let t; const e = this; const n = e._adapter; const i = e.min; const r = e.max; const a = e.options; const o = a.time; const s = o.unit || wa(o.minUnit, i, r, e._getLabelCapacity(i)); const l = g(o.stepSize, 1); const c = s === 'week' && o.isoWeekday; const u = V(c) || !0 === c; const h = {}; let f = i; if (u && (f = +n.startOf(f, 'isoWeek', c)), f = +n.startOf(f, u ? 'day' : s), n.diff(r, i, s) > 1e5 * l) { throw new Error(i + ' and ' + r + ' are too far apart with stepSize of ' + l + ' ' + s) } const d = a.ticks.source === 'data' && e.getDataTimestamps(); for (t = f; t < r; t = +n.add(t, l, s)) { Ma(h, t, d) } return t !== r && a.bounds !== 'ticks' || Ma(h, t, d), Object.keys(h).sort(function (t, e) { return t - e }).map(function (t) { return +t }) }, n.getLabelForValue = function (t) { const e = this._adapter; const n = this.options.time; return n.tooltipFormat ? e.format(t, n.tooltipFormat) : e.format(t, n.displayFormats.datetime) }, n._tickFormatFunction = function (t, e, n, i) { const r = this; const a = r.options; const o = a.time.displayFormats; const s = r._unit; const l = r._majorUnit; const c = s && o[s]; const u = l && o[l]; const h = n[e]; const f = l && u && h && h.major; const d = r._adapter.format(t, i || (f ? u : c)); const p = a.ticks.callback; return p ? p(d, e, n) : d }, n.generateTickLabels = function (t) { let e, n, i; for (e = 0, n = t.length; e < n; ++e) { (i = t[e]).label = this._tickFormatFunction(i.value, e, t) } }, n.getDecimalForValue = function (t) { const e = this; return (t - e.min) / (e.max - e.min) }, n.getPixelForValue = function (t) { const e = this; const n = e._offsets; const i = e.getDecimalForValue(t); return e.getPixelForDecimal((n.start + i) * n.factor) }, n.getValueForPixel = function (t) { const e = this; const n = e._offsets; const i = e.getDecimalForPixel(t) / n.factor - n.end; return e.min + i * (e.max - e.min) }, n._getLabelSize = function (t) { const e = this; const n = e.options.ticks; const i = e.ctx.measureText(t).width; const r = Y(e.isHorizontal() ? n.maxRotation : n.minRotation); const a = Math.cos(r); const o = Math.sin(r); const s = e._resolveTickFontOptions(0).size; return { w: i * a + s * o, h: i * o + s * a } }, n._getLabelCapacity = function (t) { const e = this; const n = e.options.time; const i = n.displayFormats; const r = i[n.unit] || i.millisecond; const a = e._tickFormatFunction(t, 0, ka(e, [t], e._majorUnit), r); const o = e._getLabelSize(a); const s = Math.floor(e.isHorizontal() ? e.width / o.w : e.height / o.h) - 1; return s > 0 ? s : 1 }, n.getDataTimestamps = function () { let t; let e; const n = this; let i = n._cache.data || []; if (i.length) { return i } const r = n.getMatchingVisibleMetas(); if (n._normalized && r.length) { return n._cache.data = r[0].controller.getAllParsedValues(n) } for (t = 0, e = r.length; t < e; ++t) { i = i.concat(r[t].controller.getAllParsedValues(n)) } return n._cache.data = n.normalize(i) }, n.getLabelTimestamps = function () { let t; let e; const n = this; const i = n._cache.labels || []; if (i.length) { return i } const r = n.getLabels(); for (t = 0, e = r.length; t < e; ++t) { i.push(_a(n, r[t])) } return n._cache.labels = n._normalized ? i : n.normalize(i) }, n.normalize = function (t) { return bt(t.sort(ya)) }, e }(ei)); function Pa (t, e, n) { let i, r, a, o; if (n) { i = Math.floor(e), r = Math.ceil(e), a = t[i], o = t[r] } else { const s = ht(t, e); a = s.lo, o = s.hi, i = t[a], r = t[o] } const l = r - i; return l ? a + (o - a) * (e - i) / l : a }Sa.id = 'time', Sa.defaults = { bounds: 'data', adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: 'millisecond', displayFormats: {} }, ticks: { source: 'auto', major: { enabled: !1 } } }; const Da = (function (t) { function e (e) { let n; return (n = t.call(this, e) || this)._table = [], n._maxIndex = void 0, n }i(e, t); const n = e.prototype; return n.initOffsets = function () { const e = this; const n = e._getTimestampsForTable(); e._table = e.buildLookupTable(n), e._maxIndex = e._table.length - 1, t.prototype.initOffsets.call(this, n) }, n.buildLookupTable = function (t) { const e = this.min; const n = this.max; if (!t.length) { return [{ time: e, pos: 0 }, { time: n, pos: 1 }] } let i; let r; let a; const o = [e]; for (i = 0, r = t.length; i < r; ++i) { (a = t[i]) > e && a < n && o.push(a) } return o.push(n), o }, n._getTimestampsForTable = function () { const t = this; let e = t._cache.all || []; if (e.length) { return e } const n = t.getDataTimestamps(); const i = t.getLabelTimestamps(); return e = n.length && i.length ? t.normalize(n.concat(i)) : n.length ? n : i, e = t._cache.all = e }, n.getPixelForValue = function (t, e) { const n = this; const i = n._offsets; const r = n._normalized && n._maxIndex > 0 && !h(e) ? e / n._maxIndex : n.getDecimalForValue(t); return n.getPixelForDecimal((i.start + r) * i.factor) }, n.getDecimalForValue = function (t) { return Pa(this._table, t) / this._maxIndex }, n.getValueForPixel = function (t) { const e = this; const n = e._offsets; const i = e.getDecimalForPixel(t) / n.factor - n.end; return Pa(e._table, i * this._maxIndex, !0) }, e }(Sa)); Da.id = 'timeseries', Da.defaults = Sa.defaults; const Aa = Object.freeze({ __proto__: null, CategoryScale: ia, LinearScale: oa, LogarithmicScale: ca, RadialLinearScale: va, TimeScale: Sa, TimeSeriesScale: Da }); return mi.register(Zi, Aa, xr, na), mi.helpers = n({}, Fi), mi._adapters = Bi, mi.Animation = Cn, mi.Animations = Fn, mi.animator = s, mi.controllers = ii.controllers.items, mi.DatasetController = Un, mi.Element = Xn, mi.elements = xr, mi.Interaction = zt, mi.layouts = Jt, mi.platforms = Ie, mi.Scale = ei, mi.Ticks = qn, n(mi, Zi, Aa, xr, na, Ie), mi.Chart = mi, typeof window !== 'undefined' && (window.Chart = mi), mi
}))
