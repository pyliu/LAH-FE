/*!
    localForage -- Offline Storage, Improved
    Version 1.7.3
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
!(function (a) { if (typeof exports === 'object' && typeof module !== 'undefined') { module.exports = a() } else if (typeof define === 'function' && define.amd) { define([], a) } else { let b; b = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this, b.localforage = a() } }(function () { return (function a (b, c, d) { function e (g, h) { if (!c[g]) { if (!b[g]) { const i = typeof require === 'function' && require; if (!h && i) { return i(g, !0) } if (f) { return f(g, !0) } const j = new Error("Cannot find module '" + g + "'"); throw j.code = 'MODULE_NOT_FOUND', j } const k = c[g] = { exports: {} }; b[g][0].call(k.exports, function (a) { const c = b[g][1][a]; return e(c || a) }, k, k.exports, a, b, c, d) } return c[g].exports } for (var f = typeof require === 'function' && require, g = 0; g < d.length; g++) { e(d[g]) } return e }({ 1: [function (a, b, c) { (function (a) { 'use strict'; function c () { k = !0; for (var a, b, c = l.length; c;) { for (b = l, l = [], a = -1; ++a < c;) { b[a]() }c = l.length }k = !1 } function d (a) { l.push(a) !== 1 || k || e() } let e; const f = a.MutationObserver || a.WebKitMutationObserver; if (f) { let g = 0; const h = new f(c); const i = a.document.createTextNode(''); h.observe(i, { characterData: !0 }), e = function () { i.data = g = ++g % 2 } } else if (a.setImmediate || void 0 === a.MessageChannel) { e = 'document' in a && 'onreadystatechange' in a.document.createElement('script') ? function () { let b = a.document.createElement('script'); b.onreadystatechange = function () { c(), b.onreadystatechange = null, b.parentNode.removeChild(b), b = null }, a.document.documentElement.appendChild(b) } : function () { setTimeout(c, 0) } } else { const j = new a.MessageChannel(); j.port1.onmessage = c, e = function () { j.port2.postMessage(0) } } let k; var l = []; b.exports = d }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}) }, {}], 2: [function (a, b, c) { 'use strict'; function d () {} function e (a) { if (typeof a !== 'function') { throw new TypeError('resolver must be a function') } this.state = s, this.queue = [], this.outcome = void 0, a !== d && i(this, a) } function f (a, b, c) { this.promise = a, typeof b === 'function' && (this.onFulfilled = b, this.callFulfilled = this.otherCallFulfilled), typeof c === 'function' && (this.onRejected = c, this.callRejected = this.otherCallRejected) } function g (a, b, c) { o(function () { let d; try { d = b(c) } catch (b) { return p.reject(a, b) }d === a ? p.reject(a, new TypeError('Cannot resolve promise with itself')) : p.resolve(a, d) }) } function h (a) { const b = a && a.then; if (a && (typeof a === 'object' || typeof a === 'function') && typeof b === 'function') { return function () { b.apply(a, arguments) } } } function i (a, b) { function c (b) { f || (f = !0, p.reject(a, b)) } function d (b) { f || (f = !0, p.resolve(a, b)) } function e () { b(d, c) } var f = !1; const g = j(e); g.status === 'error' && c(g.value) } function j (a, b) { const c = {}; try { c.value = a(b), c.status = 'success' } catch (a) { c.status = 'error', c.value = a } return c } function k (a) { return a instanceof this ? a : p.resolve(new this(d), a) } function l (a) { const b = new this(d); return p.reject(b, a) } function m (a) { function b (a, b) { function d (a) { g[b] = a, ++h !== e || f || (f = !0, p.resolve(j, g)) }c.resolve(a).then(d, function (a) { f || (f = !0, p.reject(j, a)) }) } var c = this; if (Object.prototype.toString.call(a) !== '[object Array]') { return this.reject(new TypeError('must be an array')) } var e = a.length; var f = !1; if (!e) { return this.resolve([]) } for (var g = new Array(e), h = 0, i = -1, j = new this(d); ++i < e;) { b(a[i], i) } return j } function n (a) { function b (a) { c.resolve(a).then(function (a) { f || (f = !0, p.resolve(h, a)) }, function (a) { f || (f = !0, p.reject(h, a)) }) } var c = this; if (Object.prototype.toString.call(a) !== '[object Array]') { return this.reject(new TypeError('must be an array')) } const e = a.length; var f = !1; if (!e) { return this.resolve([]) } for (var g = -1, h = new this(d); ++g < e;) { b(a[g]) } return h } var o = a(1); var p = {}; const q = ['REJECTED']; const r = ['FULFILLED']; var s = ['PENDING']; b.exports = e, e.prototype.catch = function (a) { return this.then(null, a) }, e.prototype.then = function (a, b) { if (typeof a !== 'function' && this.state === r || typeof b !== 'function' && this.state === q) { return this } const c = new this.constructor(d); if (this.state !== s) { g(c, this.state === r ? a : b, this.outcome) } else { this.queue.push(new f(c, a, b)) } return c }, f.prototype.callFulfilled = function (a) { p.resolve(this.promise, a) }, f.prototype.otherCallFulfilled = function (a) { g(this.promise, this.onFulfilled, a) }, f.prototype.callRejected = function (a) { p.reject(this.promise, a) }, f.prototype.otherCallRejected = function (a) { g(this.promise, this.onRejected, a) }, p.resolve = function (a, b) { const c = j(h, b); if (c.status === 'error') { return p.reject(a, c.value) } const d = c.value; if (d) { i(a, d) } else { a.state = r, a.outcome = b; for (let e = -1, f = a.queue.length; ++e < f;) { a.queue[e].callFulfilled(b) } } return a }, p.reject = function (a, b) { a.state = q, a.outcome = b; for (let c = -1, d = a.queue.length; ++c < d;) { a.queue[c].callRejected(b) } return a }, e.resolve = k, e.reject = l, e.all = m, e.race = n }, { 1: 1 }], 3: [function (a, b, c) { (function (b) { 'use strict'; typeof b.Promise !== 'function' && (b.Promise = a(2)) }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}) }, { 2: 2 }], 4: [function (a, b, c) { 'use strict'; function d (a, b) { if (!(a instanceof b)) { throw new TypeError('Cannot call a class as a function') } } function e () { try { if (typeof indexedDB !== 'undefined') { return indexedDB } if (typeof webkitIndexedDB !== 'undefined') { return webkitIndexedDB } if (typeof mozIndexedDB !== 'undefined') { return mozIndexedDB } if (typeof OIndexedDB !== 'undefined') { return OIndexedDB } if (typeof msIndexedDB !== 'undefined') { return msIndexedDB } } catch (a) { } } function f () { try { if (!ua) { return !1 } const a = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform); const b = typeof fetch === 'function' && fetch.toString().includes('[native code'); return (!a || b) && typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined' } catch (a) { return !1 } } function g (a, b) { a = a || [], b = b || {}; try { return new Blob(a, b) } catch (f) { if (f.name !== 'TypeError') { throw f } for (var c = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder, d = new c(), e = 0; e < a.length; e += 1) { d.append(a[e]) } return d.getBlob(b.type) } } function h (a, b) { b && a.then(function (a) { b(null, a) }, function (a) { b(a) }) } function i (a, b, c) { typeof b === 'function' && a.then(b), typeof c === 'function' && a.catch(c) } function j (a) { return typeof a !== 'string' && (console.warn(a + ' used as a key, but it is not a string.'), a = String(a)), a } function k () { if (arguments.length && typeof arguments[arguments.length - 1] === 'function') { return arguments[arguments.length - 1] } } function l (a) { for (var b = a.length, c = new ArrayBuffer(b), d = new Uint8Array(c), e = 0; e < b; e++) { d[e] = a.charCodeAt(e) } return c } function m (a) { return new va(function (b) { const c = a.transaction(wa, Ba); const d = g(['']); c.objectStore(wa).put(d, 'key'), c.onabort = function (a) { a.preventDefault(), a.stopPropagation(), b(!1) }, c.oncomplete = function () { const a = navigator.userAgent.match(/Chrome\/(\d+)/); const c = navigator.userAgent.match(/Edge\//); b(c || !a || parseInt(a[1], 10) >= 43) } }).catch(function () { return !1 }) } function n (a) { return typeof xa === 'boolean' ? va.resolve(xa) : m(a).then(function (a) { return xa = a }) } function o (a) { const b = ya[a.name]; const c = {}; c.promise = new va(function (a, b) { c.resolve = a, c.reject = b }), b.deferredOperations.push(c), b.dbReady ? b.dbReady = b.dbReady.then(function () { return c.promise }) : b.dbReady = c.promise } function p (a) { const b = ya[a.name]; const c = b.deferredOperations.pop(); if (c) { return c.resolve(), c.promise } } function q (a, b) { const c = ya[a.name]; const d = c.deferredOperations.pop(); if (d) { return d.reject(b), d.promise } } function r (a, b) { return new va(function (c, d) { if (ya[a.name] = ya[a.name] || B(), a.db) { if (!b) { return c(a.db) } o(a), a.db.close() } const e = [a.name]; b && e.push(a.version); const f = ua.open.apply(ua, e); b && (f.onupgradeneeded = function (b) { const c = f.result; try { c.createObjectStore(a.storeName), b.oldVersion <= 1 && c.createObjectStore(wa) } catch (c) { if (c.name !== 'ConstraintError') { throw c } console.warn('The database "' + a.name + '" has been upgraded from version ' + b.oldVersion + ' to version ' + b.newVersion + ', but the storage "' + a.storeName + '" already exists.') } }), f.onerror = function (a) { a.preventDefault(), d(f.error) }, f.onsuccess = function () { c(f.result), p(a) } }) } function s (a) { return r(a, !1) } function t (a) { return r(a, !0) } function u (a, b) { if (!a.db) { return !0 } const c = !a.db.objectStoreNames.contains(a.storeName); const d = a.version < a.db.version; const e = a.version > a.db.version; if (d && (a.version !== b && console.warn('The database "' + a.name + "\" can't be downgraded from version " + a.db.version + ' to version ' + a.version + '.'), a.version = a.db.version), e || c) { if (c) { const f = a.db.version + 1; f > a.version && (a.version = f) } return !0 } return !1 } function v (a) { return new va(function (b, c) { const d = new FileReader(); d.onerror = c, d.onloadend = function (c) { const d = btoa(c.target.result || ''); b({ __local_forage_encoded_blob: !0, data: d, type: a.type }) }, d.readAsBinaryString(a) }) } function w (a) { return g([l(atob(a.data))], { type: a.type }) } function x (a) { return a && a.__local_forage_encoded_blob } function y (a) { const b = this; const c = b._initReady().then(function () { const a = ya[b._dbInfo.name]; if (a && a.dbReady) { return a.dbReady } }); return i(c, a, a), c } function z (a) { o(a); for (var b = ya[a.name], c = b.forages, d = 0; d < c.length; d++) { const e = c[d]; e._dbInfo.db && (e._dbInfo.db.close(), e._dbInfo.db = null) } return a.db = null, s(a).then(function (b) { return a.db = b, u(a) ? t(a) : b }).then(function (d) { a.db = b.db = d; for (let e = 0; e < c.length; e++) { c[e]._dbInfo.db = d } }).catch(function (b) { throw q(a, b), b }) } function A (a, b, c, d) { void 0 === d && (d = 1); try { const e = a.db.transaction(a.storeName, b); c(null, e) } catch (e) { if (d > 0 && (!a.db || e.name === 'InvalidStateError' || e.name === 'NotFoundError')) { return va.resolve().then(function () { if (!a.db || e.name === 'NotFoundError' && !a.db.objectStoreNames.contains(a.storeName) && a.version <= a.db.version) { return a.db && (a.version = a.db.version + 1), t(a) } }).then(function () { return z(a).then(function () { A(a, b, c, d - 1) }) }).catch(c) } c(e) } } function B () { return { forages: [], db: null, dbReady: null, deferredOperations: [] } } function C (a) { function b () { return va.resolve() } const c = this; const d = { db: null }; if (a) { for (const e in a) { d[e] = a[e] } } let f = ya[d.name]; f || (f = B(), ya[d.name] = f), f.forages.push(c), c._initReady || (c._initReady = c.ready, c.ready = y); for (var g = [], h = 0; h < f.forages.length; h++) { const i = f.forages[h]; i !== c && g.push(i._initReady().catch(b)) } const j = f.forages.slice(0); return va.all(g).then(function () { return d.db = f.db, s(d) }).then(function (a) { return d.db = a, u(d, c._defaultConfig.version) ? t(d) : a }).then(function (a) { d.db = f.db = a, c._dbInfo = d; for (let b = 0; b < j.length; b++) { const e = j[b]; e !== c && (e._dbInfo.db = d.db, e._dbInfo.version = d.version) } }) } function D (a, b) { const c = this; a = j(a); const d = new va(function (b, d) { c.ready().then(function () { A(c._dbInfo, Aa, function (e, f) { if (e) { return d(e) } try { const g = f.objectStore(c._dbInfo.storeName); const h = g.get(a); h.onsuccess = function () { let a = h.result; void 0 === a && (a = null), x(a) && (a = w(a)), b(a) }, h.onerror = function () { d(h.error) } } catch (a) { d(a) } }) }).catch(d) }); return h(d, b), d } function E (a, b) { const c = this; const d = new va(function (b, d) { c.ready().then(function () { A(c._dbInfo, Aa, function (e, f) { if (e) { return d(e) } try { const g = f.objectStore(c._dbInfo.storeName); const h = g.openCursor(); let i = 1; h.onsuccess = function () { const c = h.result; if (c) { let d = c.value; x(d) && (d = w(d)); const e = a(d, c.key, i++); void 0 !== e ? b(e) : c.continue() } else { b() } }, h.onerror = function () { d(h.error) } } catch (a) { d(a) } }) }).catch(d) }); return h(d, b), d } function F (a, b, c) { const d = this; a = j(a); const e = new va(function (c, e) { let f; d.ready().then(function () { return f = d._dbInfo, za.call(b) === '[object Blob]' ? n(f.db).then(function (a) { return a ? b : v(b) }) : b }).then(function (b) { A(d._dbInfo, Ba, function (f, g) { if (f) { return e(f) } try { const h = g.objectStore(d._dbInfo.storeName); b === null && (b = void 0); const i = h.put(b, a); g.oncomplete = function () { void 0 === b && (b = null), c(b) }, g.onabort = g.onerror = function () { const a = i.error ? i.error : i.transaction.error; e(a) } } catch (a) { e(a) } }) }).catch(e) }); return h(e, c), e } function G (a, b) { const c = this; a = j(a); const d = new va(function (b, d) { c.ready().then(function () { A(c._dbInfo, Ba, function (e, f) { if (e) { return d(e) } try { const g = f.objectStore(c._dbInfo.storeName); const h = g.delete(a); f.oncomplete = function () { b() }, f.onerror = function () { d(h.error) }, f.onabort = function () { const a = h.error ? h.error : h.transaction.error; d(a) } } catch (a) { d(a) } }) }).catch(d) }); return h(d, b), d } function H (a) { const b = this; const c = new va(function (a, c) { b.ready().then(function () { A(b._dbInfo, Ba, function (d, e) { if (d) { return c(d) } try { const f = e.objectStore(b._dbInfo.storeName); const g = f.clear(); e.oncomplete = function () { a() }, e.onabort = e.onerror = function () { const a = g.error ? g.error : g.transaction.error; c(a) } } catch (a) { c(a) } }) }).catch(c) }); return h(c, a), c } function I (a) { const b = this; const c = new va(function (a, c) { b.ready().then(function () { A(b._dbInfo, Aa, function (d, e) { if (d) { return c(d) } try { const f = e.objectStore(b._dbInfo.storeName); const g = f.count(); g.onsuccess = function () { a(g.result) }, g.onerror = function () { c(g.error) } } catch (a) { c(a) } }) }).catch(c) }); return h(c, a), c } function J (a, b) { const c = this; const d = new va(function (b, d) { if (a < 0) { return void b(null) } c.ready().then(function () { A(c._dbInfo, Aa, function (e, f) { if (e) { return d(e) } try { const g = f.objectStore(c._dbInfo.storeName); let h = !1; const i = g.openCursor(); i.onsuccess = function () { const c = i.result; if (!c) { return void b(null) } a === 0 ? b(c.key) : h ? b(c.key) : (h = !0, c.advance(a)) }, i.onerror = function () { d(i.error) } } catch (a) { d(a) } }) }).catch(d) }); return h(d, b), d } function K (a) { const b = this; const c = new va(function (a, c) { b.ready().then(function () { A(b._dbInfo, Aa, function (d, e) { if (d) { return c(d) } try { const f = e.objectStore(b._dbInfo.storeName); const g = f.openCursor(); const h = []; g.onsuccess = function () { const b = g.result; if (!b) { return void a(h) } h.push(b.key), b.continue() }, g.onerror = function () { c(g.error) } } catch (a) { c(a) } }) }).catch(c) }); return h(c, a), c } function L (a, b) { b = k.apply(this, arguments); const c = this.config(); a = typeof a !== 'function' && a || {}, a.name || (a.name = a.name || c.name, a.storeName = a.storeName || c.storeName); let d; const e = this; if (a.name) { const f = a.name === c.name && e._dbInfo.db; const g = f ? va.resolve(e._dbInfo.db) : s(a).then(function (b) { const c = ya[a.name]; const d = c.forages; c.db = b; for (let e = 0; e < d.length; e++) { d[e]._dbInfo.db = b } return b }); d = a.storeName ? g.then(function (b) { if (b.objectStoreNames.contains(a.storeName)) { const c = b.version + 1; o(a); const d = ya[a.name]; const e = d.forages; b.close(); for (let f = 0; f < e.length; f++) { const g = e[f]; g._dbInfo.db = null, g._dbInfo.version = c } return new va(function (b, d) { const e = ua.open(a.name, c); e.onerror = function (a) { e.result.close(), d(a) }, e.onupgradeneeded = function () { e.result.deleteObjectStore(a.storeName) }, e.onsuccess = function () { const a = e.result; a.close(), b(a) } }).then(function (a) { d.db = a; for (let b = 0; b < e.length; b++) { const c = e[b]; c._dbInfo.db = a, p(c._dbInfo) } }).catch(function (b) { throw (q(a, b) || va.resolve()).catch(function () {}), b }) } }) : g.then(function (b) { o(a); const c = ya[a.name]; const d = c.forages; b.close(); for (let e = 0; e < d.length; e++) { d[e]._dbInfo.db = null } return new va(function (b, c) { const d = ua.deleteDatabase(a.name); d.onerror = d.onblocked = function (a) { const b = d.result; b && b.close(), c(a) }, d.onsuccess = function () { const a = d.result; a && a.close(), b(a) } }).then(function (a) { c.db = a; for (let b = 0; b < d.length; b++) { p(d[b]._dbInfo) } }).catch(function (b) { throw (q(a, b) || va.resolve()).catch(function () {}), b }) }) } else { d = va.reject('Invalid arguments') } return h(d, b), d } function M () { return typeof openDatabase === 'function' } function N (a) { let b; let c; let d; let e; let f; let g = 0.75 * a.length; const h = a.length; let i = 0; a[a.length - 1] === '=' && (g--, a[a.length - 2] === '=' && g--); const j = new ArrayBuffer(g); const k = new Uint8Array(j); for (b = 0; b < h; b += 4) { c = Da.indexOf(a[b]), d = Da.indexOf(a[b + 1]), e = Da.indexOf(a[b + 2]), f = Da.indexOf(a[b + 3]), k[i++] = c << 2 | d >> 4, k[i++] = (15 & d) << 4 | e >> 2, k[i++] = (3 & e) << 6 | 63 & f } return j } function O (a) { let b; const c = new Uint8Array(a); let d = ''; for (b = 0; b < c.length; b += 3) { d += Da[c[b] >> 2], d += Da[(3 & c[b]) << 4 | c[b + 1] >> 4], d += Da[(15 & c[b + 1]) << 2 | c[b + 2] >> 6], d += Da[63 & c[b + 2]] } return c.length % 3 == 2 ? d = d.substring(0, d.length - 1) + '=' : c.length % 3 == 1 && (d = d.substring(0, d.length - 2) + '=='), d } function P (a, b) { let c = ''; if (a && (c = Ua.call(a)), a && (c === '[object ArrayBuffer]' || a.buffer && Ua.call(a.buffer) === '[object ArrayBuffer]')) { let d; let e = Ga; a instanceof ArrayBuffer ? (d = a, e += Ia) : (d = a.buffer, c === '[object Int8Array]' ? e += Ka : c === '[object Uint8Array]' ? e += La : c === '[object Uint8ClampedArray]' ? e += Ma : c === '[object Int16Array]' ? e += Na : c === '[object Uint16Array]' ? e += Pa : c === '[object Int32Array]' ? e += Oa : c === '[object Uint32Array]' ? e += Qa : c === '[object Float32Array]' ? e += Ra : c === '[object Float64Array]' ? e += Sa : b(new Error('Failed to get type for BinaryArray'))), b(e + O(d)) } else if (c === '[object Blob]') { const f = new FileReader(); f.onload = function () { const c = Ea + a.type + '~' + O(this.result); b(Ga + Ja + c) }, f.readAsArrayBuffer(a) } else { try { b(JSON.stringify(a)) } catch (c) { console.error("Couldn't convert value into a JSON string: ", a), b(null, c) } } } function Q (a) { if (a.substring(0, Ha) !== Ga) { return JSON.parse(a) } let b; let c = a.substring(Ta); const d = a.substring(Ha, Ta); if (d === Ja && Fa.test(c)) { const e = c.match(Fa); b = e[1], c = c.substring(e[0].length) } const f = N(c); switch (d) { case Ia:return f; case Ja:return g([f], { type: b }); case Ka:return new Int8Array(f); case La:return new Uint8Array(f); case Ma:return new Uint8ClampedArray(f); case Na:return new Int16Array(f); case Pa:return new Uint16Array(f); case Oa:return new Int32Array(f); case Qa:return new Uint32Array(f); case Ra:return new Float32Array(f); case Sa:return new Float64Array(f); default:throw new Error('Unkown type: ' + d) } } function R (a, b, c, d) { a.executeSql('CREATE TABLE IF NOT EXISTS ' + b.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], c, d) } function S (a) { const b = this; const c = { db: null }; if (a) { for (const d in a) { c[d] = typeof a[d] !== 'string' ? a[d].toString() : a[d] } } const e = new va(function (a, d) { try { c.db = openDatabase(c.name, String(c.version), c.description, c.size) } catch (a) { return d(a) }c.db.transaction(function (e) { R(e, c, function () { b._dbInfo = c, a() }, function (a, b) { d(b) }) }, d) }); return c.serializer = Va, e } function T (a, b, c, d, e, f) { a.executeSql(c, d, e, function (a, g) { g.code === g.SYNTAX_ERR ? a.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [b.storeName], function (a, h) { h.rows.length ? f(a, g) : R(a, b, function () { a.executeSql(c, d, e, f) }, f) }, f) : f(a, g) }, f) } function U (a, b) { const c = this; a = j(a); const d = new va(function (b, d) { c.ready().then(function () { const e = c._dbInfo; e.db.transaction(function (c) { T(c, e, 'SELECT * FROM ' + e.storeName + ' WHERE key = ? LIMIT 1', [a], function (a, c) { let d = c.rows.length ? c.rows.item(0).value : null; d && (d = e.serializer.deserialize(d)), b(d) }, function (a, b) { d(b) }) }) }).catch(d) }); return h(d, b), d } function V (a, b) { const c = this; const d = new va(function (b, d) { c.ready().then(function () { const e = c._dbInfo; e.db.transaction(function (c) { T(c, e, 'SELECT * FROM ' + e.storeName, [], function (c, d) { for (let f = d.rows, g = f.length, h = 0; h < g; h++) { const i = f.item(h); let j = i.value; if (j && (j = e.serializer.deserialize(j)), void 0 !== (j = a(j, i.key, h + 1))) { return void b(j) } }b() }, function (a, b) { d(b) }) }) }).catch(d) }); return h(d, b), d } function W (a, b, c, d) { const e = this; a = j(a); const f = new va(function (f, g) { e.ready().then(function () { void 0 === b && (b = null); const h = b; const i = e._dbInfo; i.serializer.serialize(b, function (b, j) { j ? g(j) : i.db.transaction(function (c) { T(c, i, 'INSERT OR REPLACE INTO ' + i.storeName + ' (key, value) VALUES (?, ?)', [a, b], function () { f(h) }, function (a, b) { g(b) }) }, function (b) { if (b.code === b.QUOTA_ERR) { if (d > 0) { return void f(W.apply(e, [a, h, c, d - 1])) } g(b) } }) }) }).catch(g) }); return h(f, c), f } function X (a, b, c) { return W.apply(this, [a, b, c, 1]) } function Y (a, b) { const c = this; a = j(a); const d = new va(function (b, d) { c.ready().then(function () { const e = c._dbInfo; e.db.transaction(function (c) { T(c, e, 'DELETE FROM ' + e.storeName + ' WHERE key = ?', [a], function () { b() }, function (a, b) { d(b) }) }) }).catch(d) }); return h(d, b), d } function Z (a) { const b = this; const c = new va(function (a, c) { b.ready().then(function () { const d = b._dbInfo; d.db.transaction(function (b) { T(b, d, 'DELETE FROM ' + d.storeName, [], function () { a() }, function (a, b) { c(b) }) }) }).catch(c) }); return h(c, a), c } function $ (a) { const b = this; const c = new va(function (a, c) { b.ready().then(function () { const d = b._dbInfo; d.db.transaction(function (b) { T(b, d, 'SELECT COUNT(key) as c FROM ' + d.storeName, [], function (b, c) { const d = c.rows.item(0).c; a(d) }, function (a, b) { c(b) }) }) }).catch(c) }); return h(c, a), c } function _ (a, b) { const c = this; const d = new va(function (b, d) { c.ready().then(function () { const e = c._dbInfo; e.db.transaction(function (c) { T(c, e, 'SELECT key FROM ' + e.storeName + ' WHERE id = ? LIMIT 1', [a + 1], function (a, c) { const d = c.rows.length ? c.rows.item(0).key : null; b(d) }, function (a, b) { d(b) }) }) }).catch(d) }); return h(d, b), d } function aa (a) { const b = this; const c = new va(function (a, c) { b.ready().then(function () { const d = b._dbInfo; d.db.transaction(function (b) { T(b, d, 'SELECT key FROM ' + d.storeName, [], function (b, c) { for (var d = [], e = 0; e < c.rows.length; e++) { d.push(c.rows.item(e).key) }a(d) }, function (a, b) { c(b) }) }) }).catch(c) }); return h(c, a), c } function ba (a) { return new va(function (b, c) { a.transaction(function (d) { d.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (c, d) { for (var e = [], f = 0; f < d.rows.length; f++) { e.push(d.rows.item(f).name) }b({ db: a, storeNames: e }) }, function (a, b) { c(b) }) }, function (a) { c(a) }) }) } function ca (a, b) { b = k.apply(this, arguments); const c = this.config(); a = typeof a !== 'function' && a || {}, a.name || (a.name = a.name || c.name, a.storeName = a.storeName || c.storeName); let d; const e = this; return d = a.name ? new va(function (b) { let d; d = a.name === c.name ? e._dbInfo.db : openDatabase(a.name, '', '', 0), b(a.storeName ? { db: d, storeNames: [a.storeName] } : ba(d)) }).then(function (a) { return new va(function (b, c) { a.db.transaction(function (d) { function e (a) { return new va(function (b, c) { d.executeSql('DROP TABLE IF EXISTS ' + a, [], function () { b() }, function (a, b) { c(b) }) }) } for (var f = [], g = 0, h = a.storeNames.length; g < h; g++) { f.push(e(a.storeNames[g])) }va.all(f).then(function () { b() }).catch(function (a) { c(a) }) }, function (a) { c(a) }) }) }) : va.reject('Invalid arguments'), h(d, b), d } function da () { try { return typeof localStorage !== 'undefined' && 'setItem' in localStorage && !!localStorage.setItem } catch (a) { return !1 } } function ea (a, b) { let c = a.name + '/'; return a.storeName !== b.storeName && (c += a.storeName + '/'), c } function fa () { const a = '_localforage_support_test'; try { return localStorage.setItem(a, !0), localStorage.removeItem(a), !1 } catch (a) { return !0 } } function ga () { return !fa() || localStorage.length > 0 } function ha (a) { const b = this; const c = {}; if (a) { for (const d in a) { c[d] = a[d] } } return c.keyPrefix = ea(a, b._defaultConfig), ga() ? (b._dbInfo = c, c.serializer = Va, va.resolve()) : va.reject() } function ia (a) { const b = this; const c = b.ready().then(function () { for (let a = b._dbInfo.keyPrefix, c = localStorage.length - 1; c >= 0; c--) { const d = localStorage.key(c); d.indexOf(a) === 0 && localStorage.removeItem(d) } }); return h(c, a), c } function ja (a, b) { const c = this; a = j(a); const d = c.ready().then(function () { const b = c._dbInfo; let d = localStorage.getItem(b.keyPrefix + a); return d && (d = b.serializer.deserialize(d)), d }); return h(d, b), d } function ka (a, b) { const c = this; const d = c.ready().then(function () { for (let b = c._dbInfo, d = b.keyPrefix, e = d.length, f = localStorage.length, g = 1, h = 0; h < f; h++) { const i = localStorage.key(h); if (i.indexOf(d) === 0) { let j = localStorage.getItem(i); if (j && (j = b.serializer.deserialize(j)), void 0 !== (j = a(j, i.substring(e), g++))) { return j } } } }); return h(d, b), d } function la (a, b) { const c = this; const d = c.ready().then(function () { let b; const d = c._dbInfo; try { b = localStorage.key(a) } catch (a) { b = null } return b && (b = b.substring(d.keyPrefix.length)), b }); return h(d, b), d } function ma (a) { const b = this; const c = b.ready().then(function () { for (var a = b._dbInfo, c = localStorage.length, d = [], e = 0; e < c; e++) { const f = localStorage.key(e); f.indexOf(a.keyPrefix) === 0 && d.push(f.substring(a.keyPrefix.length)) } return d }); return h(c, a), c } function na (a) { const b = this; const c = b.keys().then(function (a) { return a.length }); return h(c, a), c } function oa (a, b) { const c = this; a = j(a); const d = c.ready().then(function () { const b = c._dbInfo; localStorage.removeItem(b.keyPrefix + a) }); return h(d, b), d } function pa (a, b, c) { const d = this; a = j(a); const e = d.ready().then(function () { void 0 === b && (b = null); const c = b; return new va(function (e, f) { const g = d._dbInfo; g.serializer.serialize(b, function (b, d) { if (d) { f(d) } else { try { localStorage.setItem(g.keyPrefix + a, b), e(c) } catch (a) { a.name !== 'QuotaExceededError' && a.name !== 'NS_ERROR_DOM_QUOTA_REACHED' || f(a), f(a) } } }) }) }); return h(e, c), e } function qa (a, b) { if (b = k.apply(this, arguments), a = typeof a !== 'function' && a || {}, !a.name) { const c = this.config(); a.name = a.name || c.name, a.storeName = a.storeName || c.storeName } let d; const e = this; return d = a.name ? new va(function (b) { b(a.storeName ? ea(a, e._defaultConfig) : a.name + '/') }).then(function (a) { for (let b = localStorage.length - 1; b >= 0; b--) { const c = localStorage.key(b); c.indexOf(a) === 0 && localStorage.removeItem(c) } }) : va.reject('Invalid arguments'), h(d, b), d } function ra (a, b) { a[b] = function () { const c = arguments; return a.ready().then(function () { return a[b].apply(a, c) }) } } function sa () { for (let a = 1; a < arguments.length; a++) { const b = arguments[a]; if (b) { for (const c in b) { b.hasOwnProperty(c) && ($a(b[c]) ? arguments[0][c] = b[c].slice() : arguments[0][c] = b[c]) } } } return arguments[0] } const ta = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (a) { return typeof a } : function (a) { return a && typeof Symbol === 'function' && a.constructor === Symbol && a !== Symbol.prototype ? 'symbol' : typeof a }; var ua = e(); typeof Promise === 'undefined' && a(3); var va = Promise; var wa = 'local-forage-detect-blob-support'; var xa = void 0; var ya = {}; var za = Object.prototype.toString; var Aa = 'readonly'; var Ba = 'readwrite'; const Ca = { _driver: 'asyncStorage', _initStorage: C, _support: f(), iterate: E, getItem: D, setItem: F, removeItem: G, clear: H, length: I, key: J, keys: K, dropInstance: L }; var Da = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; var Ea = '~~local_forage_type~'; var Fa = /^~~local_forage_type~([^~]+)~/; var Ga = '__lfsc__:'; var Ha = Ga.length; var Ia = 'arbf'; var Ja = 'blob'; var Ka = 'si08'; var La = 'ui08'; var Ma = 'uic8'; var Na = 'si16'; var Oa = 'si32'; var Pa = 'ur16'; var Qa = 'ui32'; var Ra = 'fl32'; var Sa = 'fl64'; var Ta = Ha + Ia.length; var Ua = Object.prototype.toString; var Va = { serialize: P, deserialize: Q, stringToBuffer: N, bufferToString: O }; const Wa = { _driver: 'webSQLStorage', _initStorage: S, _support: M(), iterate: V, getItem: U, setItem: X, removeItem: Y, clear: Z, length: $, key: _, keys: aa, dropInstance: ca }; const Xa = { _driver: 'localStorageWrapper', _initStorage: ha, _support: da(), iterate: ka, getItem: ja, setItem: pa, removeItem: oa, clear: ia, length: na, key: la, keys: ma, dropInstance: qa }; const Ya = function (a, b) { return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b) }; const Za = function (a, b) { for (let c = a.length, d = 0; d < c;) { if (Ya(a[d], b)) { return !0 } d++ } return !1 }; var $a = Array.isArray || function (a) { return Object.prototype.toString.call(a) === '[object Array]' }; const _a = {}; const ab = {}; const bb = { INDEXEDDB: Ca, WEBSQL: Wa, LOCALSTORAGE: Xa }; const cb = [bb.INDEXEDDB._driver, bb.WEBSQL._driver, bb.LOCALSTORAGE._driver]; const db = ['dropInstance']; const eb = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(db); const fb = { description: '', driver: cb.slice(), name: 'localforage', size: 4980736, storeName: 'keyvaluepairs', version: 1 }; const gb = (function () { function a (b) { d(this, a); for (const c in bb) { if (bb.hasOwnProperty(c)) { const e = bb[c]; const f = e._driver; this[c] = f, _a[f] || this.defineDriver(e) } } this._defaultConfig = sa({}, fb), this._config = sa({}, this._defaultConfig, b), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function () {}) } return a.prototype.config = function (a) { if ((void 0 === a ? 'undefined' : ta(a)) === 'object') { if (this._ready) { return new Error("Can't call config() after localforage has been used.") } for (const b in a) { if (b === 'storeName' && (a[b] = a[b].replace(/\W/g, '_')), b === 'version' && typeof a[b] !== 'number') { return new Error('Database version must be a number.') } this._config[b] = a[b] } return !('driver' in a && a.driver) || this.setDriver(this._config.driver) } return typeof a === 'string' ? this._config[a] : this._config }, a.prototype.defineDriver = function (a, b, c) { const d = new va(function (b, c) { try { const d = a._driver; const e = new Error('Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver'); if (!a._driver) { return void c(e) } for (let f = eb.concat('_initStorage'), g = 0, i = f.length; g < i; g++) { const j = f[g]; if ((!Za(db, j) || a[j]) && typeof a[j] !== 'function') { return void c(e) } }(function () { for (let b = function (a) { return function () { const b = new Error('Method ' + a + ' is not implemented by the current driver'); const c = va.reject(b); return h(c, arguments[arguments.length - 1]), c } }, c = 0, d = db.length; c < d; c++) { const e = db[c]; a[e] || (a[e] = b(e)) } })(); const k = function (c) { _a[d] && console.info('Redefining LocalForage driver: ' + d), _a[d] = a, ab[d] = c, b() }; '_support' in a ? a._support && typeof a._support === 'function' ? a._support().then(k, c) : k(!!a._support) : k(!0) } catch (a) { c(a) } }); return i(d, b, c), d }, a.prototype.driver = function () { return this._driver || null }, a.prototype.getDriver = function (a, b, c) { const d = _a[a] ? va.resolve(_a[a]) : va.reject(new Error('Driver not found.')); return i(d, b, c), d }, a.prototype.getSerializer = function (a) { const b = va.resolve(Va); return i(b, a), b }, a.prototype.ready = function (a) { const b = this; const c = b._driverSet.then(function () { return b._ready === null && (b._ready = b._initDriver()), b._ready }); return i(c, a, a), c }, a.prototype.setDriver = function (a, b, c) { function d () { g._config.driver = g.driver() } function e (a) { return g._extend(a), d(), g._ready = g._initStorage(g._config), g._ready } function f (a) { return function () { function b () { for (;c < a.length;) { const f = a[c]; return c++, g._dbInfo = null, g._ready = null, g.getDriver(f).then(e).catch(b) }d(); const h = new Error('No available storage method found.'); return g._driverSet = va.reject(h), g._driverSet } var c = 0; return b() } } var g = this; $a(a) || (a = [a]); const h = this._getSupportedDrivers(a); const j = this._driverSet !== null ? this._driverSet.catch(function () { return va.resolve() }) : va.resolve(); return this._driverSet = j.then(function () { const a = h[0]; return g._dbInfo = null, g._ready = null, g.getDriver(a).then(function (a) { g._driver = a._driver, d(), g._wrapLibraryMethodsWithReady(), g._initDriver = f(h) }) }).catch(function () { d(); const a = new Error('No available storage method found.'); return g._driverSet = va.reject(a), g._driverSet }), i(this._driverSet, b, c), this._driverSet }, a.prototype.supports = function (a) { return !!ab[a] }, a.prototype._extend = function (a) { sa(this, a) }, a.prototype._getSupportedDrivers = function (a) { for (var b = [], c = 0, d = a.length; c < d; c++) { const e = a[c]; this.supports(e) && b.push(e) } return b }, a.prototype._wrapLibraryMethodsWithReady = function () { for (let a = 0, b = eb.length; a < b; a++) { ra(this, eb[a]) } }, a.prototype.createInstance = function (b) { return new a(b) }, a }()); const hb = new gb(); b.exports = hb }, { 3: 3 }] }, {}, [4]))(4) }))
